var tipuesearch = {"pages":[{"title":" FTDSS ","text":"FTDSS 土壌凍結融解過程における数値計算ソルバーへの実装 Warning Work in progress 概要 土壌凍結融解過程の水分・熱移動の数値計算 Note このプロジェクトでは，Fortranで係れている． Todo リファクタリング コマンドライン引数への対応 他 Bug 現在の所バグは見つかっていない． Developer Info Kikuchi Shun","tags":"home","loc":"index.html"},{"title":"Heat – FTDSS ","text":"type, public :: Heat Inherits type~~heat~~InheritsGraph type~heat Heat type~geometry_2d Geometry_2D type~heat->type~geometry_2d Geometry type~hcf HCF type~heat->type~hcf HCFs type~boudary_condition Boudary_Condition type~heat->type~boudary_condition BC type~shape Shape type~geometry_2d->type~shape Shape_Function type~dp2d DP2d type~geometry_2d->type~dp2d Nodes_2D type~hcf_parameters HCF_Parameters type~hcf->type~hcf_parameters type~boudary_condition_dirichlet Boudary_Condition_Dirichlet type~boudary_condition->type~boudary_condition_dirichlet Dirichlet type~boudary_condition_neumann Boudary_Condition_Neumann type~boudary_condition->type~boudary_condition_neumann Neumann Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Geometry BC HCFs Constructor Heat Source Code Heat Components Type Visibility Attributes Name Initial type( Geometry_2D ), private :: Geometry type( Boudary_Condition ), private :: BC type( HCF ), private :: HCFs Constructor public interface Heat private function Heat_Constructor (Structure_Input) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Structure_Input Return Value type( Heat ) Source Code type Heat type ( Geometry_2D ) :: Geometry type ( Boudary_Condition ) :: BC type ( HCF ) :: HCFs ! integer(int32)              :: Num_Elements, Num_Nodes, Num_Shape, Num_Dimention, Num_Shape_Type, Num_Region ! integer(int32), allocatable :: Element(:,:) ! integer(int32), allocatable :: Element_Region(:), COO_Region(:) ! type(DP2d)                  :: Nodes_2D ! real(real64),   allocatable :: Area(:) ! type(Shape)                 :: Shape_Function contains end type Heat","tags":"","loc":"type/heat.html"},{"title":"Output – FTDSS ","text":"type, public :: Output Contents Variables Output_Observation_Flag T_FileName Fr_FileName TC_FileName C_FileName P_FileName Flux_FileName K_FileName dir_Path is_Output is_Output_Dat is_Output_VTK Constructor Output Type-Bound Procedures Output_All Output_Observation Source Code Output Components Type Visibility Attributes Name Initial integer(kind=int32), private, allocatable :: Output_Observation_Flag (:) character(len=256), private :: T_FileName character(len=256), private :: Fr_FileName character(len=256), private :: TC_FileName character(len=256), private :: C_FileName character(len=256), private :: P_FileName character(len=256), private :: Flux_FileName character(len=256), private :: K_FileName character(len=256), private :: dir_Path logical, private, allocatable :: is_Output (:) logical, private :: is_Output_Dat logical, private :: is_Output_VTK Constructor public interface Output private function Output_Constructor (Inputs) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Inputs Return Value type( Output ) Type-Bound Procedures procedure, public :: Output_All => Inout_Output_All private subroutine Inout_Output_All (self, Solver, num) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: num procedure, public :: Output_Observation => Inout_Output_Observation private subroutine Inout_Output_Observation (self, Solver, time) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver real(kind=real64), intent(in) :: time Source Code type :: Output private integer ( int32 ), allocatable :: Output_Observation_Flag (:) character ( 256 ) :: T_FileName , Fr_FileName , TC_FileName , C_FileName , P_FileName , Flux_FileName , K_FileName character ( 256 ) :: dir_Path logical , allocatable :: is_Output (:) logical :: is_Output_Dat , is_Output_VTK contains ! procedure :: Output_All         => Inout_Output_All_vtk procedure :: Output_All => Inout_Output_All procedure :: Output_Observation => Inout_Output_Observation end type Output","tags":"","loc":"type/output.html"},{"title":"HCF – FTDSS ","text":"type, public, extends( HCF_Parameters ) :: HCF Inherits type~~hcf~~InheritsGraph type~hcf HCF type~hcf_parameters HCF_Parameters type~hcf->type~hcf_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~hcf~~InheritedByGraph type~hcf HCF type~heat Heat type~heat->type~hcf HCFs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 alpha2 n1 n2 m1 m2 hcrit w1 w2 Ks kzero l Omega Calculate_HCF Calculate_HCF_mu Constructor HCF Type-Bound Procedures Calculate_Kflh Source Code HCF Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: Ks real(kind=real64), public :: kzero real(kind=real64), public :: l real(kind=real64), public :: Omega procedure( Calculation_HCF ), public, pointer, nopass :: Calculate_HCF => null() procedure( Calculation_HCF_mu ), public, pointer, nopass :: Calculate_HCF_mu => null() Constructor public interface HCF public function HCF_Constructor (in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in_HCF_Parameters (:) integer(kind=int32), intent(in) :: HCF_Model_id integer(kind=int32), intent(in) :: Kflh_Model_id Return Value type( HCF ) Type-Bound Procedures procedure, public :: Calculate_Kflh => Calculate_Ks public function Calculate_Ks (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name class( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Source Code type , extends ( HCF_Parameters ) :: HCF private procedure ( Calculation_HCF ), pointer , nopass :: Calculate_HCF => null () procedure ( Calculation_HCF_mu ), pointer , nopass :: Calculate_HCF_mu => null () contains procedure :: Calculate_Kflh => Calculate_Ks end type HCF","tags":"","loc":"type/hcf.html"},{"title":"VC – FTDSS ","text":"type, public :: VC sequence Contents Variables x y Source Code VC Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y Source Code type :: VC sequence real ( real64 ) :: x , y end type VC","tags":"","loc":"type/vc.html"},{"title":"Vector2D – FTDSS ","text":"type, public :: Vector2D sequence Inherited by type~~vector2d~~InheritedByGraph type~vector2d Vector2D type~type_thermalconductivity_3phase_dispersity_2d Type_ThermalConductivity_3Phase_Dispersity_2D type~type_thermalconductivity_3phase_dispersity_2d->type~vector2d dispersity type~heatconstants HeatConstants type~heatconstants->type~vector2d dispersity type~heatfields HeatFields type~heatfields->type~heatconstants Constants type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x y Source Code Vector2D Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y Source Code type :: Vector2D sequence real ( real64 ) :: x , y end type Vector2D","tags":"","loc":"type/vector2d.html"},{"title":"Vector3D – FTDSS ","text":"type, public :: Vector3D sequence Inherited by type~~vector3d~~InheritedByGraph type~vector3d Vector3D type~type_thermalconductivity_3phase_dispersity_3d Type_ThermalConductivity_3Phase_Dispersity_3D type~type_thermalconductivity_3phase_dispersity_3d->type~vector3d dispersity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x y z Source Code Vector3D Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y real(kind=real64), public :: z Source Code type :: Vector3D sequence real ( real64 ) :: x , y , z end type Vector3D","tags":"","loc":"type/vector3d.html"},{"title":"DP2d – FTDSS ","text":"type, public :: DP2d sequence Inherited by type~~dp2d~~InheritedByGraph type~dp2d DP2d type~watervariables WaterVariables type~watervariables->type~dp2d wFlux, hGrad type~observation2d Observation2d type~observation2d->type~dp2d obsCOO type~geometry_2d Geometry_2D type~geometry_2d->type~dp2d Nodes_2D type~geometry2d Geometry2d type~geometry2d->type~dp2d vCood type~heatvariables HeatVariables type~heatvariables->type~dp2d Tgrad, TFlux type~waterfields WaterFields type~waterfields->type~watervariables Variables type~heatfields HeatFields type~heatfields->type~heatvariables Variables type~heat Heat type~heat->type~geometry_2d Geometry type~solverinfo SolverInfo type~solverinfo->type~observation2d Obs type~solverinfo->type~geometry2d N type~solverinfo->type~waterfields Water type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x y Source Code DP2d Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: x (:) real(kind=real64), public, allocatable :: y (:) Source Code type :: DP2d sequence real ( real64 ), allocatable :: x (:), y (:) end type DP2d","tags":"","loc":"type/dp2d.html"},{"title":"DP3d – FTDSS ","text":"type, public :: DP3d sequence Contents Variables x y z Source Code DP3d Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: x (:) real(kind=real64), public, allocatable :: y (:) real(kind=real64), public, allocatable :: z (:) Source Code type :: DP3d sequence real ( real64 ), allocatable :: x (:), y (:), z (:) end type DP3d","tags":"","loc":"type/dp3d.html"},{"title":"INT2d – FTDSS ","text":"type, public :: INT2d sequence Inherited by type~~int2d~~InheritedByGraph type~int2d INT2d type~boudaryconditioninfo BoudaryConditionInfo type~boudaryconditioninfo->type~int2d Edges type~boudarycondition BoudaryCondition type~boudarycondition->type~boudaryconditioninfo Heat, Water, Stress type~solverinfo SolverInfo type~solverinfo->type~boudarycondition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x y Source Code INT2d Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: x (:) integer(kind=int32), public, allocatable :: y (:) Source Code type :: INT2d sequence integer ( int32 ), allocatable :: x (:), y (:) end type INT2d","tags":"","loc":"type/int2d.html"},{"title":"INT3d – FTDSS ","text":"type, public :: INT3d sequence Contents Variables x y z Source Code INT3d Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: x (:) integer(kind=int32), public, allocatable :: y (:) integer(kind=int32), public, allocatable :: z (:) Source Code type :: INT3d sequence integer ( int32 ), allocatable :: x (:), y (:), z (:) end type INT3d","tags":"","loc":"type/int3d.html"},{"title":"PH – FTDSS ","text":"type, public :: PH sequence Contents Variables soil water ice Source Code PH Components Type Visibility Attributes Name Initial real(kind=real64), public :: soil real(kind=real64), public :: water real(kind=real64), public :: ice Source Code type :: PH sequence real ( real64 ) :: soil , water , ice end type PH","tags":"","loc":"type/ph.html"},{"title":"Phases – FTDSS ","text":"type, public :: Phases sequence Inherited by type~~phases~~InheritedByGraph type~phases Phases type~heatconstants HeatConstants type~heatconstants->type~phases Density, ThermalConductivity, SpecificHeat, HeatCapacity type~waterconstants WaterConstants type~waterconstants->type~phases HydraulicConductivity type~heatfields HeatFields type~heatfields->type~heatconstants Constants type~waterfields WaterFields type~waterfields->type~waterconstants Constants type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat type~solverinfo->type~waterfields Water Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables soil water ice Source Code Phases Components Type Visibility Attributes Name Initial real(kind=real64), public :: soil real(kind=real64), public :: water real(kind=real64), public :: ice Source Code type :: Phases sequence real ( real64 ) :: soil , water , ice end type Phases","tags":"","loc":"type/phases.html"},{"title":"Shape – FTDSS ","text":"type, public :: Shape sequence Inherited by type~~shape~~InheritedByGraph type~shape Shape type~geometry_2d Geometry_2D type~geometry_2d->type~shape Shape_Function type~geometry2d Geometry2d type~geometry2d->type~shape Basis type~heat Heat type~heat->type~geometry_2d Geometry type~solverinfo SolverInfo type~solverinfo->type~geometry2d N Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a b c d Source Code Shape Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: a (:,:) real(kind=real64), public, allocatable :: b (:,:) real(kind=real64), public, allocatable :: c (:,:) real(kind=real64), public, allocatable :: d (:,:) Source Code type :: Shape sequence real ( real64 ), allocatable :: a (:, :), b (:, :), c (:, :), d (:, :) end type Shape","tags":"","loc":"type/shape.html"},{"title":"BoudaryConditionInfo – FTDSS ","text":"type, public :: BoudaryConditionInfo Inherits type~~boudaryconditioninfo~~InheritsGraph type~boudaryconditioninfo BoudaryConditionInfo type~int2d INT2d type~boudaryconditioninfo->type~int2d Edges Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~boudaryconditioninfo~~InheritedByGraph type~boudaryconditioninfo BoudaryConditionInfo type~boudarycondition BoudaryCondition type~boudarycondition->type~boudaryconditioninfo Heat, Water, Stress type~solverinfo SolverInfo type~solverinfo->type~boudarycondition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Node TypeKey type value Edges EdgesDirection EdgesDistance Source Code BoudaryConditionInfo Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: Node (:) integer(kind=int32), public, allocatable :: TypeKey (:) integer(kind=int32), public, allocatable :: type (:) real(kind=real64), public, allocatable :: value (:) type( INT2d ), public :: Edges integer(kind=int32), public, allocatable :: EdgesDirection (:) real(kind=real64), public, allocatable :: EdgesDistance (:) Source Code type :: BoudaryConditionInfo integer ( int32 ), allocatable :: Node (:) ! <= BC.in integer ( int32 ), allocatable :: TypeKey (:) ! <= BC.in integer ( int32 ), allocatable :: type (:) ! <= BCtype.in real ( real64 ), allocatable :: value (:) ! <= BCtype.in type ( INT2d ) :: Edges integer ( int32 ), allocatable :: EdgesDirection (:) real ( real64 ), allocatable :: EdgesDistance (:) end type BoudaryConditionInfo","tags":"","loc":"type/boudaryconditioninfo.html"},{"title":"BoudaryCondition – FTDSS ","text":"type, public :: BoudaryCondition Inherits type~~boudarycondition~~InheritsGraph type~boudarycondition BoudaryCondition type~boudaryconditioninfo BoudaryConditionInfo type~boudarycondition->type~boudaryconditioninfo Heat, Water, Stress type~int2d INT2d type~boudaryconditioninfo->type~int2d Edges Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~boudarycondition~~InheritedByGraph type~boudarycondition BoudaryCondition type~solverinfo SolverInfo type~solverinfo->type~boudarycondition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Heat Water Stress numNode numType numEdges Source Code BoudaryCondition Components Type Visibility Attributes Name Initial type( BoudaryConditionInfo ), public :: Heat type( BoudaryConditionInfo ), public :: Water type( BoudaryConditionInfo ), public :: Stress integer(kind=int32), public :: numNode integer(kind=int32), public :: numType integer(kind=int32), public :: numEdges Source Code type :: BoudaryCondition type ( BoudaryConditionInfo ) :: Heat , Water , Stress integer ( int32 ) :: numNode , numType , numEdges end type BoudaryCondition","tags":"","loc":"type/boudarycondition.html"},{"title":"Boudary_Condition_Dirichlet – FTDSS ","text":"type, public :: Boudary_Condition_Dirichlet Inherited by type~~boudary_condition_dirichlet~~InheritedByGraph type~boudary_condition_dirichlet Boudary_Condition_Dirichlet type~boudary_condition Boudary_Condition type~boudary_condition->type~boudary_condition_dirichlet Dirichlet type~heat Heat type~heat->type~boudary_condition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Num_Node Num_Type Node Node_Type Value_Info value Source Code Boudary_Condition_Dirichlet Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Node integer(kind=int32), public :: Num_Type integer(kind=int32), public, allocatable :: Node (:) integer(kind=int32), public, allocatable :: Node_Type (:) integer(kind=int32), public, allocatable :: Value_Info (:) real(kind=real64), public, allocatable :: value (:) Source Code type :: Boudary_Condition_Dirichlet integer ( int32 ) :: Num_Node , Num_Type integer ( int32 ), allocatable :: Node (:), Node_Type (:), Value_Info (:) real ( real64 ), allocatable :: value (:) end type Boudary_Condition_Dirichlet","tags":"","loc":"type/boudary_condition_dirichlet.html"},{"title":"Boudary_Condition_Neumann – FTDSS ","text":"type, public :: Boudary_Condition_Neumann Inherited by type~~boudary_condition_neumann~~InheritedByGraph type~boudary_condition_neumann Boudary_Condition_Neumann type~boudary_condition Boudary_Condition type~boudary_condition->type~boudary_condition_neumann Neumann type~heat Heat type~heat->type~boudary_condition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Num_Edge Num_Edge_Type Num_Type Edge Edge_Type Value_Info value Heat_Transfer Source Code Boudary_Condition_Neumann Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Edge integer(kind=int32), public :: Num_Edge_Type integer(kind=int32), public :: Num_Type integer(kind=int32), public, allocatable :: Edge (:,:) integer(kind=int32), public, allocatable :: Edge_Type (:) integer(kind=int32), public, allocatable :: Value_Info (:) real(kind=real64), public, allocatable :: value (:) real(kind=real64), public, allocatable :: Heat_Transfer (:) Source Code type :: Boudary_Condition_Neumann integer ( int32 ) :: Num_Edge , Num_Edge_Type , Num_Type integer ( int32 ), allocatable :: Edge (:, :), Edge_Type (:), Value_Info (:) real ( real64 ), allocatable :: value (:), Heat_Transfer (:) end type Boudary_Condition_Neumann","tags":"","loc":"type/boudary_condition_neumann.html"},{"title":"Boudary_Condition – FTDSS ","text":"type, public :: Boudary_Condition Inherits type~~boudary_condition~~InheritsGraph type~boudary_condition Boudary_Condition type~boudary_condition_dirichlet Boudary_Condition_Dirichlet type~boudary_condition->type~boudary_condition_dirichlet Dirichlet type~boudary_condition_neumann Boudary_Condition_Neumann type~boudary_condition->type~boudary_condition_neumann Neumann Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~boudary_condition~~InheritedByGraph type~boudary_condition Boudary_Condition type~heat Heat type~heat->type~boudary_condition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Dirichlet Neumann Source Code Boudary_Condition Components Type Visibility Attributes Name Initial type( Boudary_Condition_Dirichlet ), public :: Dirichlet type( Boudary_Condition_Neumann ), public :: Neumann Source Code type :: Boudary_Condition type ( Boudary_Condition_Dirichlet ) :: Dirichlet type ( Boudary_Condition_Neumann ) :: Neumann end type Boudary_Condition","tags":"","loc":"type/boudary_condition.html"},{"title":"InitialConditionInfo – FTDSS ","text":"type, public :: InitialConditionInfo Inherited by type~~initialconditioninfo~~InheritedByGraph type~initialconditioninfo InitialConditionInfo type~initialcondition InitialCondition type~initialcondition->type~initialconditioninfo Heat, Water, Stress type~solverinfo SolverInfo type~solverinfo->type~initialcondition IC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables type value isSet Source Code InitialConditionInfo Components Type Visibility Attributes Name Initial integer(kind=int32), public :: type real(kind=real64), public :: value logical, public :: isSet Source Code type :: InitialConditionInfo integer ( int32 ) :: type real ( real64 ) :: value logical :: isSet end type InitialConditionInfo","tags":"","loc":"type/initialconditioninfo.html"},{"title":"InitialCondition – FTDSS ","text":"type, public :: InitialCondition Inherits type~~initialcondition~~InheritsGraph type~initialcondition InitialCondition type~initialconditioninfo InitialConditionInfo type~initialcondition->type~initialconditioninfo Heat, Water, Stress Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~initialcondition~~InheritedByGraph type~initialcondition InitialCondition type~solverinfo SolverInfo type~solverinfo->type~initialcondition IC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Heat Water Stress Source Code InitialCondition Components Type Visibility Attributes Name Initial type( InitialConditionInfo ), public :: Heat type( InitialConditionInfo ), public :: Water type( InitialConditionInfo ), public :: Stress Source Code type :: InitialCondition type ( InitialConditionInfo ) :: Heat , Water , Stress end type InitialCondition","tags":"","loc":"type/initialcondition.html"},{"title":"MPIInfo – FTDSS ","text":"type, public :: MPIInfo Inherited by type~~mpiinfo~~InheritedByGraph type~mpiinfo MPIInfo type~solverinfo SolverInfo type~solverinfo->type~mpiinfo MPI Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables size rank Source Code MPIInfo Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size integer(kind=int32), public :: rank Source Code type :: MPIInfo integer ( int32 ) :: size , rank end type MPIInfo","tags":"","loc":"type/mpiinfo.html"},{"title":"Basic_params – FTDSS ","text":"type, public :: Basic_params Contents Variables Element Node Shape Dim Region Calculation_timeUnit Input_timeUnit Output_timeUnit Interval_timeUnit Calculation_step CalculationPeriod Interval isDisplayPrompt FileOutput TimeDiscretization Source Code Basic_params Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Element integer(kind=int32), public :: Node integer(kind=int32), public :: Shape integer(kind=int32), public :: Dim integer(kind=int32), public :: Region character, public, allocatable :: Calculation_timeUnit character, public, allocatable :: Input_timeUnit character, public, allocatable :: Output_timeUnit character, public, allocatable :: Interval_timeUnit integer(kind=int32), public :: Calculation_step integer(kind=int32), public :: CalculationPeriod integer(kind=int32), public :: Interval logical, public :: isDisplayPrompt character, public, allocatable :: FileOutput real(kind=real64), public :: TimeDiscretization Source Code type :: Basic_params integer ( int32 ) :: Element integer ( int32 ) :: Node integer ( int32 ) :: Shape integer ( int32 ) :: Dim integer ( int32 ) :: Region character (:), allocatable :: Calculation_timeUnit character (:), allocatable :: Input_timeUnit character (:), allocatable :: Output_timeUnit character (:), allocatable :: Interval_timeUnit integer ( int32 ) :: Calculation_step integer ( int32 ) :: CalculationPeriod integer ( int32 ) :: Interval logical :: isDisplayPrompt character (:), allocatable :: FileOutput real ( real64 ) :: TimeDiscretization end type Basic_params","tags":"","loc":"type/basic_params.html"},{"title":"Type_Solver – FTDSS ","text":"type, public :: Type_Solver Inherits type~~type_solver~~InheritsGraph type~type_solver Type_Solver type~base_solver Base_Solver type~type_solver->type~base_solver Thermal, Hydraulic Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Thermal Hydraulic Source Code Type_Solver Components Type Visibility Attributes Name Initial class( Base_Solver ), public, allocatable :: Thermal class( Base_Solver ), public, allocatable :: Hydraulic Source Code type :: Type_Solver class ( Base_Solver ), allocatable :: Thermal ! Solver for heat transfer class ( Base_Solver ), allocatable :: Hydraulic ! Solver for water flow end type Type_Solver","tags":"","loc":"type/type_solver.html"},{"title":"Base_Solver – FTDSS ","text":"type, public :: Base_Solver Inherited by type~~base_solver~~InheritedByGraph type~base_solver Base_Solver type~type_solver Type_Solver type~type_solver->type~base_solver Thermal, Hydraulic type~type_solver_iterative Type_Solver_Iterative type~type_solver_iterative->type~base_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables useSolver Source Code Base_Solver Components Type Visibility Attributes Name Initial integer(kind=int32), public :: useSolver Source Code type :: Base_Solver integer ( int32 ) :: useSolver ! Solver fpr execute solution 1: Direct, 2: 22Iterative end type Base_Solver","tags":"","loc":"type/base_solver.html"},{"title":"Type_Solver_Iterative – FTDSS ","text":"type, public, extends( Base_Solver ) :: Type_Solver_Iterative Inherits type~~type_solver_iterative~~InheritsGraph type~type_solver_iterative Type_Solver_Iterative type~base_solver Base_Solver type~type_solver_iterative->type~base_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables useSolver SolverType PreconditionerType MaxIter Tol Source Code Type_Solver_Iterative Components Type Visibility Attributes Name Initial integer(kind=int32), public :: useSolver integer(kind=int32), public :: SolverType integer(kind=int32), public :: PreconditionerType integer(kind=int32), public :: MaxIter real(kind=real64), public :: Tol Source Code type , extends ( Base_Solver ) :: Type_Solver_Iterative integer ( int32 ) :: SolverType ! Solver type integer ( int32 ) :: PreconditionerType ! Preconditioner type integer ( int32 ) :: MaxIter ! Maximum number of iterations real ( real64 ) :: Tol ! Convergence criterion end type Type_Solver_Iterative","tags":"","loc":"type/type_solver_iterative.html"},{"title":"Base_Density – FTDSS ","text":"type, public :: Base_Density Inherited by type~~base_density~~InheritedByGraph type~base_density Base_Density type~type_thermal Type_Thermal type~type_thermal->type~base_density Density type~type_density_1phase Type_Density_1Phase type~type_density_1phase->type~base_density type~type_density_3phase Type_Density_3Phase type~type_density_3phase->type~base_density type~type_density_2phase Type_Density_2Phase type~type_density_2phase->type~base_density type~type_region Type_Region type~type_region->type~type_thermal Thermal Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Base_Density Source Code type :: Base_Density end type Base_Density","tags":"","loc":"type/base_density.html"},{"title":"Type_Density_3Phase – FTDSS ","text":"type, public, extends( Base_Density ) :: Type_Density_3Phase Inherits type~~type_density_3phase~~InheritsGraph type~type_density_3phase Type_Density_3Phase type~base_density Base_Density type~type_density_3phase->type~base_density Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Soil Water Ice Source Code Type_Density_3Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice Source Code type , extends ( Base_Density ) :: Type_Density_3Phase real ( real64 ) :: Soil , Water , Ice end type Type_Density_3Phase","tags":"","loc":"type/type_density_3phase.html"},{"title":"Type_Density_2Phase – FTDSS ","text":"type, public, extends( Base_Density ) :: Type_Density_2Phase Inherits type~~type_density_2phase~~InheritsGraph type~type_density_2phase Type_Density_2Phase type~base_density Base_Density type~type_density_2phase->type~base_density Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Phase1 Phase2 Source Code Type_Density_2Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2 Source Code type , extends ( Base_Density ) :: Type_Density_2Phase real ( real64 ) :: Phase1 , Phase2 end type Type_Density_2Phase","tags":"","loc":"type/type_density_2phase.html"},{"title":"Type_Density_1Phase – FTDSS ","text":"type, public, extends( Base_Density ) :: Type_Density_1Phase Inherits type~~type_density_1phase~~InheritsGraph type~type_density_1phase Type_Density_1Phase type~base_density Base_Density type~type_density_1phase->type~base_density Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Phase1 Source Code Type_Density_1Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 Source Code type , extends ( Base_Density ) :: Type_Density_1Phase real ( real64 ) :: Phase1 end type Type_Density_1Phase","tags":"","loc":"type/type_density_1phase.html"},{"title":"Base_SpecificHeat – FTDSS ","text":"type, public :: Base_SpecificHeat Inherited by type~~base_specificheat~~InheritedByGraph type~base_specificheat Base_SpecificHeat type~type_thermal Type_Thermal type~type_thermal->type~base_specificheat SpecificHeat type~type_specificheat_3phase Type_SpecificHeat_3Phase type~type_specificheat_3phase->type~base_specificheat type~type_specificheat_2phase Type_SpecificHeat_2Phase type~type_specificheat_2phase->type~base_specificheat type~type_specificheat_1phase Type_SpecificHeat_1Phase type~type_specificheat_1phase->type~base_specificheat type~type_region Type_Region type~type_region->type~type_thermal Thermal Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Base_SpecificHeat Source Code type :: Base_SpecificHeat end type Base_SpecificHeat","tags":"","loc":"type/base_specificheat.html"},{"title":"Type_SpecificHeat_3Phase – FTDSS ","text":"type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_3Phase Inherits type~~type_specificheat_3phase~~InheritsGraph type~type_specificheat_3phase Type_SpecificHeat_3Phase type~base_specificheat Base_SpecificHeat type~type_specificheat_3phase->type~base_specificheat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Soil Water Ice Source Code Type_SpecificHeat_3Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice Source Code type , extends ( Base_SpecificHeat ) :: Type_SpecificHeat_3Phase real ( real64 ) :: Soil ! Soil specific heat real ( real64 ) :: Water ! Water specific heat real ( real64 ) :: Ice ! Ice specific heat end type Type_SpecificHeat_3Phase","tags":"","loc":"type/type_specificheat_3phase.html"},{"title":"Type_SpecificHeat_2Phase – FTDSS ","text":"type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_2Phase Inherits type~~type_specificheat_2phase~~InheritsGraph type~type_specificheat_2phase Type_SpecificHeat_2Phase type~base_specificheat Base_SpecificHeat type~type_specificheat_2phase->type~base_specificheat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Phase1 Phase2 Source Code Type_SpecificHeat_2Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2 Source Code type , extends ( Base_SpecificHeat ) :: Type_SpecificHeat_2Phase real ( real64 ) :: Phase1 , Phase2 end type Type_SpecificHeat_2Phase","tags":"","loc":"type/type_specificheat_2phase.html"},{"title":"Type_SpecificHeat_1Phase – FTDSS ","text":"type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_1Phase Inherits type~~type_specificheat_1phase~~InheritsGraph type~type_specificheat_1phase Type_SpecificHeat_1Phase type~base_specificheat Base_SpecificHeat type~type_specificheat_1phase->type~base_specificheat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Phase1 Source Code Type_SpecificHeat_1Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 Source Code type , extends ( Base_SpecificHeat ) :: Type_SpecificHeat_1Phase real ( real64 ) :: Phase1 end type Type_SpecificHeat_1Phase","tags":"","loc":"type/type_specificheat_1phase.html"},{"title":"Base_ThermalConductivity – FTDSS ","text":"type, public :: Base_ThermalConductivity Inherited by type~~base_thermalconductivity~~InheritedByGraph type~base_thermalconductivity Base_ThermalConductivity type~type_thermal Type_Thermal type~type_thermal->type~base_thermalconductivity ThermalConductivity type~type_thermalconductivity_1phase Type_ThermalConductivity_1Phase type~type_thermalconductivity_1phase->type~base_thermalconductivity type~type_thermalconductivity_2phase Type_ThermalConductivity_2Phase type~type_thermalconductivity_2phase->type~base_thermalconductivity type~type_thermalconductivity_3phase Type_ThermalConductivity_3Phase type~type_thermalconductivity_3phase->type~base_thermalconductivity type~type_region Type_Region type~type_region->type~type_thermal Thermal type~type_thermalconductivity_3phase_dispersity_2d Type_ThermalConductivity_3Phase_Dispersity_2D type~type_thermalconductivity_3phase_dispersity_2d->type~type_thermalconductivity_3phase type~type_thermalconductivity_3phase_dispersity_3d Type_ThermalConductivity_3Phase_Dispersity_3D type~type_thermalconductivity_3phase_dispersity_3d->type~type_thermalconductivity_3phase Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Base_ThermalConductivity Source Code type :: Base_ThermalConductivity end type Base_ThermalConductivity","tags":"","loc":"type/base_thermalconductivity.html"},{"title":"Type_ThermalConductivity_3Phase – FTDSS ","text":"type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_3Phase Inherits type~~type_thermalconductivity_3phase~~InheritsGraph type~type_thermalconductivity_3phase Type_ThermalConductivity_3Phase type~base_thermalconductivity Base_ThermalConductivity type~type_thermalconductivity_3phase->type~base_thermalconductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~type_thermalconductivity_3phase~~InheritedByGraph type~type_thermalconductivity_3phase Type_ThermalConductivity_3Phase type~type_thermalconductivity_3phase_dispersity_2d Type_ThermalConductivity_3Phase_Dispersity_2D type~type_thermalconductivity_3phase_dispersity_2d->type~type_thermalconductivity_3phase type~type_thermalconductivity_3phase_dispersity_3d Type_ThermalConductivity_3Phase_Dispersity_3D type~type_thermalconductivity_3phase_dispersity_3d->type~type_thermalconductivity_3phase Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Soil Water Ice Source Code Type_ThermalConductivity_3Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice Source Code type , extends ( Base_ThermalConductivity ) :: Type_ThermalConductivity_3Phase real ( real64 ) :: Soil , Water , Ice end type Type_ThermalConductivity_3Phase","tags":"","loc":"type/type_thermalconductivity_3phase.html"},{"title":"Type_ThermalConductivity_3Phase_Dispersity_2D – FTDSS ","text":"type, public, extends( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_2D Inherits type~~type_thermalconductivity_3phase_dispersity_2d~~InheritsGraph type~type_thermalconductivity_3phase_dispersity_2d Type_ThermalConductivity_3Phase_Dispersity_2D type~vector2d Vector2D type~type_thermalconductivity_3phase_dispersity_2d->type~vector2d dispersity type~type_thermalconductivity_3phase Type_ThermalConductivity_3Phase type~type_thermalconductivity_3phase_dispersity_2d->type~type_thermalconductivity_3phase type~base_thermalconductivity Base_ThermalConductivity type~type_thermalconductivity_3phase->type~base_thermalconductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Soil Water Ice dispersity Source Code Type_ThermalConductivity_3Phase_Dispersity_2D Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type( Vector2D ), public :: dispersity Source Code type , extends ( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_2D type ( Vector2D ) :: dispersity end type Type_ThermalConductivity_3Phase_Dispersity_2D","tags":"","loc":"type/type_thermalconductivity_3phase_dispersity_2d.html"},{"title":"Type_ThermalConductivity_3Phase_Dispersity_3D – FTDSS ","text":"type, public, extends( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_3D Inherits type~~type_thermalconductivity_3phase_dispersity_3d~~InheritsGraph type~type_thermalconductivity_3phase_dispersity_3d Type_ThermalConductivity_3Phase_Dispersity_3D type~vector3d Vector3D type~type_thermalconductivity_3phase_dispersity_3d->type~vector3d dispersity type~type_thermalconductivity_3phase Type_ThermalConductivity_3Phase type~type_thermalconductivity_3phase_dispersity_3d->type~type_thermalconductivity_3phase type~base_thermalconductivity Base_ThermalConductivity type~type_thermalconductivity_3phase->type~base_thermalconductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Soil Water Ice dispersity Source Code Type_ThermalConductivity_3Phase_Dispersity_3D Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type( Vector3D ), public :: dispersity Source Code type , extends ( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_3D type ( Vector3D ) :: dispersity end type Type_ThermalConductivity_3Phase_Dispersity_3D","tags":"","loc":"type/type_thermalconductivity_3phase_dispersity_3d.html"},{"title":"Type_ThermalConductivity_2Phase – FTDSS ","text":"type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_2Phase Inherits type~~type_thermalconductivity_2phase~~InheritsGraph type~type_thermalconductivity_2phase Type_ThermalConductivity_2Phase type~base_thermalconductivity Base_ThermalConductivity type~type_thermalconductivity_2phase->type~base_thermalconductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Phase1 Phase2 Source Code Type_ThermalConductivity_2Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2 Source Code type , extends ( Base_ThermalConductivity ) :: Type_ThermalConductivity_2Phase real ( real64 ) :: Phase1 , Phase2 end type Type_ThermalConductivity_2Phase","tags":"","loc":"type/type_thermalconductivity_2phase.html"},{"title":"Type_ThermalConductivity_1Phase – FTDSS ","text":"type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_1Phase Inherits type~~type_thermalconductivity_1phase~~InheritsGraph type~type_thermalconductivity_1phase Type_ThermalConductivity_1Phase type~base_thermalconductivity Base_ThermalConductivity type~type_thermalconductivity_1phase->type~base_thermalconductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Phase1 Source Code Type_ThermalConductivity_1Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 Source Code type , extends ( Base_ThermalConductivity ) :: Type_ThermalConductivity_1Phase real ( real64 ) :: Phase1 end type Type_ThermalConductivity_1Phase","tags":"","loc":"type/type_thermalconductivity_1phase.html"},{"title":"Base_Ice – FTDSS ","text":"type, public :: Base_Ice Inherited by type~~base_ice~~InheritedByGraph type~base_ice Base_Ice type~type_thermal Type_Thermal type~type_thermal->type~base_ice Ice type~type_ice_gcc Type_Ice_GCC type~type_ice_gcc->type~base_ice type~type_ice_trm Type_Ice_TRM type~type_ice_trm->type~base_ice type~type_ice_exp Type_Ice_EXP type~type_ice_exp->type~base_ice type~type_region Type_Region type~type_region->type~type_thermal Thermal Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables LatentHeat Source Code Base_Ice Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat Source Code type :: Base_Ice real ( real64 ) :: LatentHeat end type Base_Ice","tags":"","loc":"type/base_ice.html"},{"title":"Type_Ice_TRM – FTDSS ","text":"type, public, extends( Base_Ice ) :: Type_Ice_TRM Inherits type~~type_ice_trm~~InheritsGraph type~type_ice_trm Type_Ice_TRM type~base_ice Base_Ice type~type_ice_trm->type~base_ice Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables LatentHeat Tf Source Code Type_Ice_TRM Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf Source Code type , extends ( Base_Ice ) :: Type_Ice_TRM real ( real64 ) :: Tf end type Type_Ice_TRM","tags":"","loc":"type/type_ice_trm.html"},{"title":"Type_Ice_GCC – FTDSS ","text":"type, public, extends( Base_Ice ) :: Type_Ice_GCC Inherits type~~type_ice_gcc~~InheritsGraph type~type_ice_gcc Type_Ice_GCC type~base_wrf Base_WRF type~type_ice_gcc->type~base_wrf WRF type~base_ice Base_Ice type~type_ice_gcc->type~base_ice Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables LatentHeat Tf ModelType WRF Source Code Type_Ice_GCC Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf integer(kind=int32), public :: ModelType class( Base_WRF ), public, allocatable :: WRF Source Code type , extends ( Base_Ice ) :: Type_Ice_GCC real ( real64 ) :: Tf integer ( int32 ) :: ModelType class ( Base_WRF ), allocatable :: WRF end type Type_Ice_GCC","tags":"","loc":"type/type_ice_gcc.html"},{"title":"Type_Ice_EXP – FTDSS ","text":"type, public, extends( Base_Ice ) :: Type_Ice_EXP Inherits type~~type_ice_exp~~InheritsGraph type~type_ice_exp Type_Ice_EXP type~base_ice Base_Ice type~type_ice_exp->type~base_ice Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables LatentHeat Tf a Source Code Type_Ice_EXP Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf real(kind=real64), public :: a Source Code type , extends ( Base_Ice ) :: Type_Ice_EXP real ( real64 ) :: Tf , a end type Type_Ice_EXP","tags":"","loc":"type/type_ice_exp.html"},{"title":"Type_Thermal – FTDSS ","text":"type, public :: Type_Thermal Inherits type~~type_thermal~~InheritsGraph type~type_thermal Type_Thermal type~base_density Base_Density type~type_thermal->type~base_density Density type~base_specificheat Base_SpecificHeat type~type_thermal->type~base_specificheat SpecificHeat type~base_ice Base_Ice type~type_thermal->type~base_ice Ice type~base_thermalconductivity Base_ThermalConductivity type~type_thermal->type~base_thermalconductivity ThermalConductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~type_thermal~~InheritedByGraph type~type_thermal Type_Thermal type~type_region Type_Region type~type_region->type~type_thermal Thermal Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Density SpecificHeat ThermalConductivity Porosity Ice Source Code Type_Thermal Components Type Visibility Attributes Name Initial class( Base_Density ), public, allocatable :: Density class( Base_SpecificHeat ), public, allocatable :: SpecificHeat class( Base_ThermalConductivity ), public, allocatable :: ThermalConductivity real(kind=real64), public :: Porosity class( Base_Ice ), public, allocatable :: Ice Source Code type :: Type_Thermal class ( Base_Density ), allocatable :: Density class ( Base_SpecificHeat ), allocatable :: SpecificHeat class ( Base_ThermalConductivity ), allocatable :: ThermalConductivity real ( real64 ) :: Porosity class ( Base_Ice ), allocatable :: Ice end type Type_Thermal","tags":"","loc":"type/type_thermal.html"},{"title":"Type_Hydraulic – FTDSS ","text":"type, public :: Type_Hydraulic Inherits type~~type_hydraulic~~InheritsGraph type~type_hydraulic Type_Hydraulic type~base_hcf Base_HCF type~type_hydraulic->type~base_hcf HCF type~base_ktdynamics Base_KTDynamics type~type_hydraulic->type~base_ktdynamics KTDynamics type~base_impedance Base_Impedance type~type_hydraulic->type~base_impedance Impedance Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~type_hydraulic~~InheritedByGraph type~type_hydraulic Type_Hydraulic type~type_region Type_Region type~type_region->type~type_hydraulic Hydraulic Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables useHCF HCF useImpedance Impedance useKTDynamics KTDynamics Ks Source Code Type_Hydraulic Components Type Visibility Attributes Name Initial integer(kind=int32), public :: useHCF class( Base_HCF ), public, allocatable :: HCF logical, public :: useImpedance class( Base_Impedance ), public, allocatable :: Impedance integer(kind=int32), public :: useKTDynamics class( Base_KTDynamics ), public, allocatable :: KTDynamics real(kind=real64), public :: Ks Source Code type :: Type_Hydraulic integer ( int32 ) :: useHCF class ( Base_HCF ), allocatable :: HCF logical :: useImpedance class ( Base_Impedance ), allocatable :: Impedance integer ( int32 ) :: useKTDynamics class ( Base_KTDynamics ), allocatable :: KTDynamics real ( real64 ) :: Ks end type Type_Hydraulic","tags":"","loc":"type/type_hydraulic.html"},{"title":"Base_Impedance – FTDSS ","text":"type, public :: Base_Impedance Inherited by type~~base_impedance~~InheritedByGraph type~base_impedance Base_Impedance type~type_hydraulic Type_Hydraulic type~type_hydraulic->type~base_impedance Impedance type~type_impedance Type_Impedance type~type_impedance->type~base_impedance type~type_region Type_Region type~type_region->type~type_hydraulic Hydraulic Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Base_Impedance Source Code type Base_Impedance end type Base_Impedance","tags":"","loc":"type/base_impedance.html"},{"title":"Type_Impedance – FTDSS ","text":"type, public, extends( Base_Impedance ) :: Type_Impedance Inherits type~~type_impedance~~InheritsGraph type~type_impedance Type_Impedance type~base_impedance Base_Impedance type~type_impedance->type~base_impedance Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Omega Source Code Type_Impedance Components Type Visibility Attributes Name Initial real(kind=real64), public :: Omega Source Code type , extends ( Base_Impedance ) :: Type_Impedance real ( real64 ) :: Omega end type Type_Impedance","tags":"","loc":"type/type_impedance.html"},{"title":"Base_KTDynamics – FTDSS ","text":"type, public :: Base_KTDynamics Inherited by type~~base_ktdynamics~~InheritedByGraph type~base_ktdynamics Base_KTDynamics type~type_hydraulic Type_Hydraulic type~type_hydraulic->type~base_ktdynamics KTDynamics type~type_ktdynamics Type_KTDynamics type~type_ktdynamics->type~base_ktdynamics type~type_region Type_Region type~type_region->type~type_hydraulic Hydraulic Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Base_KTDynamics Source Code type :: Base_KTDynamics end type Base_KTDynamics","tags":"","loc":"type/base_ktdynamics.html"},{"title":"Type_KTDynamics – FTDSS ","text":"type, public, extends( Base_KTDynamics ) :: Type_KTDynamics Inherits type~~type_ktdynamics~~InheritsGraph type~type_ktdynamics Type_KTDynamics type~base_ktdynamics Base_KTDynamics type~type_ktdynamics->type~base_ktdynamics Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables kzero Source Code Type_KTDynamics Components Type Visibility Attributes Name Initial real(kind=real64), public :: kzero Source Code type , extends ( Base_KTDynamics ) :: Type_KTDynamics real ( real64 ) :: kzero end type Type_KTDynamics","tags":"","loc":"type/type_ktdynamics.html"},{"title":"Type_Region_Flags – FTDSS ","text":"type, public :: Type_Region_Flags Inherited by type~~type_region_flags~~InheritedByGraph type~type_region_flags Type_Region_Flags type~type_region Type_Region type~type_region->type~type_region_flags Flags Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables isHeat isWater isStress is1Phase is2Phase is3Phase isCompression isFrostHeavePressure isDispersity isFrozen Source Code Type_Region_Flags Components Type Visibility Attributes Name Initial logical, public :: isHeat logical, public :: isWater logical, public :: isStress logical, public :: is1Phase logical, public :: is2Phase logical, public :: is3Phase logical, public :: isCompression logical, public :: isFrostHeavePressure logical, public :: isDispersity logical, public :: isFrozen Source Code type :: Type_Region_Flags logical :: isHeat , isWater , isStress logical :: is1Phase , is2Phase , is3Phase logical :: isCompression , isFrostHeavePressure , isDispersity logical :: isFrozen end type Type_Region_Flags","tags":"","loc":"type/type_region_flags.html"},{"title":"Type_Region – FTDSS ","text":"type, public :: Type_Region Inherits type~~type_region~~InheritsGraph type~type_region Type_Region type~type_thermal Type_Thermal type~type_region->type~type_thermal Thermal type~type_hydraulic Type_Hydraulic type~type_region->type~type_hydraulic Hydraulic type~type_region_flags Type_Region_Flags type~type_region->type~type_region_flags Flags type~base_specificheat Base_SpecificHeat type~type_thermal->type~base_specificheat SpecificHeat type~base_ice Base_Ice type~type_thermal->type~base_ice Ice type~base_density Base_Density type~type_thermal->type~base_density Density type~base_thermalconductivity Base_ThermalConductivity type~type_thermal->type~base_thermalconductivity ThermalConductivity type~base_hcf Base_HCF type~type_hydraulic->type~base_hcf HCF type~base_ktdynamics Base_KTDynamics type~type_hydraulic->type~base_ktdynamics KTDynamics type~base_impedance Base_Impedance type~type_hydraulic->type~base_impedance Impedance Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables CalculationType Modelnumber Thermal Hydraulic Flags Source Code Type_Region Components Type Visibility Attributes Name Initial integer(kind=int32), public :: CalculationType integer(kind=int32), public :: Modelnumber type( Type_Thermal ), public :: Thermal type( Type_Hydraulic ), public :: Hydraulic type( Type_Region_Flags ), public :: Flags Source Code type :: Type_Region integer ( int32 ) :: CalculationType integer ( int32 ) :: Modelnumber type ( Type_Thermal ) :: Thermal type ( Type_Hydraulic ) :: Hydraulic type ( Type_Region_Flags ) :: Flags end type Type_Region","tags":"","loc":"type/type_region.html"},{"title":"DF – FTDSS ","text":"type, public :: DF Inherited by type~~df~~InheritedByGraph type~df DF type~heatvariables HeatVariables type~heatvariables->type~df Cs, Cp, lambda, rho, Ca type~watervariables WaterVariables type~watervariables->type~df Klh type~solverinfo SolverInfo type~solverinfo->type~df mWater, mIce, T, P, Si, Sw type~heatfields HeatFields type~solverinfo->type~heatfields Heat type~waterfields WaterFields type~solverinfo->type~waterfields Water type~heatfields->type~heatvariables Variables type~waterfields->type~watervariables Variables Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables new old pre dif div tmp Source Code DF Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: new (:) real(kind=real64), public, allocatable :: old (:) real(kind=real64), public, allocatable :: pre (:) real(kind=real64), public, allocatable :: dif (:) real(kind=real64), public, allocatable :: div (:) real(kind=real64), public, allocatable :: tmp (:) Source Code type :: DF real ( real64 ), allocatable :: new (:), old (:), pre (:), dif (:), div (:), tmp (:) end type DF","tags":"","loc":"type/df.html"},{"title":"Flag – FTDSS ","text":"type, public :: Flag Inherited by type~~flag~~InheritedByGraph type~flag Flag type~solverinfo SolverInfo type~solverinfo->type~flag Flags Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables isTRM isGCC isPower isSwitchTRM isSwitchOnceTRM isStdOut isOutputAll isOutput isPrintLisMem outOBS Source Code Flag Components Type Visibility Attributes Name Initial logical, public :: isTRM logical, public :: isGCC logical, public :: isPower logical, public :: isSwitchTRM logical, public :: isSwitchOnceTRM logical, public :: isStdOut logical, public :: isOutputAll logical, public :: isOutput logical, public :: isPrintLisMem logical, public, allocatable :: outOBS (:) Source Code type :: Flag logical :: isTRM , isGCC , isPower , isSwitchTRM , isSwitchOnceTRM logical :: isStdOut , isOutputAll , isOutput , isPrintLisMem logical , allocatable :: outOBS (:) end type Flag","tags":"","loc":"type/flag.html"},{"title":"CRS – FTDSS ","text":"type, public :: CRS Inherited by type~~crs~~InheritedByGraph type~crs CRS type~heatfields HeatFields type~heatfields->type~crs LHS_A type~ils ILS type~ils->type~crs CRS_A type~waterfields WaterFields type~waterfields->type~crs LHS_A type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat type~solverinfo->type~waterfields Water Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables nnz Ptr Ind Val Source Code CRS Components Type Visibility Attributes Name Initial integer(kind=int32), public :: nnz integer(kind=int32), public, allocatable :: Ptr (:) integer(kind=int32), public, allocatable :: Ind (:) real(kind=real64), public, allocatable :: Val (:) Source Code type :: CRS integer ( int32 ) :: nnz integer ( int32 ), allocatable :: Ptr (:), Ind (:) real ( real64 ), allocatable :: Val (:) end type CRS","tags":"","loc":"type/crs.html"},{"title":"Lis – FTDSS ","text":"type, public :: Lis Inherited by type~~lis~~InheritedByGraph type~lis Lis type~solverinfo SolverInfo type~solverinfo->type~lis Lis Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables TSolver TOption PSolver POption Maxiter Tol isOMP Source Code Lis Components Type Visibility Attributes Name Initial integer(kind=int32), public :: TSolver integer(kind=int32), public :: TOption integer(kind=int32), public :: PSolver integer(kind=int32), public :: POption integer(kind=int32), public :: Maxiter real(kind=real64), public :: Tol logical, public :: isOMP Source Code type :: Lis integer ( int32 ) :: TSolver , TOption , PSolver , POption , Maxiter real ( real64 ) :: Tol logical :: isOMP end type Lis","tags":"","loc":"type/lis.html"},{"title":"Observation2d – FTDSS ","text":"type, public :: Observation2d Inherits type~~observation2d~~InheritsGraph type~observation2d Observation2d type~dp2d DP2d type~observation2d->type~dp2d obsCOO Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~observation2d~~InheritedByGraph type~observation2d Observation2d type~solverinfo SolverInfo type~solverinfo->type~observation2d Obs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables nObs nObsType obsPoint obsCOO nAreaObs vAreaObs Source Code Observation2d Components Type Visibility Attributes Name Initial integer(kind=int32), public :: nObs integer(kind=int32), public :: nObsType integer(kind=int32), public, allocatable :: obsPoint (:) type( DP2d ), public :: obsCOO integer(kind=int32), public, allocatable :: nAreaObs (:) real(kind=real64), public, allocatable :: vAreaObs (:,:) Source Code type :: Observation2d integer ( int32 ) :: nObs , nObsType ! 1: Nodes integer ( int32 ), allocatable :: obsPoint (:) ! 2: Coordinate type ( DP2d ) :: obsCOO integer ( int32 ), allocatable :: nAreaObs (:) real ( real64 ), allocatable :: vAreaObs (:, :) end type Observation2d","tags":"","loc":"type/observation2d.html"},{"title":"HeatVariables – FTDSS ","text":"type, public :: HeatVariables Inherits type~~heatvariables~~InheritsGraph type~heatvariables HeatVariables type~df DF type~heatvariables->type~df Cs, Cp, lambda, rho, Ca type~dp2d DP2d type~heatvariables->type~dp2d Tgrad, TFlux Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~heatvariables~~InheritedByGraph type~heatvariables HeatVariables type~heatfields HeatFields type~heatfields->type~heatvariables Variables type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Cs Cp lambda rho Ca Tgrad TFlux Phase Source Code HeatVariables Components Type Visibility Attributes Name Initial type( DF ), public :: Cs type( DF ), public :: Cp type( DF ), public :: lambda type( DF ), public :: rho type( DF ), public :: Ca type( DP2d ), public :: Tgrad type( DP2d ), public :: TFlux integer(kind=int32), public, allocatable :: Phase (:) Source Code type :: HeatVariables type ( DF ) :: Cs , Cp , lambda , rho , Ca type ( DP2d ) :: Tgrad , TFlux integer ( int32 ), allocatable :: Phase (:) end type HeatVariables","tags":"","loc":"type/heatvariables.html"},{"title":"HeatConstants – FTDSS ","text":"type, public :: HeatConstants Inherits type~~heatconstants~~InheritsGraph type~heatconstants HeatConstants type~phases Phases type~heatconstants->type~phases Density, ThermalConductivity, SpecificHeat, HeatCapacity type~vector2d Vector2D type~heatconstants->type~vector2d dispersity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~heatconstants~~InheritedByGraph type~heatconstants HeatConstants type~heatfields HeatFields type~heatfields->type~heatconstants Constants type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Density ThermalConductivity SpecificHeat HeatCapacity dispersity Porosity LatentHeat Source Code HeatConstants Components Type Visibility Attributes Name Initial type( Phases ), public :: Density type( Phases ), public :: ThermalConductivity type( Phases ), public :: SpecificHeat type( Phases ), public :: HeatCapacity type( Vector2D ), public :: dispersity real(kind=real64), public :: Porosity real(kind=real64), public :: LatentHeat Source Code type HeatConstants type ( Phases ) :: Density , ThermalConductivity , SpecificHeat , HeatCapacity type ( Vector2d ) :: dispersity real ( real64 ) :: Porosity , LatentHeat end type HeatConstants","tags":"","loc":"type/heatconstants.html"},{"title":"PowerModel – FTDSS ","text":"type, public :: PowerModel Inherited by type~~powermodel~~InheritedByGraph type~powermodel PowerModel type~latentheattreatment LatentHeatTreatment type~latentheattreatment->type~powermodel Power type~heatfields HeatFields type~heatfields->type~latentheattreatment Latent type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables phi Tf a Ca_max Source Code PowerModel Components Type Visibility Attributes Name Initial real(kind=real64), public :: phi real(kind=real64), public :: Tf real(kind=real64), public :: a real(kind=real64), public :: Ca_max Source Code type PowerModel real ( real64 ) :: phi , Tf , a real ( real64 ) :: Ca_max end type PowerModel","tags":"","loc":"type/powermodel.html"},{"title":"GCCModel – FTDSS ","text":"type, public :: GCCModel Inherited by type~~gccmodel~~InheritedByGraph type~gccmodel GCCModel type~latentheattreatment LatentHeatTreatment type~latentheattreatment->type~gccmodel GCC type~heatfields HeatFields type~heatfields->type~latentheattreatment Latent type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha n m Tf Ca_max Source Code GCCModel Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha real(kind=real64), public :: n real(kind=real64), public :: m real(kind=real64), public :: Tf real(kind=real64), public :: Ca_max Source Code type :: GCCModel real ( real64 ) :: thetaS , thetaR , alpha , n , m real ( real64 ) :: Tf real ( real64 ) :: Ca_max end type GCCModel","tags":"","loc":"type/gccmodel.html"},{"title":"WRF_Parameters – FTDSS ","text":"type, public :: WRF_Parameters Contents Variables thetaS thetaR alpha1 alpha2 n1 n2 m1 m2 hcrit w1 w2 Source Code WRF_Parameters Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 Source Code type :: WRF_Parameters ! w1, w2は先に計算しておく real ( real64 ) :: thetaS , thetaR , alpha1 , alpha2 , n1 , n2 , m1 , m2 , hcrit , w1 , w2 end type WRF_Parameters","tags":"","loc":"type/wrf_parameters.html"},{"title":"Base_WRF – FTDSS ","text":"type, public :: Base_WRF Inherited by type~~base_wrf~~InheritedByGraph type~base_wrf Base_WRF type~type_wrf_ko Type_WRF_KO type~type_wrf_ko->type~base_wrf type~type_wrf_durner Type_WRF_Durner type~type_wrf_durner->type~base_wrf type~type_wrf_bc Type_WRF_BC type~type_wrf_bc->type~base_wrf type~type_ice_gcc Type_Ice_GCC type~type_ice_gcc->type~base_wrf WRF type~type_wrf_mvg Type_WRF_MVG type~type_wrf_mvg->type~base_wrf type~type_wrf_vg Type_WRF_VG type~type_wrf_vg->type~base_wrf type~type_wrf_dvgch Type_WRF_DVGCH type~type_wrf_dvgch->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR Source Code Base_WRF Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR Source Code type :: Base_WRF real ( real64 ) :: thetaS , thetaR end type Base_WRF","tags":"","loc":"type/base_wrf.html"},{"title":"Type_WRF_BC – FTDSS ","text":"type, public, extends( Base_WRF ) :: Type_WRF_BC Inherits type~~type_wrf_bc~~InheritsGraph type~type_wrf_bc Type_WRF_BC type~base_wrf Base_WRF type~type_wrf_bc->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 Source Code Type_WRF_BC Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 Source Code type , extends ( Base_WRF ) :: Type_WRF_BC real ( real64 ) :: alpha1 , n1 end type Type_WRF_BC","tags":"","loc":"type/type_wrf_bc.html"},{"title":"Type_WRF_VG – FTDSS ","text":"type, public, extends( Base_WRF ) :: Type_WRF_VG Inherits type~~type_wrf_vg~~InheritsGraph type~type_wrf_vg Type_WRF_VG type~base_wrf Base_WRF type~type_wrf_vg->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 m1 Source Code Type_WRF_VG Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 Source Code type , extends ( Base_WRF ) :: Type_WRF_VG real ( real64 ) :: alpha1 , n1 , m1 end type Type_WRF_VG","tags":"","loc":"type/type_wrf_vg.html"},{"title":"Type_WRF_KO – FTDSS ","text":"type, public, extends( Base_WRF ) :: Type_WRF_KO Inherits type~~type_wrf_ko~~InheritsGraph type~type_wrf_ko Type_WRF_KO type~base_wrf Base_WRF type~type_wrf_ko->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 Source Code Type_WRF_KO Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 Source Code type , extends ( Base_WRF ) :: Type_WRF_KO real ( real64 ) :: alpha1 , n1 end type Type_WRF_KO","tags":"","loc":"type/type_wrf_ko.html"},{"title":"Type_WRF_MVG – FTDSS ","text":"type, public, extends( Base_WRF ) :: Type_WRF_MVG Inherits type~~type_wrf_mvg~~InheritsGraph type~type_wrf_mvg Type_WRF_MVG type~base_wrf Base_WRF type~type_wrf_mvg->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 m1 hcrit Source Code Type_WRF_MVG Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: hcrit Source Code type , extends ( Base_WRF ) :: Type_WRF_MVG real ( real64 ) :: alpha1 , n1 , m1 , hcrit end type Type_WRF_MVG","tags":"","loc":"type/type_wrf_mvg.html"},{"title":"Type_WRF_Durner – FTDSS ","text":"type, public, extends( Base_WRF ) :: Type_WRF_Durner Inherits type~~type_wrf_durner~~InheritsGraph type~type_wrf_durner Type_WRF_Durner type~base_wrf Base_WRF type~type_wrf_durner->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 m1 alpha2 n2 m2 w1 w2 Source Code Type_WRF_Durner Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2 Source Code type , extends ( Base_WRF ) :: Type_WRF_Durner real ( real64 ) :: alpha1 , n1 , m1 , alpha2 , n2 , m2 , w1 , w2 end type Type_WRF_Durner","tags":"","loc":"type/type_wrf_durner.html"},{"title":"Type_WRF_DVGCH – FTDSS ","text":"type, public, extends( Base_WRF ) :: Type_WRF_DVGCH Inherits type~~type_wrf_dvgch~~InheritsGraph type~type_wrf_dvgch Type_WRF_DVGCH type~base_wrf Base_WRF type~type_wrf_dvgch->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 m1 n2 m2 w1 w2 Source Code Type_WRF_DVGCH Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2 Source Code type , extends ( Base_WRF ) :: Type_WRF_DVGCH real ( real64 ) :: alpha1 , n1 , m1 , n2 , m2 , w1 , w2 end type Type_WRF_DVGCH","tags":"","loc":"type/type_wrf_dvgch.html"},{"title":"HCF_Parameters – FTDSS ","text":"type, public :: HCF_Parameters Inherited by type~~hcf_parameters~~InheritedByGraph type~hcf_parameters HCF_Parameters type~hcf HCF type~hcf->type~hcf_parameters type~heat Heat type~heat->type~hcf HCFs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 alpha2 n1 n2 m1 m2 hcrit w1 w2 Ks kzero l Omega Source Code HCF_Parameters Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: Ks real(kind=real64), public :: kzero real(kind=real64), public :: l real(kind=real64), public :: Omega Source Code type :: HCF_Parameters real ( real64 ) :: thetaS , thetaR , alpha1 , alpha2 , n1 , n2 , m1 , m2 , hcrit , w1 , w2 real ( real64 ) :: Ks , kzero , l , Omega end type HCF_Parameters","tags":"","loc":"type/hcf_parameters.html"},{"title":"Base_HCF – FTDSS ","text":"type, public :: Base_HCF Inherited by type~~base_hcf~~InheritedByGraph type~base_hcf Base_HCF type~type_hcf_bc Type_HCF_BC type~type_hcf_bc->type~base_hcf type~type_hcf_ko Type_HCF_KO type~type_hcf_ko->type~base_hcf type~type_hcf_durner Type_HCF_Durner type~type_hcf_durner->type~base_hcf type~type_hydraulic Type_Hydraulic type~type_hydraulic->type~base_hcf HCF type~type_hcf_vg Type_HCF_VG type~type_hcf_vg->type~base_hcf type~type_hcf_mvg Type_HCF_MVG type~type_hcf_mvg->type~base_hcf type~type_hcf_dvgch Type_HCF_DVGCH type~type_hcf_dvgch->type~base_hcf type~type_region Type_Region type~type_region->type~type_hydraulic Hydraulic Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR Source Code Base_HCF Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR Source Code type :: Base_HCF real ( real64 ) :: thetaS , thetaR end type Base_HCF","tags":"","loc":"type/base_hcf.html"},{"title":"Type_HCF_BC – FTDSS ","text":"type, public, extends( Base_HCF ) :: Type_HCF_BC Inherits type~~type_hcf_bc~~InheritsGraph type~type_hcf_bc Type_HCF_BC type~base_hcf Base_HCF type~type_hcf_bc->type~base_hcf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 l Source Code Type_HCF_BC Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: l Source Code type , extends ( Base_HCF ) :: Type_HCF_BC real ( real64 ) :: alpha1 , n1 , l end type Type_HCF_BC","tags":"","loc":"type/type_hcf_bc.html"},{"title":"Type_HCF_VG – FTDSS ","text":"type, public, extends( Base_HCF ) :: Type_HCF_VG Inherits type~~type_hcf_vg~~InheritsGraph type~type_hcf_vg Type_HCF_VG type~base_hcf Base_HCF type~type_hcf_vg->type~base_hcf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 m1 l Source Code Type_HCF_VG Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: l Source Code type , extends ( Base_HCF ) :: Type_HCF_VG real ( real64 ) :: alpha1 , n1 , m1 , l end type Type_HCF_VG","tags":"","loc":"type/type_hcf_vg.html"},{"title":"Type_HCF_KO – FTDSS ","text":"type, public, extends( Base_HCF ) :: Type_HCF_KO Inherits type~~type_hcf_ko~~InheritsGraph type~type_hcf_ko Type_HCF_KO type~base_hcf Base_HCF type~type_hcf_ko->type~base_hcf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 Source Code Type_HCF_KO Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 Source Code type , extends ( Base_HCF ) :: Type_HCF_KO real ( real64 ) :: alpha1 , n1 end type Type_HCF_KO","tags":"","loc":"type/type_hcf_ko.html"},{"title":"Type_HCF_MVG – FTDSS ","text":"type, public, extends( Base_HCF ) :: Type_HCF_MVG Inherits type~~type_hcf_mvg~~InheritsGraph type~type_hcf_mvg Type_HCF_MVG type~base_hcf Base_HCF type~type_hcf_mvg->type~base_hcf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 m1 hcrit l Source Code Type_HCF_MVG Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: hcrit real(kind=real64), public :: l Source Code type , extends ( Base_HCF ) :: Type_HCF_MVG real ( real64 ) :: alpha1 , n1 , m1 , hcrit , l end type Type_HCF_MVG","tags":"","loc":"type/type_hcf_mvg.html"},{"title":"Type_HCF_Durner – FTDSS ","text":"type, public, extends( Base_HCF ) :: Type_HCF_Durner Inherits type~~type_hcf_durner~~InheritsGraph type~type_hcf_durner Type_HCF_Durner type~base_hcf Base_HCF type~type_hcf_durner->type~base_hcf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 m1 alpha2 n2 m2 w1 w2 l Source Code Type_HCF_Durner Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: l Source Code type , extends ( Base_HCF ) :: Type_HCF_Durner real ( real64 ) :: alpha1 , n1 , m1 , alpha2 , n2 , m2 , w1 , w2 , l end type Type_HCF_Durner","tags":"","loc":"type/type_hcf_durner.html"},{"title":"Type_HCF_DVGCH – FTDSS ","text":"type, public, extends( Base_HCF ) :: Type_HCF_DVGCH Inherits type~~type_hcf_dvgch~~InheritsGraph type~type_hcf_dvgch Type_HCF_DVGCH type~base_hcf Base_HCF type~type_hcf_dvgch->type~base_hcf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables thetaS thetaR alpha1 n1 m1 n2 m2 w1 w2 l Source Code Type_HCF_DVGCH Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: l Source Code type , extends ( Base_HCF ) :: Type_HCF_DVGCH real ( real64 ) :: alpha1 , n1 , m1 , n2 , m2 , w1 , w2 , l end type Type_HCF_DVGCH","tags":"","loc":"type/type_hcf_dvgch.html"},{"title":"LatentHeatTreatment – FTDSS ","text":"type, public :: LatentHeatTreatment Inherits type~~latentheattreatment~~InheritsGraph type~latentheattreatment LatentHeatTreatment type~gccmodel GCCModel type~latentheattreatment->type~gccmodel GCC type~powermodel PowerModel type~latentheattreatment->type~powermodel Power Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~latentheattreatment~~InheritedByGraph type~latentheattreatment LatentHeatTreatment type~heatfields HeatFields type~heatfields->type~latentheattreatment Latent type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables useModel Lf rhoI Cp_unf GCC Power Source Code LatentHeatTreatment Components Type Visibility Attributes Name Initial integer(kind=int32), public :: useModel real(kind=real64), public :: Lf real(kind=real64), public :: rhoI real(kind=real64), public :: Cp_unf type( GCCModel ), public :: GCC type( PowerModel ), public :: Power Source Code type :: LatentHeatTreatment integer ( int32 ) :: useModel ! 20: GCC, 30: Power real ( real64 ) :: Lf , rhoI real ( real64 ) :: Cp_unf type ( GCCModel ) :: GCC type ( PowerModel ) :: Power end type LatentHeatTreatment","tags":"","loc":"type/latentheattreatment.html"},{"title":"HeatFields – FTDSS ","text":"type, public :: HeatFields Inherits type~~heatfields~~InheritsGraph type~heatfields HeatFields type~heatvariables HeatVariables type~heatfields->type~heatvariables Variables type~heatconstants HeatConstants type~heatfields->type~heatconstants Constants type~crs CRS type~heatfields->type~crs LHS_A type~latentheattreatment LatentHeatTreatment type~heatfields->type~latentheattreatment Latent type~df DF type~heatvariables->type~df Cs, Cp, lambda, rho, Ca type~dp2d DP2d type~heatvariables->type~dp2d Tgrad, TFlux type~vector2d Vector2D type~heatconstants->type~vector2d dispersity type~phases Phases type~heatconstants->type~phases Density, ThermalConductivity, SpecificHeat, HeatCapacity type~gccmodel GCCModel type~latentheattreatment->type~gccmodel GCC type~powermodel PowerModel type~latentheattreatment->type~powermodel Power Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~heatfields~~InheritedByGraph type~heatfields HeatFields type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Variables Constants Latent LHS_A RA Rhs Source Code HeatFields Components Type Visibility Attributes Name Initial type( HeatVariables ), public :: Variables type( HeatConstants ), public :: Constants type( LatentHeatTreatment ), public :: Latent type( CRS ), public :: LHS_A real(kind=real64), public, allocatable :: RA (:,:) real(kind=real64), public, allocatable :: Rhs (:) Source Code type :: HeatFields type ( HeatVariables ) :: Variables type ( HeatConstants ) :: Constants type ( LatentHeatTreatment ) :: Latent type ( CRS ) :: LHS_A real ( real64 ), allocatable :: RA (:, :) real ( real64 ), allocatable :: Rhs (:) end type HeatFields","tags":"","loc":"type/heatfields.html"},{"title":"WaterVariables – FTDSS ","text":"type, public :: WaterVariables Inherits type~~watervariables~~InheritsGraph type~watervariables WaterVariables type~df DF type~watervariables->type~df Klh type~dp2d DP2d type~watervariables->type~dp2d wFlux, hGrad Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~watervariables~~InheritedByGraph type~watervariables WaterVariables type~waterfields WaterFields type~waterfields->type~watervariables Variables type~solverinfo SolverInfo type~solverinfo->type~waterfields Water Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Klh wFlux hGrad Source Code WaterVariables Components Type Visibility Attributes Name Initial type( DF ), public :: Klh type( DP2d ), public :: wFlux type( DP2d ), public :: hGrad Source Code type WaterVariables type ( DF ) :: Klh type ( DP2d ) :: wFlux , hGrad end type WaterVariables","tags":"","loc":"type/watervariables.html"},{"title":"WaterConstants – FTDSS ","text":"type, public :: WaterConstants Inherits type~~waterconstants~~InheritsGraph type~waterconstants WaterConstants type~phases Phases type~waterconstants->type~phases HydraulicConductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~waterconstants~~InheritedByGraph type~waterconstants WaterConstants type~waterfields WaterFields type~waterfields->type~waterconstants Constants type~solverinfo SolverInfo type~solverinfo->type~waterfields Water Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables HydraulicConductivity zeta Source Code WaterConstants Components Type Visibility Attributes Name Initial type( Phases ), public :: HydraulicConductivity real(kind=real64), public :: zeta Source Code type WaterConstants type ( Phases ) :: HydraulicConductivity real ( real64 ) :: zeta end type WaterConstants","tags":"","loc":"type/waterconstants.html"},{"title":"WaterFields – FTDSS ","text":"type, public :: WaterFields Inherits type~~waterfields~~InheritsGraph type~waterfields WaterFields type~watervariables WaterVariables type~waterfields->type~watervariables Variables type~crs CRS type~waterfields->type~crs LHS_A type~waterconstants WaterConstants type~waterfields->type~waterconstants Constants type~df DF type~watervariables->type~df Klh type~dp2d DP2d type~watervariables->type~dp2d wFlux, hGrad type~phases Phases type~waterconstants->type~phases HydraulicConductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~waterfields~~InheritedByGraph type~waterfields WaterFields type~solverinfo SolverInfo type~solverinfo->type~waterfields Water Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Variables Constants LHS_A RA Rhs Source Code WaterFields Components Type Visibility Attributes Name Initial type( WaterVariables ), public :: Variables type( WaterConstants ), public :: Constants type( CRS ), public :: LHS_A real(kind=real64), public, allocatable :: RA (:,:) real(kind=real64), public, allocatable :: Rhs (:) Source Code type :: WaterFields type ( WaterVariables ) :: Variables type ( WaterConstants ) :: Constants type ( CRS ) :: LHS_A real ( real64 ), allocatable :: RA (:, :) real ( real64 ), allocatable :: Rhs (:) end type WaterFields","tags":"","loc":"type/waterfields.html"},{"title":"Geometry2d – FTDSS ","text":"type, public :: Geometry2d Inherits type~~geometry2d~~InheritsGraph type~geometry2d Geometry2d type~dp2d DP2d type~geometry2d->type~dp2d vCood type~shape Shape type~geometry2d->type~shape Basis Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~geometry2d~~InheritedByGraph type~geometry2d Geometry2d type~solverinfo SolverInfo type~solverinfo->type~geometry2d N Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables element node shape dim ShCoe pElement vCood eArea Basis Source Code Geometry2d Components Type Visibility Attributes Name Initial integer(kind=int32), public :: element integer(kind=int32), public :: node integer(kind=int32), public :: shape integer(kind=int32), public :: dim integer(kind=int32), public :: ShCoe integer(kind=int32), public, allocatable :: pElement (:,:) type( DP2d ), public :: vCood real(kind=real64), public, allocatable :: eArea (:) type( Shape ), public :: Basis Source Code type :: Geometry2d integer ( int32 ) :: element , node , shape , dim , ShCoe integer ( int32 ), allocatable :: pElement (:, :) type ( DP2d ) :: vCood real ( real64 ), allocatable :: eArea (:) type ( Shape ) :: Basis end type Geometry2d","tags":"","loc":"type/geometry2d.html"},{"title":"Geometry_2D – FTDSS ","text":"type, public :: Geometry_2D Inherits type~~geometry_2d~~InheritsGraph type~geometry_2d Geometry_2D type~dp2d DP2d type~geometry_2d->type~dp2d Nodes_2D type~shape Shape type~geometry_2d->type~shape Shape_Function Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Inherited by type~~geometry_2d~~InheritedByGraph type~geometry_2d Geometry_2D type~heat Heat type~heat->type~geometry_2d Geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Num_Elements Num_Nodes Num_Shape Num_Dimention Num_Shape_Type Num_Region Element Element_Region COO_Region Nodes_2D Area Shape_Function Source Code Geometry_2D Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Elements integer(kind=int32), public :: Num_Nodes integer(kind=int32), public :: Num_Shape integer(kind=int32), public :: Num_Dimention integer(kind=int32), public :: Num_Shape_Type integer(kind=int32), public :: Num_Region integer(kind=int32), public, allocatable :: Element (:,:) integer(kind=int32), public, allocatable :: Element_Region (:) integer(kind=int32), public, allocatable :: COO_Region (:) type( DP2d ), public :: Nodes_2D real(kind=real64), public, allocatable :: Area (:) type( Shape ), public :: Shape_Function Source Code type :: Geometry_2D integer ( int32 ) :: Num_Elements , Num_Nodes , Num_Shape , Num_Dimention , Num_Shape_Type , Num_Region integer ( int32 ), allocatable :: Element (:, :) integer ( int32 ), allocatable :: Element_Region (:), COO_Region (:) type ( DP2d ) :: Nodes_2D real ( real64 ), allocatable :: Area (:) type ( Shape ) :: Shape_Function end type Geometry_2D","tags":"","loc":"type/geometry_2d.html"},{"title":"TimeInfo – FTDSS ","text":"type, public :: TimeInfo Inherited by type~~timeinfo~~InheritedByGraph type~timeinfo TimeInfo type~solverinfo SolverInfo type~solverinfo->type~timeinfo Time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables tUnit cTime cdt cinterval ts te max_dt min_dt tconv tst dt odt Source Code TimeInfo Components Type Visibility Attributes Name Initial character(len=3), public :: tUnit real(kind=real64), public :: cTime real(kind=real64), public :: cdt real(kind=real64), public :: cinterval real(kind=real64), public :: ts real(kind=real64), public :: te real(kind=real64), public :: max_dt real(kind=real64), public :: min_dt real(kind=real64), public :: tconv real(kind=real64), public, pointer :: tst real(kind=real64), public, pointer :: dt real(kind=real64), public, pointer :: odt Source Code type :: TimeInfo character ( 3 ) :: tUnit ! tUnit <- nmk 1: Second, 2: Minute, 3: Hour, 4: Day, 5: Month, 6: Year ! n : Calculation time unit, m: dt unit, k: output interval time unit real ( real64 ) :: cTime , cdt , cinterval real ( real64 ) :: ts , te , max_dt , min_dt , tconv real ( real64 ), pointer :: tst , dt , odt end type TimeInfo","tags":"","loc":"type/timeinfo.html"},{"title":"Iteration – FTDSS ","text":"type, public :: Iteration Inherited by type~~iteration~~InheritedByGraph type~iteration Iteration type~solverinfo SolverInfo type~solverinfo->type~iteration Iter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables itermax iNLmax iNI iter titer iNL digits_itermax Source Code Iteration Components Type Visibility Attributes Name Initial integer(kind=int32), public :: itermax integer(kind=int32), public :: iNLmax integer(kind=int32), public :: iNI integer(kind=int32), public, pointer :: iter integer(kind=int32), public, pointer :: titer integer(kind=int32), public, pointer :: iNL integer(kind=int32), public :: digits_itermax Source Code type :: Iteration integer ( int32 ) :: itermax , iNLmax , iNI integer ( int32 ), pointer :: iter , titer , iNL integer ( int32 ) :: digits_itermax end type Iteration","tags":"","loc":"type/iteration.html"},{"title":"SolverInfo – FTDSS ","text":"type, public :: SolverInfo Inherits type~~solverinfo~~InheritsGraph type~solverinfo SolverInfo type~timeinfo TimeInfo type~solverinfo->type~timeinfo Time type~observation2d Observation2d type~solverinfo->type~observation2d Obs type~waterfields WaterFields type~solverinfo->type~waterfields Water type~boudarycondition BoudaryCondition type~solverinfo->type~boudarycondition BC type~df DF type~solverinfo->type~df mWater, mIce, T, P, Si, Sw type~mpiinfo MPIInfo type~solverinfo->type~mpiinfo MPI type~geometry2d Geometry2d type~solverinfo->type~geometry2d N type~iteration Iteration type~solverinfo->type~iteration Iter type~heatfields HeatFields type~solverinfo->type~heatfields Heat type~initialcondition InitialCondition type~solverinfo->type~initialcondition IC type~lis Lis type~solverinfo->type~lis Lis type~flag Flag type~solverinfo->type~flag Flags type~dp2d DP2d type~observation2d->type~dp2d obsCOO type~crs CRS type~waterfields->type~crs LHS_A type~watervariables WaterVariables type~waterfields->type~watervariables Variables type~waterconstants WaterConstants type~waterfields->type~waterconstants Constants type~boudaryconditioninfo BoudaryConditionInfo type~boudarycondition->type~boudaryconditioninfo Heat, Water, Stress type~shape Shape type~geometry2d->type~shape Basis type~geometry2d->type~dp2d vCood type~heatfields->type~crs LHS_A type~heatconstants HeatConstants type~heatfields->type~heatconstants Constants type~latentheattreatment LatentHeatTreatment type~heatfields->type~latentheattreatment Latent type~heatvariables HeatVariables type~heatfields->type~heatvariables Variables type~initialconditioninfo InitialConditionInfo type~initialcondition->type~initialconditioninfo Heat, Water, Stress type~watervariables->type~df Klh type~watervariables->type~dp2d wFlux, hGrad type~vector2d Vector2D type~heatconstants->type~vector2d dispersity type~phases Phases type~heatconstants->type~phases Density, ThermalConductivity, SpecificHeat, HeatCapacity type~gccmodel GCCModel type~latentheattreatment->type~gccmodel GCC type~powermodel PowerModel type~latentheattreatment->type~powermodel Power type~waterconstants->type~phases HydraulicConductivity type~int2d INT2d type~boudaryconditioninfo->type~int2d Edges type~heatvariables->type~df Cs, Cp, lambda, rho, Ca type~heatvariables->type~dp2d Tgrad, TFlux Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables N isHeat isWater isStress nAnalysis nFrTreat nTimeDisc isStdOut outputFile Time Iter Obs Heat Water BC IC mWater mIce T P Si Sw Lis Flags fmt_Stdout fmt_Fileout MPI Source Code SolverInfo Components Type Visibility Attributes Name Initial type( Geometry2d ), public :: N logical, public :: isHeat logical, public :: isWater logical, public :: isStress integer(kind=int32), public :: nAnalysis integer(kind=int32), public :: nFrTreat integer(kind=int32), public :: nTimeDisc integer(kind=int32), public :: isStdOut integer(kind=int32), public :: outputFile type( TimeInfo ), public :: Time type( Iteration ), public :: Iter type( Observation2d ), public :: Obs type( HeatFields ), public :: Heat type( WaterFields ), public :: Water type( BoudaryCondition ), public :: BC type( InitialCondition ), public :: IC type( DF ), public :: mWater type( DF ), public :: mIce type( DF ), public :: T type( DF ), public :: P type( DF ), public :: Si type( DF ), public :: Sw type( Lis ), public :: Lis type( Flag ), public :: Flags character(len=64), public :: fmt_Stdout character(len=64), public :: fmt_Fileout type( MPIInfo ), public :: MPI Source Code type :: SolverInfo type ( Geometry2d ) :: N logical :: isHeat , isWater , isStress integer ( int32 ) :: nAnalysis , nFrTreat , nTimeDisc , isStdOut , outputFile type ( TimeInfo ) :: Time type ( Iteration ) :: Iter type ( Observation2d ) :: Obs type ( HeatFields ) :: Heat type ( WaterFields ) :: Water type ( BoudaryCondition ) :: BC type ( InitialCondition ) :: IC type ( DF ) :: mWater , mIce type ( DF ) :: T , P type ( DF ) :: Si , Sw type ( Lis ) :: Lis type ( Flag ) :: Flags character ( 64 ) :: fmt_Stdout , fmt_Fileout #ifdef _MPI type ( MPIInfo ) :: MPI #endif end type SolverInfo","tags":"","loc":"type/solverinfo.html"},{"title":"ILS – FTDSS ","text":"type, public :: ILS Inherits type~~ils~~InheritsGraph type~ils ILS type~crs CRS type~ils->type~crs CRS_A Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables CRS_A M p phat s shat r r0 t v x b Constructor ILS Finalization Procedures ILS_Destructor Type-Bound Procedures BiCGStab Chkerr Source Code ILS Components Type Visibility Attributes Name Initial type( CRS ), private :: CRS_A real(kind=real64), private, dimension(:), pointer :: M real(kind=real64), private, dimension(:), pointer :: p real(kind=real64), private, dimension(:), pointer :: phat real(kind=real64), private, dimension(:), pointer :: s real(kind=real64), private, dimension(:), pointer :: shat real(kind=real64), private, dimension(:), pointer :: r real(kind=real64), private, dimension(:), pointer :: r0 real(kind=real64), private, dimension(:), pointer :: t real(kind=real64), private, dimension(:), pointer :: v real(kind=real64), private, dimension(:), pointer :: x real(kind=real64), private, dimension(:), pointer :: b Constructor public interface ILS private function Solve_Initialize_BiCGStab (Solver, MCRS) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(in) :: MCRS Return Value type( ILS ) Finalization Procedures final :: ILS_Destructor private subroutine ILS_Destructor (self) Arguments Type Intent Optional Attributes Name type( ILS ) :: self Type-Bound Procedures procedure, public :: BiCGStab => Solver_BiCGStab private subroutine Solver_BiCGStab (self, Solver, BiCG_A, BiCG_b, BiCG_x, status) Arguments Type Intent Optional Attributes Name class( ILS ) :: self type( SolverInfo ), intent(inout) :: Solver type( CRS ), intent(in) :: BiCG_A real(kind=real64), intent(in) :: BiCG_b (:) real(kind=real64), intent(inout) :: BiCG_x (:) integer(kind=int32), intent(inout) :: status procedure, public :: Chkerr => Solver_Check_Error private subroutine Solver_Check_Error (self, ierr, time) Arguments Type Intent Optional Attributes Name class( ILS ) :: self integer(kind=int32), intent(in) :: ierr real(kind=real64), intent(in) :: time Source Code type :: ILS private type ( CRS ) :: CRS_A real ( real64 ), dimension (:), pointer :: M , p , phat , s , shat , r , r0 , t , v , x , b contains procedure :: BiCGStab => Solver_BiCGStab procedure :: Chkerr => Solver_Check_Error final :: ILS_Destructor end type ILS","tags":"","loc":"type/ils.html"},{"title":"DLS – FTDSS ","text":"type, public :: DLS Contents Variables N Constructor DLS Type-Bound Procedures LU Components Type Visibility Attributes Name Initial integer(kind=int32), private :: N Constructor public interface DLS private function Solve_Initialize_LU (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ) :: Solver Return Value type( DLS ) Type-Bound Procedures procedure, public :: LU => Solver_LU private subroutine Solver_LU (self, LU_A, LU_b, LU_x) Arguments Type Intent Optional Attributes Name class( DLS ) :: self real(kind=real64), intent(inout) :: LU_A (:,:) real(kind=real64), intent(inout) :: LU_b (:) real(kind=real64), intent(inout) :: LU_x (:)","tags":"","loc":"type/dls.html"},{"title":"Calculation_HCF – FTDSS","text":"abstract interface public function Calculation_HCF(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64)","tags":"","loc":"interface/calculation_hcf.html"},{"title":"Calculation_HCF_mu – FTDSS","text":"abstract interface public function Calculation_HCF_mu(T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64)","tags":"","loc":"interface/calculation_hcf_mu.html"},{"title":"Calculate_GCC_Segregation_interface – FTDSS","text":"abstract interface private function Calculate_GCC_Segregation_interface(T, Pw, Tf, Lf, rhoW, rhoI) result(Suction) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Pw real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW real(kind=real64), intent(in) :: rhoI Return Value real(kind=real64)","tags":"","loc":"interface/calculate_gcc_segregation_interface.html"},{"title":"Find_CRS_Index – FTDSS","text":"public subroutine Find_CRS_Index(A, serch_column, serch_index, index) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A integer(kind=int32), intent(in) :: serch_column integer(kind=int32), intent(in) :: serch_index integer(kind=int32), intent(inout) :: index Called by proc~~find_crs_index~~CalledByGraph proc~find_crs_index Find_CRS_Index proc~find_crs_indexes Find_CRS_Indexes proc~find_crs_indexes->proc~find_crs_index proc~fix_dirichletboundarycondition_temperature Fix_DirichletBoundaryCondition_Temperature proc~fix_dirichletboundarycondition_temperature->proc~find_crs_index proc~fix_dirichletboundarycondition_water Fix_DirichletBoundaryCondition_Water proc~fix_dirichletboundarycondition_water->proc~find_crs_index proc~calc_gm_time_trm Calc_GM_Time_TRM proc~calc_gm_time_trm->proc~find_crs_indexes proc~calc_gm_diffusion Calc_GM_Diffusion proc~calc_gm_diffusion->proc~find_crs_indexes proc~calc_gm_time_divide Calc_GM_Time_Divide proc~calc_gm_time_divide->proc~find_crs_indexes proc~calc_gm_diffusion_trm Calc_GM_Diffusion_TRM proc~calc_gm_diffusion_trm->proc~find_crs_indexes proc~calc_gm_time_richards Calc_GM_Time_Richards proc~calc_gm_time_richards->proc~find_crs_indexes proc~fix_boundaryconditions Fix_BoundaryConditions proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_temperature proc~calc_gm_diffusion_richards Calc_GM_Diffusion_Richards proc~calc_gm_diffusion_richards->proc~find_crs_indexes proc~calc_gm_diffusion_advection_trm Calc_GM_Diffusion_Advection_TRM proc~calc_gm_diffusion_advection_trm->proc~find_crs_indexes proc~calc_gm_diffusion_advection Calc_GM_Diffusion_Advection proc~calc_gm_diffusion_advection->proc~find_crs_indexes proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~calc_gm_time_trm proc~assemble_gm_heat->proc~calc_gm_diffusion proc~assemble_gm_heat->proc~calc_gm_time_divide proc~assemble_gm_heat->proc~calc_gm_diffusion_trm proc~assemble_gm_heat->proc~calc_gm_diffusion_advection_trm proc~assemble_gm_heat->proc~calc_gm_diffusion_advection proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~fix_boundaryconditions proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~assemble_gm_heat_ic->proc~calc_gm_time_trm proc~assemble_gm_heat_ic->proc~calc_gm_diffusion proc~assemble_gm_heat_ic->proc~calc_gm_time_divide proc~assemble_gm_heat_ic->proc~calc_gm_diffusion_trm proc~assemble_gm_water Assemble_GM_Water proc~assemble_gm_water->proc~calc_gm_time_richards proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~fix_initialcondition_gradient_water->proc~fix_boundaryconditions proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat proc~fix_initialcondition->proc~fix_initialcondition_gradient_water Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Find_CRS_Index Source Code subroutine Find_CRS_Index ( A , serch_column , serch_index , index ) implicit none type ( CRS ), intent ( in ) :: A integer ( int32 ), intent ( in ) :: serch_column , serch_index integer ( int32 ), intent ( inout ) :: index integer ( int32 ) :: i , start_index , end_index index = 0 ! serch_columnのindex範囲を取得 start_index = A % Ptr ( serch_column - 1 ) end_index = A % Ptr ( serch_column ) - 1 ! 範囲内でserch_indexになる値のインデックスを見つける do i = start_index , end_index if ( A % Ind ( i ) == serch_index - 1 ) then index = i end if end do end subroutine Find_CRS_Index","tags":"","loc":"proc/find_crs_index.html"},{"title":"Find_CRS_Indexes – FTDSS","text":"public subroutine Find_CRS_Indexes(lump, A, serch_index1, serch_index2, serch_index3, indexes) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lump type( CRS ), intent(in) :: A integer(kind=int32), intent(in) :: serch_index1 integer(kind=int32), intent(in) :: serch_index2 integer(kind=int32), intent(in) :: serch_index3 integer(kind=int32), intent(inout) :: indexes (:) Calls proc~~find_crs_indexes~~CallsGraph proc~find_crs_indexes Find_CRS_Indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~find_crs_indexes~~CalledByGraph proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_time_trm Calc_GM_Time_TRM proc~calc_gm_time_trm->proc~find_crs_indexes proc~calc_gm_diffusion Calc_GM_Diffusion proc~calc_gm_diffusion->proc~find_crs_indexes proc~calc_gm_time_divide Calc_GM_Time_Divide proc~calc_gm_time_divide->proc~find_crs_indexes proc~calc_gm_diffusion_trm Calc_GM_Diffusion_TRM proc~calc_gm_diffusion_trm->proc~find_crs_indexes proc~calc_gm_time_richards Calc_GM_Time_Richards proc~calc_gm_time_richards->proc~find_crs_indexes proc~calc_gm_diffusion_richards Calc_GM_Diffusion_Richards proc~calc_gm_diffusion_richards->proc~find_crs_indexes proc~calc_gm_diffusion_advection_trm Calc_GM_Diffusion_Advection_TRM proc~calc_gm_diffusion_advection_trm->proc~find_crs_indexes proc~calc_gm_diffusion_advection Calc_GM_Diffusion_Advection proc~calc_gm_diffusion_advection->proc~find_crs_indexes proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~calc_gm_time_trm proc~assemble_gm_heat->proc~calc_gm_diffusion proc~assemble_gm_heat->proc~calc_gm_time_divide proc~assemble_gm_heat->proc~calc_gm_diffusion_trm proc~assemble_gm_heat->proc~calc_gm_diffusion_advection_trm proc~assemble_gm_heat->proc~calc_gm_diffusion_advection proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~assemble_gm_heat_ic->proc~calc_gm_time_trm proc~assemble_gm_heat_ic->proc~calc_gm_diffusion proc~assemble_gm_heat_ic->proc~calc_gm_time_divide proc~assemble_gm_heat_ic->proc~calc_gm_diffusion_trm proc~assemble_gm_water Assemble_GM_Water proc~assemble_gm_water->proc~calc_gm_time_richards proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Find_CRS_Indexes Source Code subroutine Find_CRS_Indexes ( lump , A , serch_index1 , serch_index2 , serch_index3 , indexes ) implicit none type ( CRS ), intent ( in ) :: A integer ( int32 ), intent ( in ) :: lump , serch_index1 , serch_index2 , serch_index3 integer ( int32 ), intent ( inout ) :: indexes (:) if ( lump == udmp ) then call Find_CRS_Index ( A , serch_index1 , serch_index1 , indexes ( 1 )) call Find_CRS_Index ( A , serch_index1 , serch_index2 , indexes ( 2 )) call Find_CRS_Index ( A , serch_index1 , serch_index3 , indexes ( 3 )) call Find_CRS_Index ( A , serch_index2 , serch_index1 , indexes ( 4 )) call Find_CRS_Index ( A , serch_index2 , serch_index2 , indexes ( 5 )) call Find_CRS_Index ( A , serch_index2 , serch_index3 , indexes ( 6 )) call Find_CRS_Index ( A , serch_index3 , serch_index1 , indexes ( 7 )) call Find_CRS_Index ( A , serch_index3 , serch_index2 , indexes ( 8 )) call Find_CRS_Index ( A , serch_index3 , serch_index3 , indexes ( 9 )) else if ( lump == dmp ) then call Find_CRS_Index ( A , serch_index1 , serch_index1 , indexes ( 1 )) call Find_CRS_Index ( A , serch_index2 , serch_index2 , indexes ( 2 )) call Find_CRS_Index ( A , serch_index3 , serch_index3 , indexes ( 3 )) end if end subroutine Find_CRS_Indexes","tags":"","loc":"proc/find_crs_indexes.html"},{"title":"Init_Assemble – FTDSS","text":"public subroutine Init_Assemble(A) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A Calls proc~~init_assemble~~CallsGraph proc~init_assemble Init_Assemble proc~duplicate_crs Duplicate_CRS proc~init_assemble->proc~duplicate_crs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Init_Assemble Source Code subroutine Init_Assemble ( A ) implicit none type ( CRS ), intent ( in ) :: A call Duplicate_CRS ( A , tmpCRS1 ) tmpCRS1 % val (:) = 0.0d0 call Duplicate_CRS ( A , tmpCRS2 ) tmpCRS2 % val (:) = 0.0d0 end subroutine Init_Assemble","tags":"","loc":"proc/init_assemble.html"},{"title":"Set_C – FTDSS","text":"private subroutine Set_C(C, case, p, C1, C2) Arguments Type Intent Optional Attributes Name type( DF ), intent(in) :: C integer(kind=int32), intent(in) :: case integer(kind=int32), intent(in) :: p real(kind=real64), intent(inout) :: C1 real(kind=real64), intent(inout) :: C2 Called by proc~~set_c~~CalledByGraph proc~set_c Set_C proc~calc_gm_time_divide Calc_GM_Time_Divide proc~calc_gm_time_divide->proc~set_c proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~calc_gm_time_divide proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~assemble_gm_heat_ic->proc~calc_gm_time_divide proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Set_C Source Code subroutine Set_C ( C , case , p , C1 , C2 ) implicit none type ( DF ), intent ( in ) :: C integer ( int32 ), intent ( in ) :: case , p real ( real64 ), intent ( inout ) :: C1 , C2 if ( case == 1 ) then C1 = C % pre ( p ) C2 = C % old ( p ) else if ( case == 2 ) then C1 = C % div ( p ) C2 = C % old ( p ) else if ( case == 3 ) then C1 = C % div ( p ) C2 = C % div ( p ) else if ( case == 4 ) then C1 = C % div ( p ) C2 = C % old ( p ) end if end subroutine Set_C","tags":"","loc":"proc/set_c.html"},{"title":"Calc_GM_Time_TRM – FTDSS","text":"private subroutine Calc_GM_Time_TRM(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~calc_gm_time_trm~~CallsGraph proc~calc_gm_time_trm Calc_GM_Time_TRM proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_time_trm->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_gm_time_trm~~CalledByGraph proc~calc_gm_time_trm Calc_GM_Time_TRM proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~calc_gm_time_trm proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~assemble_gm_heat_ic->proc~calc_gm_time_trm proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_GM_Time_TRM Source Code subroutine Calc_GM_Time_TRM ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , C1 , C2 , C3 , C tmpCRS1 % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = Solver % N % eArea ( iN ) * D12 / Solver % Time % dt C1 = Solver % Heat % Variables % Cp % pre ( p1 ) C2 = Solver % Heat % Variables % Cp % pre ( p2 ) C3 = Solver % Heat % Variables % Cp % pre ( p3 ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) tmpCRS1 % Val ( indexes ( 1 )) = tmpCRS1 % Val ( indexes ( 1 )) + CoeA * C1 * 2.d0 tmpCRS1 % Val ( indexes ( 2 )) = tmpCRS1 % Val ( indexes ( 2 )) + CoeA * C1 tmpCRS1 % Val ( indexes ( 3 )) = tmpCRS1 % Val ( indexes ( 3 )) + CoeA * C1 tmpCRS1 % Val ( indexes ( 4 )) = tmpCRS1 % Val ( indexes ( 4 )) + CoeA * C2 tmpCRS1 % Val ( indexes ( 5 )) = tmpCRS1 % Val ( indexes ( 5 )) + CoeA * C2 * 2.d0 tmpCRS1 % Val ( indexes ( 6 )) = tmpCRS1 % Val ( indexes ( 6 )) + CoeA * C2 tmpCRS1 % Val ( indexes ( 7 )) = tmpCRS1 % Val ( indexes ( 7 )) + CoeA * C3 tmpCRS1 % Val ( indexes ( 8 )) = tmpCRS1 % Val ( indexes ( 8 )) + CoeA * C3 tmpCRS1 % Val ( indexes ( 9 )) = tmpCRS1 % Val ( indexes ( 9 )) + CoeA * C3 * 2.d0 end do end subroutine Calc_GM_Time_TRM","tags":"","loc":"proc/calc_gm_time_trm.html"},{"title":"Calc_GM_Time_TRM_F – FTDSS","text":"private subroutine Calc_GM_Time_TRM_F(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~calc_gm_time_trm_f~~CallsGraph proc~calc_gm_time_trm_f Calc_GM_Time_TRM_F interface~allocate_matrix Allocate_Matrix proc~calc_gm_time_trm_f->interface~allocate_matrix proc~check_allocate_rank2_int32 Check_Allocate_rank2_int32 interface~allocate_matrix->proc~check_allocate_rank2_int32 proc~check_allocate_rank2_real64 Check_Allocate_rank2_real64 interface~allocate_matrix->proc~check_allocate_rank2_real64 proc~error_message error_message proc~check_allocate_rank2_int32->proc~error_message proc~check_allocate_rank2_real64->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_GM_Time_TRM_F Source Code subroutine Calc_GM_Time_TRM_F ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , C1 , C2 , C3 , C if (. not . allocated ( tmpA )) call Allocate_Matrix ( tmpA , Solver % N % node , Solver % N % node ) tmpA (:,:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = Solver % N % eArea ( iN ) * D12 / Solver % Time % dt C1 = Solver % Heat % Variables % Cp % pre ( p1 ) C2 = Solver % Heat % Variables % Cp % pre ( p2 ) C3 = Solver % Heat % Variables % Cp % pre ( p3 ) tmpA ( p1 , p1 ) = tmpA ( p1 , p1 ) + CoeA * C1 * 2.d0 tmpA ( p1 , p2 ) = tmpA ( p1 , p2 ) + CoeA * C1 tmpA ( p1 , p3 ) = tmpA ( p1 , p3 ) + CoeA * C1 tmpA ( p2 , p1 ) = tmpA ( p2 , p1 ) + CoeA * C2 tmpA ( p2 , p2 ) = tmpA ( p2 , p2 ) + CoeA * C2 * 2.d0 tmpA ( p2 , p3 ) = tmpA ( p2 , p3 ) + CoeA * C2 tmpA ( p3 , p1 ) = tmpA ( p3 , p1 ) + CoeA * C3 tmpA ( p3 , p2 ) = tmpA ( p3 , p2 ) + CoeA * C3 tmpA ( p3 , p3 ) = tmpA ( p3 , p3 ) + CoeA * C3 * 2.d0 end do end subroutine Calc_GM_Time_TRM_F","tags":"","loc":"proc/calc_gm_time_trm_f.html"},{"title":"Calc_GM_Time_Divide – FTDSS","text":"private subroutine Calc_GM_Time_Divide(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~calc_gm_time_divide~~CallsGraph proc~calc_gm_time_divide Calc_GM_Time_Divide proc~set_c Set_C proc~calc_gm_time_divide->proc~set_c proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_time_divide->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_gm_time_divide~~CalledByGraph proc~calc_gm_time_divide Calc_GM_Time_Divide proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~calc_gm_time_divide proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~assemble_gm_heat_ic->proc~calc_gm_time_divide proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_GM_Time_Divide Source Code subroutine Calc_GM_Time_Divide ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ) real ( real64 ) :: CoeA , C11 , C12 , C13 , C21 , C22 , C23 tmpCRS1 % val (:) = 0.0d0 tmpCRS2 % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = Solver % N % eArea ( iN ) * D3 / Solver % Time % dt call Set_C ( Solver % Heat % Variables % Ca , Solver % Heat % Variables % Phase ( p1 ), p1 , C11 , C21 ) call Set_C ( Solver % Heat % Variables % Ca , Solver % Heat % Variables % Phase ( p2 ), p2 , C12 , C22 ) call Set_C ( Solver % Heat % Variables % Ca , Solver % Heat % Variables % Phase ( p3 ), p3 , C13 , C23 ) call Find_CRS_Indexes ( dmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) tmpCRS1 % Val ( indexes ( 1 )) = tmpCRS1 % Val ( indexes ( 1 )) + CoeA * C11 tmpCRS1 % Val ( indexes ( 2 )) = tmpCRS1 % Val ( indexes ( 2 )) + CoeA * C12 tmpCRS1 % Val ( indexes ( 3 )) = tmpCRS1 % Val ( indexes ( 3 )) + CoeA * C13 tmpCRS2 % Val ( indexes ( 1 )) = tmpCRS2 % Val ( indexes ( 1 )) + CoeA * C21 tmpCRS2 % Val ( indexes ( 2 )) = tmpCRS2 % Val ( indexes ( 2 )) + CoeA * C22 tmpCRS2 % Val ( indexes ( 3 )) = tmpCRS2 % Val ( indexes ( 3 )) + CoeA * C23 end do end subroutine Calc_GM_Time_Divide","tags":"","loc":"proc/calc_gm_time_divide.html"},{"title":"Calc_GM_Time_Richards – FTDSS","text":"private subroutine Calc_GM_Time_Richards(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~calc_gm_time_richards~~CallsGraph proc~calc_gm_time_richards Calc_GM_Time_Richards proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_time_richards->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_gm_time_richards~~CalledByGraph proc~calc_gm_time_richards Calc_GM_Time_Richards proc~assemble_gm_water Assemble_GM_Water proc~assemble_gm_water->proc~calc_gm_time_richards Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_GM_Time_Richards Source Code subroutine Calc_GM_Time_Richards ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ) real ( real64 ) :: CoeA , C1 , C2 , C3 tmpCRS1 % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = SOlver % Water % Constants % zeta * Solver % N % eArea ( iN ) * D3 / Solver % Time % dt call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) tmpCRS1 % Val ( indexes ( 1 )) = tmpCRS1 % Val ( indexes ( 1 )) + CoeA tmpCRS1 % Val ( indexes ( 2 )) = tmpCRS1 % Val ( indexes ( 2 )) + CoeA tmpCRS1 % Val ( indexes ( 3 )) = tmpCRS1 % Val ( indexes ( 3 )) + CoeA end do end subroutine Calc_GM_Time_Richards","tags":"","loc":"proc/calc_gm_time_richards.html"},{"title":"Calc_GM_Diffusion_TRM – FTDSS","text":"private subroutine Calc_GM_Diffusion_TRM(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~calc_gm_diffusion_trm~~CallsGraph proc~calc_gm_diffusion_trm Calc_GM_Diffusion_TRM proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_diffusion_trm->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_gm_diffusion_trm~~CalledByGraph proc~calc_gm_diffusion_trm Calc_GM_Diffusion_TRM proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~calc_gm_diffusion_trm proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~assemble_gm_heat_ic->proc~calc_gm_diffusion_trm proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_GM_Diffusion_TRM Source Code subroutine Calc_GM_Diffusion_TRM ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , Lm1 , Lm2 , Lm3 Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm1 * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm1 * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm1 * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm2 * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm2 * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm2 * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm3 * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm3 * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm3 * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion_TRM","tags":"","loc":"proc/calc_gm_diffusion_trm.html"},{"title":"Calc_GM_Diffusion – FTDSS","text":"private subroutine Calc_GM_Diffusion(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~calc_gm_diffusion~~CallsGraph proc~calc_gm_diffusion Calc_GM_Diffusion proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_diffusion->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_gm_diffusion~~CalledByGraph proc~calc_gm_diffusion Calc_GM_Diffusion proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~calc_gm_diffusion proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~assemble_gm_heat_ic->proc~calc_gm_diffusion proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_GM_Diffusion Source Code subroutine Calc_GM_Diffusion ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , Lm1 , Lm2 , Lm3 , Lm Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) Lm = ( Lm1 + Lm2 + Lm3 ) * D3 be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion","tags":"","loc":"proc/calc_gm_diffusion.html"},{"title":"Calc_GM_Diffusion_Richards – FTDSS","text":"private subroutine Calc_GM_Diffusion_Richards(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~calc_gm_diffusion_richards~~CallsGraph proc~calc_gm_diffusion_richards Calc_GM_Diffusion_Richards proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_diffusion_richards->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_GM_Diffusion_Richards Source Code subroutine Calc_GM_Diffusion_Richards ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , K1 , K2 , K3 , K Solver % Water % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) K1 = Solver % Water % Variables % Klh % pre ( p1 ) K2 = Solver % Water % Variables % Klh % pre ( p2 ) K3 = Solver % Water % Variables % Klh % pre ( p3 ) K = ( K1 + K2 + K3 ) * D3 be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Water % LHS_A % Val ( indexes ( 1 )) = Solver % Water % LHS_A % Val ( indexes ( 1 )) + K * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 2 )) = Solver % Water % LHS_A % Val ( indexes ( 2 )) + K * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 3 )) = Solver % Water % LHS_A % Val ( indexes ( 3 )) + K * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 4 )) = Solver % Water % LHS_A % Val ( indexes ( 4 )) + K * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 5 )) = Solver % Water % LHS_A % Val ( indexes ( 5 )) + K * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 6 )) = Solver % Water % LHS_A % Val ( indexes ( 6 )) + K * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 7 )) = Solver % Water % LHS_A % Val ( indexes ( 7 )) + K * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 8 )) = Solver % Water % LHS_A % Val ( indexes ( 8 )) + K * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 9 )) = Solver % Water % LHS_A % Val ( indexes ( 9 )) + K * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion_Richards","tags":"","loc":"proc/calc_gm_diffusion_richards.html"},{"title":"Calc_GM_Diffusion_Richards_F – FTDSS","text":"private subroutine Calc_GM_Diffusion_Richards_F(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Called by proc~~calc_gm_diffusion_richards_f~~CalledByGraph proc~calc_gm_diffusion_richards_f Calc_GM_Diffusion_Richards_F proc~assemble_gm_water Assemble_GM_Water proc~assemble_gm_water->proc~calc_gm_diffusion_richards_f proc~assemble_gm_water_ic Assemble_GM_Water_IC proc~assemble_gm_water_ic->proc~calc_gm_diffusion_richards_f proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~fix_initialcondition_gradient_water->proc~assemble_gm_water_ic proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_water Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_GM_Diffusion_Richards_F Source Code subroutine Calc_GM_Diffusion_Richards_F ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , K1 , K2 , K3 , K Solver % Water % RA (:,:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) K1 = Solver % Water % Variables % Klh % pre ( p1 ) K2 = Solver % Water % Variables % Klh % pre ( p2 ) K3 = Solver % Water % Variables % Klh % pre ( p3 ) K = ( K1 * K2 * K3 ) ** D3 be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) Solver % Water % RA ( p1 , p1 ) = Solver % Water % RA ( p1 , p1 ) + K * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Water % RA ( p1 , p2 ) = Solver % Water % RA ( p1 , p2 ) + K * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Water % RA ( p1 , p3 ) = Solver % Water % RA ( p1 , p3 ) + K * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Water % RA ( p2 , p1 ) = Solver % Water % RA ( p2 , p1 ) + K * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Water % RA ( p2 , p2 ) = Solver % Water % RA ( p2 , p2 ) + K * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Water % RA ( p2 , p3 ) = Solver % Water % RA ( p2 , p3 ) + K * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Water % RA ( p3 , p1 ) = Solver % Water % RA ( p3 , p1 ) + K * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Water % RA ( p3 , p2 ) = Solver % Water % RA ( p3 , p2 ) + K * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Water % RA ( p3 , p3 ) = Solver % Water % RA ( p3 , p3 ) + K * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion_Richards_F","tags":"","loc":"proc/calc_gm_diffusion_richards_f.html"},{"title":"Calc_GM_Diffusion_Advection_TRM – FTDSS","text":"private subroutine Calc_GM_Diffusion_Advection_TRM(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~calc_gm_diffusion_advection_trm~~CallsGraph proc~calc_gm_diffusion_advection_trm Calc_GM_Diffusion_Advection_TRM proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_diffusion_advection_trm->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_gm_diffusion_advection_trm~~CalledByGraph proc~calc_gm_diffusion_advection_trm Calc_GM_Diffusion_Advection_TRM proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~calc_gm_diffusion_advection_trm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_GM_Diffusion_Advection_TRM Source Code subroutine Calc_GM_Diffusion_Advection_TRM ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: be1 , be2 , be3 , ga1 , ga2 , ga3 real ( real64 ) :: CoeA , Lm1 , Lm2 , Lm3 real ( real64 ) :: CoeB , u1 , u2 , u3 , v1 , v2 , v3 , AD1 , AD2 , AD3 Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) CoeB = Solver % Heat % Constants % HeatCapacity % water / 6.0d0 u1 = Solver % Water % Variables % wFlux % x ( p1 ) u2 = Solver % Water % Variables % wFlux % x ( p2 ) u3 = Solver % Water % Variables % wFlux % x ( p3 ) v1 = Solver % Water % Variables % wFlux % y ( p1 ) v2 = Solver % Water % Variables % wFlux % y ( p2 ) v3 = Solver % Water % Variables % wFlux % y ( p3 ) AD1 = u1 * be1 + v1 * ga1 AD2 = u2 * be2 + v2 * ga2 AD3 = u3 * be3 + v3 * ga3 call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm1 * ( be1 * be1 + ga1 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm1 * ( be1 * be2 + ga1 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm1 * ( be1 * be3 + ga1 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm2 * ( be2 * be1 + ga2 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm2 * ( be2 * be2 + ga2 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm2 * ( be2 * be3 + ga2 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm3 * ( be3 * be1 + ga3 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm3 * ( be3 * be2 + ga3 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm3 * ( be3 * be3 + ga3 * ga3 ) * CoeA & + AD3 * CoeB end do end subroutine Calc_GM_Diffusion_Advection_TRM","tags":"","loc":"proc/calc_gm_diffusion_advection_trm.html"},{"title":"Calc_GM_Diffusion_Advection_TRM_F – FTDSS","text":"private subroutine Calc_GM_Diffusion_Advection_TRM_F(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents Source Code Calc_GM_Diffusion_Advection_TRM_F Source Code subroutine Calc_GM_Diffusion_Advection_TRM_F ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: be1 , be2 , be3 , ga1 , ga2 , ga3 real ( real64 ) :: CoeA , Lm1 , Lm2 , Lm3 real ( real64 ) :: CoeB , u1 , u2 , u3 , v1 , v2 , v3 , AD1 , AD2 , AD3 Solver % Heat % RA (:,:) = 0.0d0 ! print*,Solver%Heat%RA(1000,:) ! stop do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) CoeB = Solver % Heat % Constants % HeatCapacity % water / 6.0d0 u1 = Solver % Water % Variables % wFlux % x ( p1 ) u2 = Solver % Water % Variables % wFlux % x ( p2 ) u3 = Solver % Water % Variables % wFlux % x ( p3 ) v1 = Solver % Water % Variables % wFlux % y ( p1 ) v2 = Solver % Water % Variables % wFlux % y ( p2 ) v3 = Solver % Water % Variables % wFlux % y ( p3 ) AD1 = 0.0d0 ! u1 * be1 + v1 * ga1 AD2 = 0.0d0 ! u2 * be2 + v2 * ga2 AD3 = 0.0d0 ! u3 * be3 + v3 * ga3 ! AD1  = u1 * be1 + v1 * ga1 ! AD2  = u2 * be2 + v2 * ga2 ! AD3  = u3 * be3 + v3 * ga3 ! print*,p1,p2,p3 ! if (iN==100) stop ! call Find_CRS_Indexes(udmp, tmpCRS1, p1, p2, p3, indexes(:)) Solver % Heat % RA ( p1 , p1 ) = Solver % Heat % RA ( p1 , p1 ) + Lm1 * ( be1 * be1 + ga1 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % RA ( p1 , p2 ) = Solver % Heat % RA ( p1 , p2 ) + Lm2 * ( be1 * be2 + ga1 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % RA ( p1 , p3 ) = Solver % Heat % RA ( p1 , p3 ) + Lm3 * ( be1 * be3 + ga1 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % RA ( p2 , p1 ) = Solver % Heat % RA ( p2 , p1 ) + Lm1 * ( be2 * be1 + ga2 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % RA ( p2 , p2 ) = Solver % Heat % RA ( p2 , p2 ) + Lm2 * ( be2 * be2 + ga2 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % RA ( p2 , p3 ) = Solver % Heat % RA ( p2 , p3 ) + Lm3 * ( be2 * be3 + ga2 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % RA ( p3 , p1 ) = Solver % Heat % RA ( p3 , p1 ) + Lm1 * ( be3 * be1 + ga3 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % RA ( p3 , p2 ) = Solver % Heat % RA ( p3 , p2 ) + Lm2 * ( be3 * be2 + ga3 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % RA ( p3 , p3 ) = Solver % Heat % RA ( p3 , p1 ) + Lm3 * ( be3 * be3 + ga3 * ga3 ) * CoeA & + AD3 * CoeB end do end subroutine Calc_GM_Diffusion_Advection_TRM_F","tags":"","loc":"proc/calc_gm_diffusion_advection_trm_f.html"},{"title":"Calc_GM_Diffusion_Advection – FTDSS","text":"private subroutine Calc_GM_Diffusion_Advection(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~calc_gm_diffusion_advection~~CallsGraph proc~calc_gm_diffusion_advection Calc_GM_Diffusion_Advection proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_diffusion_advection->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_gm_diffusion_advection~~CalledByGraph proc~calc_gm_diffusion_advection Calc_GM_Diffusion_Advection proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~calc_gm_diffusion_advection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_GM_Diffusion_Advection Source Code subroutine Calc_GM_Diffusion_Advection ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: be1 , be2 , be3 , ga1 , ga2 , ga3 real ( real64 ) :: CoeA , Lm1 , Lm2 , Lm3 , Lm real ( real64 ) :: CoeB , u1 , u2 , u3 , v1 , v2 , v3 Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) Lm = ( Lm1 * Lm2 * Lm3 ) ** D3 ! Lm   = (Lm1 + Lm2 + Lm3) * D3 CoeB = Solver % Heat % Constants % HeatCapacity % water * D24 u1 = Solver % Water % Variables % wFlux % x ( p1 ) u2 = Solver % Water % Variables % wFlux % x ( p2 ) u3 = Solver % Water % Variables % wFlux % x ( p3 ) v1 = Solver % Water % Variables % wFlux % y ( p1 ) v2 = Solver % Water % Variables % wFlux % y ( p2 ) v3 = Solver % Water % Variables % wFlux % y ( p3 ) ! write(*,'(6es14.5)') u1, u2, u3, v1, v2, v3 call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm * ( be1 * be1 + ga1 * ga1 ) * CoeA & + (( 2.d0 * u1 + u2 + u3 ) * be1 + ( 2.d0 * v1 + v2 + v3 ) * ga1 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm * ( be1 * be2 + ga1 * ga2 ) * CoeA & + (( 2.d0 * u1 + u2 + u3 ) * be2 + ( 2.d0 * v1 + v2 + v3 ) * ga2 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm * ( be1 * be3 + ga1 * ga3 ) * CoeA & + (( 2.d0 * u1 + u2 + u3 ) * be3 + ( 2.d0 * v1 + v2 + v3 ) * ga3 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm * ( be2 * be1 + ga2 * ga1 ) * CoeA & + (( u1 + 2.d0 * u2 + u3 ) * be1 + ( v1 + 2.d0 * v2 + v3 ) * ga1 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm * ( be2 * be2 + ga2 * ga2 ) * CoeA & + (( u1 + 2.d0 * u2 + u3 ) * be2 + ( v1 + 2.d0 * v2 + v3 ) * ga2 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm * ( be2 * be3 + ga2 * ga3 ) * CoeA & + (( u1 + 2.d0 * u2 + u3 ) * be3 + ( v1 + 2.d0 * v2 + v3 ) * ga3 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm * ( be3 * be1 + ga3 * ga1 ) * CoeA & + (( u1 + u2 + 2.d0 * u3 ) * be1 + ( v1 + v2 + 2.d0 * v3 ) * ga1 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm * ( be3 * be2 + ga3 * ga2 ) * CoeA & + (( u1 + u2 + 2.d0 * u3 ) * be2 + ( v1 + v2 + 2.d0 * v3 ) * ga2 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm * ( be3 * be3 + ga3 * ga3 ) * CoeA & + (( u1 + u2 + 2.d0 * u3 ) * be3 + ( v1 + v2 + 2.d0 * v3 ) * ga3 ) * CoeB end do ! stop end subroutine Calc_GM_Diffusion_Advection","tags":"","loc":"proc/calc_gm_diffusion_advection.html"},{"title":"Assemble_GM_Heat – FTDSS","text":"public subroutine Assemble_GM_Heat(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~assemble_gm_heat~~CallsGraph proc~assemble_gm_heat Assemble_GM_Heat proc~calc_gm_time_trm Calc_GM_Time_TRM proc~assemble_gm_heat->proc~calc_gm_time_trm proc~calc_gm_diffusion Calc_GM_Diffusion proc~assemble_gm_heat->proc~calc_gm_diffusion proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~assemble_gm_heat->proc~matrix_vector_product_crs proc~calc_gm_diffusion_trm Calc_GM_Diffusion_TRM proc~assemble_gm_heat->proc~calc_gm_diffusion_trm proc~calc_gm_time_divide Calc_GM_Time_Divide proc~assemble_gm_heat->proc~calc_gm_time_divide proc~calc_gm_diffusion_advection_trm Calc_GM_Diffusion_Advection_TRM proc~assemble_gm_heat->proc~calc_gm_diffusion_advection_trm proc~calc_gm_diffusion_advection Calc_GM_Diffusion_Advection proc~assemble_gm_heat->proc~calc_gm_diffusion_advection proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_time_trm->proc~find_crs_indexes proc~calc_gm_diffusion->proc~find_crs_indexes proc~calc_gm_diffusion_trm->proc~find_crs_indexes proc~calc_gm_time_divide->proc~find_crs_indexes proc~set_c Set_C proc~calc_gm_time_divide->proc~set_c proc~calc_gm_diffusion_advection_trm->proc~find_crs_indexes proc~calc_gm_diffusion_advection->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Assemble_GM_Heat Source Code subroutine Assemble_GM_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver if (. not . Solver % isWater ) then if ( Solver % Flags % isTRM ) then call Calc_GM_Time_TRM ( Solver ) call Calc_GM_Diffusion_TRM ( Solver ) call SpMV ( tmpCRS1 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isGCC . or . Solver % Flags % isPower ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) end if else if ( Solver % Flags % isTRM ) then call Calc_GM_Time_TRM ( Solver ) ! call Calc_GM_Time_TRM_F(Solver) call Calc_GM_Diffusion_Advection_TRM ( Solver ) ! call Calc_GM_Diffusion_TRM(Solver) call SpMV ( tmpCRS1 , Solver % T % old (:), Solver % Heat % Rhs (:)) ! print*,Solver%Heat%Rhs(:) ! stop ! Solver%Heat%RA(:,:) = Solver%Heat%RA(:,:) + tmpA(:,:) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isGCC . or . Solver % Flags % isPower ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion_Advection ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) end if end if end subroutine Assemble_GM_Heat","tags":"","loc":"proc/assemble_gm_heat.html"},{"title":"Assemble_GM_Heat_IC – FTDSS","text":"public subroutine Assemble_GM_Heat_IC(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~assemble_gm_heat_ic~~CallsGraph proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~calc_gm_time_trm Calc_GM_Time_TRM proc~assemble_gm_heat_ic->proc~calc_gm_time_trm proc~calc_gm_diffusion Calc_GM_Diffusion proc~assemble_gm_heat_ic->proc~calc_gm_diffusion proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~assemble_gm_heat_ic->proc~matrix_vector_product_crs proc~calc_gm_diffusion_trm Calc_GM_Diffusion_TRM proc~assemble_gm_heat_ic->proc~calc_gm_diffusion_trm proc~calc_gm_time_divide Calc_GM_Time_Divide proc~assemble_gm_heat_ic->proc~calc_gm_time_divide proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_time_trm->proc~find_crs_indexes proc~calc_gm_diffusion->proc~find_crs_indexes proc~calc_gm_diffusion_trm->proc~find_crs_indexes proc~calc_gm_time_divide->proc~find_crs_indexes proc~set_c Set_C proc~calc_gm_time_divide->proc~set_c proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assemble_gm_heat_ic~~CalledByGraph proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Assemble_GM_Heat_IC Source Code subroutine Assemble_GM_Heat_IC ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver ! if (.not. Solver%isWater) then if ( Solver % Flags % isTRM ) then call Calc_GM_Time_TRM ( Solver ) call Calc_GM_Diffusion_TRM ( Solver ) call SpMV ( tmpCRS1 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isGCC ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isPower ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) end if ! end if end subroutine Assemble_GM_Heat_IC","tags":"","loc":"proc/assemble_gm_heat_ic.html"},{"title":"Assemble_GM_Water – FTDSS","text":"public subroutine Assemble_GM_Water(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~assemble_gm_water~~CallsGraph proc~assemble_gm_water Assemble_GM_Water proc~calc_gm_time_richards Calc_GM_Time_Richards proc~assemble_gm_water->proc~calc_gm_time_richards proc~calc_gm_diffusion_richards_f Calc_GM_Diffusion_Richards_F proc~assemble_gm_water->proc~calc_gm_diffusion_richards_f proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~assemble_gm_water->proc~matrix_vector_product_crs proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_time_richards->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Assemble_GM_Water Source Code subroutine Assemble_GM_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Calc_GM_Time_Richards ( Solver ) ! call Calc_GM_Diffusion_Richards(Solver) call Calc_GM_Diffusion_Richards_F ( Solver ) call SpMV ( tmpCRS1 , Solver % mIce % dif (:), Solver % Water % Rhs (:)) ! print *, Solver%Water%Rhs(:) Solver % Water % Rhs (:) = - 1.0d0 * Solver % Water % Rhs (:) end subroutine Assemble_GM_Water","tags":"","loc":"proc/assemble_gm_water.html"},{"title":"Assemble_GM_Water_IC – FTDSS","text":"public subroutine Assemble_GM_Water_IC(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~assemble_gm_water_ic~~CallsGraph proc~assemble_gm_water_ic Assemble_GM_Water_IC proc~calc_gm_diffusion_richards_f Calc_GM_Diffusion_Richards_F proc~assemble_gm_water_ic->proc~calc_gm_diffusion_richards_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~assemble_gm_water_ic~~CalledByGraph proc~assemble_gm_water_ic Assemble_GM_Water_IC proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~fix_initialcondition_gradient_water->proc~assemble_gm_water_ic proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_water Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Assemble_GM_Water_IC Source Code subroutine Assemble_GM_Water_IC ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Calc_GM_Diffusion_Richards_F ( Solver ) Solver % Water % Rhs (:) = 0.0d0 end subroutine Assemble_GM_Water_IC","tags":"","loc":"proc/assemble_gm_water_ic.html"},{"title":"Convert_CRS – FTDSS","text":"public subroutine Convert_CRS(Solver, A) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(inout) :: A Calls proc~~convert_crs~~CallsGraph proc~convert_crs Convert_CRS interface~allocate_vector Allocate_Vector proc~convert_crs->interface~allocate_vector proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~error_message error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Convert_CRS Source Code subroutine Convert_CRS ( Solver , A ) implicit none type ( SolverInfo ), intent ( in ) :: Solver type ( CRS ), intent ( inout ) :: A ! integer(int32)                  :: i, j, k, l, row_nnz integer ( int32 ) :: iN , iE , iT , irT , iNC , iNNZ , row_nnz integer ( int32 ) :: nElment , nTop , nNode integer ( int32 ), allocatable :: vertex (:), row (:), tmpInd (:) nElment = Solver % N % element nTop = Solver % N % ShCoe nNode = Solver % N % node ! 0オリジンでベクトルを作成 call Allocate_Vector ( A % Ptr , 0 , nNode ) call Allocate_Vector ( row , 0 , nNode - 1 ) call Allocate_Vector ( tmpInd , 0 , 8 * nNode ) call Allocate_Vector ( vertex , nTop ) A % Ptr ( 0 ) = 0 A % nnz = 0 do iN = 1 , nNode row (:) = 0 row_nnz = 0 do iE = 1 , nElment ! iE番目の要素の頂点を取得 get_element_node : & & do iT = 1 , nTop vertex ( iT ) = Solver % N % pElement ( iT , iE ) end do get_element_node ! j番目の要素の頂点のうちいずれかの頂点がiNと一致する場合，ベクトルにインクリメント increament_vector : & & do iT = 1 , nTop if ( vertex ( iT ) == iN ) then do irT = 1 , nTop row ( vertex ( irT ) - 1 ) = row ( vertex ( irT ) - 1 ) + 1 end do exit increament_vector end if end do increament_vector end do ! ベクトルの非ゼロ要素の数をカウントし，CRSの仮ポインタに格納 do iNC = 0 , nNode - 1 if ( row ( iNC ) > 0 ) then tmpInd ( row_nnz + A % nnz ) = iNC row_nnz = row_nnz + 1 end if end do A % nnz = A % nnz + row_nnz A % Ptr ( iN ) = A % nnz end do ! CRS Matrixのメモリ確保 (0オリジン) call Allocate_Vector ( A % Ind , 0 , A % nnz - 1 ) call Allocate_Vector ( A % val , 0 , A % nnz - 1 ) ! CRSの初期化及び値の格納 do iNNZ = 0 , A % nnz - 1 A % val ( iNNZ ) = 0.0d0 A % Ind ( iNNZ ) = tmpInd ( iNNZ ) end do deallocate ( vertex ) deallocate ( row ) deallocate ( tmpInd ) end subroutine Convert_CRS","tags":"","loc":"proc/convert_crs.html"},{"title":"Heat_Constructor – FTDSS","text":"private function Heat_Constructor(Structure_Input) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Structure_Input Return Value type( Heat ) Calls proc~~heat_constructor~~CallsGraph proc~heat_constructor Heat_Constructor proc~set_geometory_infomation Set_Geometory_Infomation proc~heat_constructor->proc~set_geometory_infomation interface~hcf HCF proc~heat_constructor->interface~hcf array_hcf array_hcf proc~heat_constructor->array_hcf proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~heat_constructor->proc~set_boundary_condition_infomations proc~hcf_constructor HCF_Constructor interface~hcf->proc~hcf_constructor interface~count_if Count_if proc~set_boundary_condition_infomations->interface~count_if proc~condition_in_boundarycondition Condition_In_BoundaryCondition proc~set_boundary_condition_infomations->proc~condition_in_boundarycondition proc~condition_heat Condition_Heat proc~set_boundary_condition_infomations->proc~condition_heat interface~allocate_vector Allocate_Vector proc~set_boundary_condition_infomations->interface~allocate_vector proc~count_if_int32 Count_if_int32 interface~count_if->proc~count_if_int32 proc~count_if_int32_array Count_if_int32_Array interface~count_if->proc~count_if_int32_array proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~error_message error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~heat_constructor~~CalledByGraph proc~heat_constructor Heat_Constructor interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Heat_Constructor Source Code type ( Heat ) function Heat_Constructor ( Structure_Input ) type ( Input ), intent ( in ) :: Structure_Input call Set_Geometory_Infomation ( Heat_Constructor , Structure_Input ) call Set_Boundary_Condition_Infomations ( Heat_Constructor , Structure_Input ) block real ( real64 ) :: array_HCF ( 9 ) array_HCF = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] print * , array_HCF Heat_Constructor % HCFs = HCF ( array_HCF , 5 , 2 ) end block end function Heat_Constructor","tags":"","loc":"proc/heat_constructor.html"},{"title":"Condition_Heat – FTDSS","text":"private function Condition_Heat(num) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num Return Value logical Called by proc~~condition_heat~~CalledByGraph proc~condition_heat Condition_Heat proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->proc~condition_heat proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Condition_Heat Source Code logical function Condition_Heat ( num ) implicit none integer ( int32 ), intent ( in ) :: num if ( mod ( num , 8 ) >= 4 ) then Condition_Heat = . true . else Condition_Heat = . false . end if end function Condition_Heat","tags":"","loc":"proc/condition_heat.html"},{"title":"Condition_In_BoundaryCondition – FTDSS","text":"private function Condition_In_BoundaryCondition(num, Value_Info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num integer(kind=int32), intent(in) :: Value_Info (:) Return Value logical Called by proc~~condition_in_boundarycondition~~CalledByGraph proc~condition_in_boundarycondition Condition_In_BoundaryCondition proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->proc~condition_in_boundarycondition proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Condition_In_BoundaryCondition Source Code logical function Condition_In_BoundaryCondition ( num , Value_Info ) implicit none integer ( int32 ), intent ( in ) :: num integer ( int32 ), intent ( in ) :: Value_Info (:) ! 配列を引数として受け取る integer :: i logical :: found found = . false . do i = 1 , size ( Value_Info ) if ( num == Value_Info ( i )) then found = . true . exit end if end do Condition_In_BoundaryCondition = found end function Condition_In_BoundaryCondition","tags":"","loc":"proc/condition_in_boundarycondition.html"},{"title":"Set_Geometory_Infomation – FTDSS","text":"private subroutine Set_Geometory_Infomation(self, Structure_Input) Arguments Type Intent Optional Attributes Name type( Heat ), intent(inout) :: self type(Input), intent(in) :: Structure_Input Called by proc~~set_geometory_infomation~~CalledByGraph proc~set_geometory_infomation Set_Geometory_Infomation proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_geometory_infomation interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Set_Geometory_Infomation Source Code subroutine Set_Geometory_Infomation ( self , Structure_Input ) type ( Heat ), intent ( inout ) :: self type ( Input ), intent ( in ) :: Structure_Input self % Geometry % Num_Elements = Structure_Input % Input_Get_Elements () self % Geometry % Num_Nodes = Structure_Input % Input_Get_Nodes () self % Geometry % Num_Shape = Structure_Input % Input_Get_Shape () self % Geometry % Num_Dimention = Structure_Input % Input_Get_Dimemsion () self % Geometry % Num_Region = Structure_Input % Input_Get_Region () self % Geometry % Num_Shape_Type = self % Geometry % Num_Shape * self % Geometry % Num_Dimention self % Geometry % Element = Structure_Input % Input_Get_Top () self % Geometry % Element_Region = Structure_Input % Input_Get_Top_Region () self % Geometry % Nodes_2D = Structure_Input % Input_Get_Coordinates () self % Geometry % COO_Region = Structure_Input % Input_Get_Coordinates_Region () end subroutine Set_Geometory_Infomation","tags":"","loc":"proc/set_geometory_infomation.html"},{"title":"Set_Boundary_Condition_Infomations – FTDSS","text":"private subroutine Set_Boundary_Condition_Infomations(self, Structure_Input) Uses Calculate_Count proc~~set_boundary_condition_infomations~~UsesGraph proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations module~calculate_count Calculate_Count proc~set_boundary_condition_infomations->module~calculate_count module~error error module~calculate_count->module~error iso_fortran_env iso_fortran_env module~calculate_count->iso_fortran_env module~types Types module~calculate_count->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name type( Heat ), intent(inout) :: self type(Input), intent(in) :: Structure_Input Calls proc~~set_boundary_condition_infomations~~CallsGraph proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations interface~count_if Count_if proc~set_boundary_condition_infomations->interface~count_if interface~allocate_vector Allocate_Vector proc~set_boundary_condition_infomations->interface~allocate_vector proc~condition_heat Condition_Heat proc~set_boundary_condition_infomations->proc~condition_heat proc~condition_in_boundarycondition Condition_In_BoundaryCondition proc~set_boundary_condition_infomations->proc~condition_in_boundarycondition proc~count_if_int32 Count_if_int32 interface~count_if->proc~count_if_int32 proc~count_if_int32_array Count_if_int32_Array interface~count_if->proc~count_if_int32_array proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~error_message error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_boundary_condition_infomations~~CalledByGraph proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Set_Boundary_Condition_Infomations Source Code subroutine Set_Boundary_Condition_Infomations ( self , Structure_Input ) use :: Calculate_Count , only : Count_if implicit none type ( Heat ), intent ( inout ) :: self type ( Input ), intent ( in ) :: Structure_Input integer ( int32 ) :: Count_Heat integer ( int32 ) :: iBC , Counter integer ( int32 ), allocatable :: Work_Node (:), Work_Edge (:, :), Work_Type (:), Work_Value_Info (:, :) real ( real64 ), allocatable :: Work_Value (:) Work_Node = Structure_Input % Input_Get_BC_Node () Work_Type = Structure_Input % Input_Get_BC_Node_Type () Work_Value_Info = Structure_Input % Input_Get_BC_Node_Value_Info () Work_Value = Structure_Input % Input_Get_BC_Node_Value ( Calc_Heat ) self % BC % Dirichlet % Num_Type = Count_if ( Work_Value_Info (:, 2 ), Condition_Heat ) call Allocate_Vector ( self % BC % Dirichlet % Value_Info , self % BC % Dirichlet % Num_Type ) call Allocate_Vector ( self % BC % Dirichlet % value , self % BC % Dirichlet % Num_Type ) Counter = 0 do iBC = 1 , size ( Work_Value_Info (:, 2 )) if ( Condition_Heat ( Work_Value_Info ( iBC , 2 ))) then Counter = Counter + 1 self % BC % Dirichlet % Value_Info ( Counter ) = Work_Value_Info ( iBC , 1 ) self % BC % Dirichlet % value ( Counter ) = Work_Value ( iBC ) end if end do self % BC % Dirichlet % Num_Node = Count_if ( Work_Type (:), Condition_In_BoundaryCondition , self % BC % Dirichlet % Value_Info (:)) call Allocate_Vector ( self % BC % Dirichlet % Node , self % BC % Dirichlet % Num_Node ) call Allocate_Vector ( self % BC % Dirichlet % Node_Type , self % BC % Dirichlet % Num_Node ) Counter = 0 do iBC = 1 , size ( Work_Type ) if ( Condition_In_BoundaryCondition ( Work_Type ( iBC ), self % BC % Dirichlet % Value_Info (:))) then Counter = Counter + 1 self % BC % Dirichlet % Node ( Counter ) = Work_Node ( iBC ) self % BC % Dirichlet % Node_Type ( Counter ) = Work_Type ( iBC ) end if end do if ( allocated ( Work_Node )) deallocate ( Work_Node ) if ( allocated ( Work_Type )) deallocate ( Work_Type ) if ( allocated ( Work_Value_Info )) deallocate ( Work_Value_Info ) if ( allocated ( Work_Value )) deallocate ( Work_Value ) self % BC % Neumann % Edge = Structure_Input % Input_Get_BC_Edge () self % BC % Neumann % Edge_Type = Structure_Input % Input_Get_BC_Edge_Type () end subroutine Set_Boundary_Condition_Infomations","tags":"","loc":"proc/set_boundary_condition_infomations.html"},{"title":"Heat – FTDSS","text":"public interface Heat Calls interface~~heat~~CallsGraph interface~heat Heat proc~heat_constructor Heat_Constructor interface~heat->proc~heat_constructor proc~set_geometory_infomation Set_Geometory_Infomation proc~heat_constructor->proc~set_geometory_infomation interface~hcf HCF proc~heat_constructor->interface~hcf array_hcf array_hcf proc~heat_constructor->array_hcf proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~heat_constructor->proc~set_boundary_condition_infomations proc~hcf_constructor HCF_Constructor interface~hcf->proc~hcf_constructor interface~count_if Count_if proc~set_boundary_condition_infomations->interface~count_if proc~condition_in_boundarycondition Condition_In_BoundaryCondition proc~set_boundary_condition_infomations->proc~condition_in_boundarycondition proc~condition_heat Condition_Heat proc~set_boundary_condition_infomations->proc~condition_heat interface~allocate_vector Allocate_Vector proc~set_boundary_condition_infomations->interface~allocate_vector proc~count_if_int32 Count_if_int32 interface~count_if->proc~count_if_int32 proc~count_if_int32_array Count_if_int32_Array interface~count_if->proc~count_if_int32_array proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~error_message error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Heat_Constructor Module Procedures private function Heat_Constructor (Structure_Input) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Structure_Input Return Value type( Heat )","tags":"","loc":"interface/heat.html"},{"title":"init_omp_config – FTDSS","text":"public subroutine init_omp_config(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~init_omp_config~~CallsGraph proc~init_omp_config init_omp_config omp_set_max_active_levels omp_set_max_active_levels proc~init_omp_config->omp_set_max_active_levels omp_get_max_threads omp_get_max_threads proc~init_omp_config->omp_get_max_threads omp_get_num_procs omp_get_num_procs proc~init_omp_config->omp_get_num_procs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_omp_config Source Code subroutine init_omp_config ( Solver ) type ( SolverInfo ), intent ( inout ) :: Solver ! OpenMPの設定 ! call omp_set_dynamic(TRUE) call omp_set_max_active_levels ( 1 ) if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '' if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) 'OpenMP Properties' if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '-------------------------------------' if ( Solver % Flags % isStdOut ) write ( * , '(a,i0)' ) 'Max number of threads           = ' , omp_get_max_threads () if ( Solver % Flags % isStdOut ) write ( * , '(a,i0)' ) 'Number of processors availables = ' , omp_get_num_procs () if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '-------------------------------------' if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '' end subroutine init_omp_config","tags":"","loc":"proc/init_omp_config.html"},{"title":"Output_Constructor – FTDSS","text":"private function Output_Constructor(Inputs) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Inputs Return Value type( Output ) Calls proc~~output_constructor~~CallsGraph proc~output_constructor Output_Constructor proc~inout_setprojectpath_getprojectpath Inout_SetProjectPath_GetProjectPath proc~output_constructor->proc~inout_setprojectpath_getprojectpath interface~allocate_vector Allocate_Vector proc~output_constructor->interface~allocate_vector proc~set_output_flag Set_Output_Flag proc~output_constructor->proc~set_output_flag proc~inout_setprojectpath_setprojectpath Inout_SetProjectPath_SetProjectPath proc~inout_setprojectpath_getprojectpath->proc~inout_setprojectpath_setprojectpath proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~error_message error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~inout_setprojectpath_setprojectpath->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_int32->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~output_constructor~~CalledByGraph proc~output_constructor Output_Constructor interface~output Output interface~output->proc~output_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Output_Constructor Source Code type ( Output ) function Output_Constructor ( Inputs ) implicit none type ( Input ), intent ( in ) :: Inputs integer ( int32 ) :: Flag_Size integer ( int32 ), allocatable :: Output_Observation_Flag (:) ! character(256) :: dir_Path integer :: i integer ( int32 ) :: Output_File_Type ! Path settings Output_Constructor % dir_Path = GetProjectPath () Output_File_Type = Inputs % Input_Get_Output_File () if ( Output_File_Type == 1 ) then Output_Constructor % is_Output_Dat = . true . Output_Constructor % is_Output_VTK = . false . else if ( Output_File_Type == 2 ) then Output_Constructor % is_Output_Dat = . false . Output_Constructor % is_Output_VTK = . true . end if Output_Constructor % T_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_T.dat\" Output_Constructor % Fr_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_Fr.dat\" Output_Constructor % TC_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_TC.dat\" Output_Constructor % C_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_C.dat\" Output_Constructor % P_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_P.dat\" Output_Constructor % Flux_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_Flux.dat\" Output_Constructor % K_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_K.dat\" Output_Observation_Flag = Inputs % Input_Get_Observation_Flag () Flag_Size = size ( Output_Observation_Flag ) call Allocate_Vector ( Output_Constructor % is_Output , Flag_Size ) do i = 1 , Flag_Size call Set_Output_Flag ( Output_Observation_Flag ( i ), Output_Constructor % is_Output ( i )) end do if ( allocated ( Output_Observation_Flag )) deallocate ( Output_Observation_Flag ) end function Output_Constructor","tags":"","loc":"proc/output_constructor.html"},{"title":"Inout_Output_All – FTDSS","text":"private subroutine Inout_Output_All(self, Solver, num) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: num Calls proc~~inout_output_all~~CallsGraph proc~inout_output_all Inout_Output_All proc~inout_output_all_dat Inout_Output_All_Dat proc~inout_output_all->proc~inout_output_all_dat proc~inout_output_all_vtk Inout_Output_All_vtk proc~inout_output_all->proc~inout_output_all_vtk proc~error_message error_message proc~inout_output_all_dat->proc~error_message proc~inout_output_all_vtk->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Inout_Output_All Source Code subroutine Inout_Output_All ( self , Solver , num ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: num if ( self % is_Output_Dat ) call Inout_Output_All_Dat ( self , Solver , num ) if ( self % is_Output_VTK ) call Inout_Output_All_vtk ( self , Solver , num ) end subroutine Inout_Output_All","tags":"","loc":"proc/inout_output_all.html"},{"title":"Inout_Output_All_Dat – FTDSS","text":"private subroutine Inout_Output_All_Dat(self, Solver, num) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: num Calls proc~~inout_output_all_dat~~CallsGraph proc~inout_output_all_dat Inout_Output_All_Dat proc~error_message error_message proc~inout_output_all_dat->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inout_output_all_dat~~CalledByGraph proc~inout_output_all_dat Inout_Output_All_Dat proc~inout_output_all Inout_Output_All proc~inout_output_all->proc~inout_output_all_dat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Inout_Output_All_Dat Source Code subroutine Inout_Output_All_Dat ( self , Solver , num ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: num character ( 256 ) :: oName , fmt integer ( int32 ) :: ios , unit_num , iN write ( oName , Solver % fmt_Fileout ) trim ( self % dir_Path ), \"Output/DATFILE/Output_\" , num , \".dat\" open ( newunit = unit_num , file = oName , status = 'replace' , action = 'write' , iostat = ios ) if ( ios /= 0 ) call error_message ( 931 ) select case ( Solver % nAnalysis ) case ( 1 ) ! do iN = 1, Solver%N%node !     write(unit_num, '(es15.7,a,es15.7)') Solver%T%pre(iN), ', ', Solver%T%Si(iN) ! end do case ( 2 ) case ( 3 ) case ( 4 ) fmt = '(2es13.5,2es13.5)' do iN = 1 , Solver % N % node write ( unit_num , fmt ) Solver % N % vCood % x ( iN ), Solver % N % vCood % y ( iN ), Solver % T % pre ( iN ), Solver % Si % pre ( iN ) end do case ( 5 ) case ( 6 ) fmt = '(2es13.5,5es13.5)' do iN = 1 , Solver % N % node write ( unit_num , fmt ) Solver % N % vCood % x ( iN ), Solver % N % vCood % y ( iN ), Solver % T % pre ( iN ), Solver % P % pre ( iN ), Solver % Si % pre ( iN ), Solver % Water % Variables % wFlux % x ( iN ), + Solver % Water % Variables % wFlux % y ( iN ) end do case ( 7 ) end select close ( unit_num ) end subroutine Inout_Output_All_Dat","tags":"","loc":"proc/inout_output_all_dat.html"},{"title":"Inout_Output_Observation – FTDSS","text":"private subroutine Inout_Output_Observation(self, Solver, time) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver real(kind=real64), intent(in) :: time Contents Source Code Inout_Output_Observation Source Code subroutine Inout_Output_Observation ( self , Solver , time ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ), intent ( in ) :: time integer ( int32 ) :: unit_num , ios , iObs , nObs , iS , dim real ( real64 ) :: obsValue ( Solver % Obs % nObs ), obsValue2d ( 2 * Solver % Obs % nObs ) real ( real64 ) :: tmpValue character ( 64 ) :: ofmt nObs = Solver % Obs % nObs if ( Solver % Flags % outOBS ( 1 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % T_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % T_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % T % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % T % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 2 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % Fr_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % Fr_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Si % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Si % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 3 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , 2 * nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % TC_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % TC_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Heat % Variables % Tgrad % x ( Solver % Obs % obsPoint ( iObs )), Solver % Heat % Variables % Tgrad % y ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + ( Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Heat % Variables % Tgrad % x ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs )))) ** 2 ! tmpValue = tmpValue + sqrt((Solver%Obs%vAreaObs(iS, iObs) * Solver%Heat%Variables%Tgrad%x(Solver%N%pElement(iS, Solver%Obs%nAreaObs(iObs))))**2+(Solver%Obs%vAreaObs(iS, iObs) * Solver%Heat%Variables%Tgrad%y(Solver%N%pElement(iS, Solver%Obs%nAreaObs(iObs))))**2) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 4 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % C_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % C_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Flags % isTRM ) then if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Heat % Variables % Cp % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Heat % Variables % Cp % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if else if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Heat % Variables % Ca % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Heat % Variables % Ca % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 5 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % P_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % P_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % P % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % P % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 6 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , 2 * nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % Flux_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % Flux_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Water % Variables % wFlux % x ( Solver % Obs % obsPoint ( iObs )), Solver % Water % Variables % wFlux % y ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs do dim = 1 , 2 if ( dim == 1 ) then tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Water % Variables % wFlux % x ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do else do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Water % Variables % wFlux % y ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do end if obsValue ( 2 * ( iObs - 1 ) + dim ) = tmpValue end do end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , 2 * nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 7 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % K_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % K_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Water % Variables % Klh % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Water % Variables % Klh % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if end subroutine Inout_Output_Observation","tags":"","loc":"proc/inout_output_observation.html"},{"title":"Inout_Output_All_vtk – FTDSS","text":"private subroutine Inout_Output_All_vtk(self, Solver, num) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: num Calls proc~~inout_output_all_vtk~~CallsGraph proc~inout_output_all_vtk Inout_Output_All_vtk proc~error_message error_message proc~inout_output_all_vtk->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inout_output_all_vtk~~CalledByGraph proc~inout_output_all_vtk Inout_Output_All_vtk proc~inout_output_all Inout_Output_All proc~inout_output_all->proc~inout_output_all_vtk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Inout_Output_All_vtk Source Code subroutine Inout_Output_All_vtk ( self , Solver , num ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: num character ( 256 ) :: oName , fmt integer ( int32 ) :: ios , unit_num , iN real ( real64 ) :: wFlux_all ( 3 , Solver % N % node ) write ( oName , Solver % fmt_Fileout ) trim ( self % dir_Path ), \"Output/DATFILE/Output_\" , num , \".vtk\" open ( newunit = unit_num , file = oName , status = 'replace' , action = 'write' , iostat = ios ) if ( ios /= 0 ) call error_message ( 931 ) write ( unit_num , '(a)' ) \"# vtk DataFile Version 2.0\" write ( unit_num , '(a)' ) \"Analysis ASCII VTK file\" write ( unit_num , '(a)' ) \"ASCII\" write ( unit_num , '(a)' ) \"DATASET UNSTRUCTURED_GRID\" write ( unit_num , '(a,i0,a)' ) \"POINTS \" , Solver % N % node , \" double\" do iN = 1 , Solver % N % node write ( unit_num , '(3f18.13)' ) Solver % N % vCood % x ( iN ), Solver % N % vCood % y ( iN ), 0 end do write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a,i0,a,i0,a)' ) \"CELLS \" , Solver % N % element , \" \" , Solver % N % element * 4 do iN = 1 , Solver % N % element write ( unit_num , '(i0,a,i0,a,i0,a,i0)' ) Solver % N % ShCoe , \" \" , Solver % N % pElement ( 1 , iN ) - 1 , \" \" , Solver % N % pElement ( 2 , iN ) - 1 , \" \" , Solver % N % pElement ( 3 , iN ) - 1 end do write ( unit_num , '(a,i0,a)' ) \"CELL_TYPES \" , Solver % N % element do iN = 1 , Solver % N % element write ( unit_num , '(i0)' ) 5 end do select case ( Solver % nAnalysis ) case ( 1 ) ! do iN = 1, Solver%N%node !     write(unit_num, '(es15.7,a,es15.7)') Solver%T%pre(iN), ', ', Solver%T%Si(iN) ! end do case ( 2 ) case ( 3 ) case ( 4 ) write ( unit_num , '(a, i0)' ) \"POINT_DATA \" , Solver % N % node write ( unit_num , '(a)' ) \"SCALARS Temperature double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % T % pre (:) write ( unit_num , '(a)' ) \"SCALARS Pressure double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % P % pre (:) write ( unit_num , '(a)' ) \"SCALARS Si double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % Si % pre (:) case ( 6 ) wFlux_all ( 1 , :) = Solver % Water % Variables % wFlux % x (:) wFlux_all ( 2 , :) = Solver % Water % Variables % wFlux % y (:) wFlux_all ( 3 , :) = 0.0d0 write ( unit_num , '(a, i0)' ) \"POINT_DATA \" , Solver % N % node write ( unit_num , '(a)' ) \"SCALARS Temperature double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % T % pre (:) write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a)' ) \"SCALARS Pressure double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % P % pre (:) write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a)' ) \"SCALARS Si double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % Si % pre (:) write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a)' ) \"VECTORS WaterFlux double\" write ( unit_num , '(3es13.5)' ) wFlux_all case ( 7 ) end select close ( unit_num ) end subroutine Inout_Output_All_vtk","tags":"","loc":"proc/inout_output_all_vtk.html"},{"title":"Set_Output_Flag – FTDSS","text":"private subroutine Set_Output_Flag(iValue, inFlag) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iValue logical, intent(inout) :: inFlag Called by proc~~set_output_flag~~CalledByGraph proc~set_output_flag Set_Output_Flag proc~output_constructor Output_Constructor proc~output_constructor->proc~set_output_flag interface~output Output interface~output->proc~output_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Set_Output_Flag Source Code subroutine Set_Output_Flag ( iValue , inFlag ) implicit none integer ( int32 ), intent ( in ) :: iValue logical , intent ( inout ) :: inFlag if ( iValue == 1 ) then inFlag = . true . else inFlag = . false . end if end subroutine Set_Output_Flag","tags":"","loc":"proc/set_output_flag.html"},{"title":"Output – FTDSS","text":"public interface Output Calls interface~~output~~CallsGraph interface~output Output proc~output_constructor Output_Constructor interface~output->proc~output_constructor proc~inout_setprojectpath_getprojectpath Inout_SetProjectPath_GetProjectPath proc~output_constructor->proc~inout_setprojectpath_getprojectpath interface~allocate_vector Allocate_Vector proc~output_constructor->interface~allocate_vector proc~set_output_flag Set_Output_Flag proc~output_constructor->proc~set_output_flag proc~inout_setprojectpath_setprojectpath Inout_SetProjectPath_SetProjectPath proc~inout_setprojectpath_getprojectpath->proc~inout_setprojectpath_setprojectpath proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~error_message error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~inout_setprojectpath_setprojectpath->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_int32->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Output_Constructor Module Procedures private function Output_Constructor (Inputs) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Inputs Return Value type( Output )","tags":"","loc":"interface/output.html"},{"title":"Inout_SetProjectPath_GetProjectPath – FTDSS","text":"public function Inout_SetProjectPath_GetProjectPath() Arguments None Return Value character(len=256) Calls proc~~inout_setprojectpath_getprojectpath~~CallsGraph proc~inout_setprojectpath_getprojectpath Inout_SetProjectPath_GetProjectPath proc~inout_setprojectpath_setprojectpath Inout_SetProjectPath_SetProjectPath proc~inout_setprojectpath_getprojectpath->proc~inout_setprojectpath_setprojectpath proc~error_message error_message proc~inout_setprojectpath_setprojectpath->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inout_setprojectpath_getprojectpath~~CalledByGraph proc~inout_setprojectpath_getprojectpath Inout_SetProjectPath_GetProjectPath proc~output_constructor Output_Constructor proc~output_constructor->proc~inout_setprojectpath_getprojectpath interface~output Output interface~output->proc~output_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Inout_SetProjectPath_GetProjectPath Source Code character ( 256 ) function Inout_SetProjectPath_GetProjectPath () implicit none if (. not . isSetProjectPath ) call Inout_SetProjectPath_SetProjectPath Inout_SetProjectPath_GetProjectPath = ProjectPath end function Inout_SetProjectPath_GetProjectPath","tags":"","loc":"proc/inout_setprojectpath_getprojectpath.html"},{"title":"Inout_SetProjectPath_SetProjectPath – FTDSS","text":"private subroutine Inout_SetProjectPath_SetProjectPath() Arguments None Calls proc~~inout_setprojectpath_setprojectpath~~CallsGraph proc~inout_setprojectpath_setprojectpath Inout_SetProjectPath_SetProjectPath proc~error_message error_message proc~inout_setprojectpath_setprojectpath->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~inout_setprojectpath_setprojectpath~~CalledByGraph proc~inout_setprojectpath_setprojectpath Inout_SetProjectPath_SetProjectPath proc~inout_setprojectpath_getprojectpath Inout_SetProjectPath_GetProjectPath proc~inout_setprojectpath_getprojectpath->proc~inout_setprojectpath_setprojectpath proc~output_constructor Output_Constructor proc~output_constructor->proc~inout_setprojectpath_getprojectpath interface~output Output interface~output->proc~output_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Inout_SetProjectPath_SetProjectPath Source Code subroutine Inout_SetProjectPath_SetProjectPath implicit none character ( 64 ), parameter :: dName = \"ProjectPath.dir\" integer ( int32 ) :: access , status , len_path , unit_num integer :: i status = access ( dName , \"r\" ) if ( status /= 0 ) call error_message ( 901 , opt_file_name = dName ) open ( newunit = unit_num , file = dName , iostat = status , status = \"old\" ) if ( status /= 0 ) call error_message ( 902 , opt_file_name = dName ) read ( unit_num , '(a)' ) ProjectPath close ( unit_num ) len_path = len_trim ( ProjectPath ) ProjectPath = trim ( adjustl ( ProjectPath )) ! For windows, replace \"\\\\\" with \"/\" i = index ( ProjectPath , \"\\\\\" ) do while ( i > 0 ) ProjectPath ( i : i + 1 ) = \"/\" if ( i + 2 <= len_path ) then ProjectPath ( i + 1 :) = ProjectPath ( i + 2 :) // \" \" end if len_path = len_path - 1 i = index ( ProjectPath , \"\\\\\" ) end do ! For UNIX, replace \"\\\" with \"/\" i = index ( ProjectPath , \"\\\") do while (i > 0) ProjectPath(i:i) = \" / \" len_path = len_trim(ProjectPath) i = index(ProjectPath, \" \\ \") end do ! Add \" / \" to end to path if (len_path > 0 .and. ProjectPath(len_path:len_path) /= \" / \") then ProjectPath = trim(adjustl(ProjectPath))//\" / \" end if isSetProjectPath = . true . end subroutine Inout_SetProjectPath_SetProjectPath","tags":"","loc":"proc/inout_setprojectpath_setprojectpath.html"},{"title":"Calc_Area_31 – FTDSS","text":"public subroutine Calc_Area_31(Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry Calls proc~~calc_area_31~~CallsGraph proc~calc_area_31 Calc_Area_31 interface~set_point Set_Point proc~calc_area_31->interface~set_point proc~error_message error_message proc~calc_area_31->proc~error_message proc~set_point_31 Set_Point_31 interface~set_point->proc~set_point_31 mpi_finalize mpi_finalize proc~error_message->mpi_finalize proc~set_point_31->proc~error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_area_31~~CalledByGraph proc~calc_area_31 Calc_Area_31 interface~calc_area Calc_Area interface~calc_area->proc~calc_area_31 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_Area_31 Source Code subroutine Calc_Area_31 ( Geometry ) implicit none type ( Geometry2d ), intent ( inout ) :: Geometry type ( Vector2d ) :: p1 , p2 , p3 integer ( int32 ) :: elem do elem = 1 , Geometry % element call set_point ( Geometry , elem , p1 , p2 , p3 ) if ( elem < 1 . or . elem > Geometry % element ) then call error_message ( 932 ) else Geometry % eArea ( elem ) = abs (( p2 % x - p1 % x ) * ( p3 % y - p1 % y ) - ( p2 % y - p1 % y ) * ( p3 % x - p1 % x )) / 2.d0 end if end do end subroutine Calc_Area_31","tags":"","loc":"proc/calc_area_31.html"},{"title":"Calc_Area – FTDSS","text":"public interface Calc_Area Calls interface~~calc_area~~CallsGraph interface~calc_area Calc_Area proc~calc_area_31 Calc_Area_31 interface~calc_area->proc~calc_area_31 interface~set_point Set_Point proc~calc_area_31->interface~set_point proc~error_message error_message proc~calc_area_31->proc~error_message proc~set_point_31 Set_Point_31 interface~set_point->proc~set_point_31 mpi_finalize mpi_finalize proc~error_message->mpi_finalize proc~set_point_31->proc~error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Calc_Area_31 Module Procedures public subroutine Calc_Area_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry","tags":"","loc":"interface/calc_area.html"},{"title":"Set_Point_31 – FTDSS","text":"private subroutine Set_Point_31(Geometry, triangle_index, p1, p2, p3) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(in) :: Geometry integer(kind=int32), intent(in) :: triangle_index type( Vector2D ), intent(inout) :: p1 type( Vector2D ), intent(inout) :: p2 type( Vector2D ), intent(inout) :: p3 Calls proc~~set_point_31~~CallsGraph proc~set_point_31 Set_Point_31 proc~error_message error_message proc~set_point_31->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_point_31~~CalledByGraph proc~set_point_31 Set_Point_31 interface~set_point Set_Point interface~set_point->proc~set_point_31 proc~calc_area_31 Calc_Area_31 proc~calc_area_31->interface~set_point proc~calc_shape_31 Calc_Shape_31 proc~calc_shape_31->interface~set_point proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~set_point interface~calc_area Calc_Area interface~calc_area->proc~calc_area_31 interface~calc_shape Calc_Shape interface~calc_shape->proc~calc_shape_31 interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Set_Point_31 Source Code subroutine Set_Point_31 ( Geometry , triangle_index , p1 , p2 , p3 ) implicit none type ( Geometry2d ), intent ( in ) :: Geometry integer ( int32 ), intent ( in ) :: triangle_index type ( Vector2d ), intent ( inout ) :: p1 , p2 , p3 p1 % x = Geometry % vCood % x ( Geometry % pElement ( 1 , triangle_index )) p2 % x = Geometry % vCood % x ( Geometry % pElement ( 2 , triangle_index )) p3 % x = Geometry % vCood % x ( Geometry % pElement ( 3 , triangle_index )) p1 % y = Geometry % vCood % y ( Geometry % pElement ( 1 , triangle_index )) p2 % y = Geometry % vCood % y ( Geometry % pElement ( 2 , triangle_index )) p3 % y = Geometry % vCood % y ( Geometry % pElement ( 3 , triangle_index )) if ( p1 % x == p2 % x . and . p1 % y == p2 % y . or . & & p1 % x == p3 % x . and . p1 % y == p3 % y . or . & & p2 % x == p3 % x . and . p2 % y == p3 % y ) then call error_message ( 928 ) end if end subroutine Set_Point_31","tags":"","loc":"proc/set_point_31.html"},{"title":"Set_Point – FTDSS","text":"public interface Set_Point Calls interface~~set_point~~CallsGraph interface~set_point Set_Point proc~set_point_31 Set_Point_31 interface~set_point->proc~set_point_31 proc~error_message error_message proc~set_point_31->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~set_point~~CalledByGraph interface~set_point Set_Point proc~calc_area_31 Calc_Area_31 proc~calc_area_31->interface~set_point proc~calc_shape_31 Calc_Shape_31 proc~calc_shape_31->interface~set_point proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~set_point interface~calc_area Calc_Area interface~calc_area->proc~calc_area_31 interface~calc_shape Calc_Shape interface~calc_shape->proc~calc_shape_31 interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Set_Point_31 Module Procedures private subroutine Set_Point_31 (Geometry, triangle_index, p1, p2, p3) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(in) :: Geometry integer(kind=int32), intent(in) :: triangle_index type( Vector2D ), intent(inout) :: p1 type( Vector2D ), intent(inout) :: p2 type( Vector2D ), intent(inout) :: p3","tags":"","loc":"interface/set_point.html"},{"title":"HCF_Constructor – FTDSS","text":"public function HCF_Constructor(in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in_HCF_Parameters (:) integer(kind=int32), intent(in) :: HCF_Model_id integer(kind=int32), intent(in) :: Kflh_Model_id Return Value type( HCF ) Called by proc~~hcf_constructor~~CalledByGraph proc~hcf_constructor HCF_Constructor interface~hcf HCF interface~hcf->proc~hcf_constructor proc~heat_constructor Heat_Constructor proc~heat_constructor->interface~hcf interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code HCF_Constructor Source Code type ( HCF ) function HCF_Constructor ( in_HCF_Parameters , HCF_Model_id , Kflh_Model_id ) implicit none real ( real64 ), intent ( in ) :: in_HCF_Parameters (:) integer ( int32 ), intent ( in ) :: HCF_Model_id , Kflh_Model_id real ( real64 ), parameter :: Tcrit = 1 5.0d0 select case ( HCF_Model_id ) case ( 1 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % Ks = in_HCF_Parameters ( 5 ) HCF_Constructor % l = in_HCF_Parameters ( 6 ) HCF_Constructor % Calculate_HCF => Calculate_HCF_BC case ( 2 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % Ks = in_HCF_Parameters ( 5 ) HCF_Constructor % l = in_HCF_Parameters ( 6 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % Calculate_HCF => Calculate_HCF_VG case ( 3 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % Ks = in_HCF_Parameters ( 5 ) HCF_Constructor % l = in_HCF_Parameters ( 6 ) HCF_Constructor % Calculate_HCF => Calculate_HCF_KO case ( 4 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % hcrit = in_HCF_Parameters ( 5 ) HCF_Constructor % Ks = in_HCF_Parameters ( 6 ) HCF_Constructor % l = in_HCF_Parameters ( 7 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % Calculate_HCF => Calculate_HCF_MVG case ( 5 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % alpha2 = in_HCF_Parameters ( 5 ) HCF_Constructor % n2 = in_HCF_Parameters ( 6 ) HCF_Constructor % w1 = in_HCF_Parameters ( 7 ) HCF_Constructor % Ks = in_HCF_Parameters ( 8 ) HCF_Constructor % l = in_HCF_Parameters ( 9 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % m2 = 1.0d0 - 1.0d0 / HCF_Constructor % n2 HCF_Constructor % w2 = 1.0d0 - HCF_Constructor % w1 HCF_Constructor % Calculate_HCF => Calculate_HCF_Durner case ( 6 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % n2 = in_HCF_Parameters ( 5 ) HCF_Constructor % w1 = in_HCF_Parameters ( 6 ) HCF_Constructor % Ks = in_HCF_Parameters ( 7 ) HCF_Constructor % l = in_HCF_Parameters ( 8 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % m2 = 1.0d0 - 1.0d0 / HCF_Constructor % n2 HCF_Constructor % w2 = 1.0d0 - HCF_Constructor % w1 HCF_Constructor % Calculate_HCF => Calculate_HCF_DVGCH end select select case ( Kflh_Model_id ) case ( 3 , 5 ) HCF_Constructor % Calculate_HCF_mu => Calc_HCF_mu_Exponential HCF_Constructor % kzero = HCF_Constructor % Ks / HCF_Constructor % Calculate_HCF_mu ( Tcrit ) case ( 6 , 7 ) HCF_Constructor % Calculate_HCF_mu => Calc_HCF_mu_Exponential_Supercooled HCF_Constructor % kzero = HCF_Constructor % Ks / HCF_Constructor % Calculate_HCF_mu ( Tcrit ) end select end function HCF_Constructor","tags":"","loc":"proc/hcf_constructor.html"},{"title":"Calculate_Ks – FTDSS","text":"public function Calculate_Ks(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name class( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_Ks Source Code function Calculate_Ks ( Instance_HCF , h ) result ( kr ) implicit none class ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr ! select case (Instance_HCF%Ks) ! case (1) !     kr = Calculate_HCF_BC(Instance_HCF, h) ! case (2) !     kr = Calculate_HCF_VG(Instance_HCF, h) ! case (3) !     kr = Calculate_HCF_KO(Instance_HCF, h) ! case (4) !     kr = Calculate_HCF_MVG(Instance_HCF, h) ! case (5) !     kr = Calculate_HCF_Durner(Instance_HCF, h) ! case (6) !     kr = Calculate_HCF_DVGCH(Instance_HCF, h) ! end select kr = 1.0d0 end function Calculate_Ks","tags":"","loc":"proc/calculate_ks.html"},{"title":"Calculate_HCF_BC – FTDSS","text":"public function Calculate_HCF_BC(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_HCF_BC Source Code function Calculate_HCF_BC ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw if ( h < - 1.0d0 / Instance_HCF % alpha1 ) then Sw = abs ( Instance_HCF % alpha1 * h ) ** ( - Instance_HCF % n1 ) else Sw = 1.0d0 end if kr = Sw ** ( 2.0d0 / ( Instance_HCF % n1 + Instance_HCF % l + 2.0d0 )) end function Calculate_HCF_BC","tags":"","loc":"proc/calculate_hcf_bc.html"},{"title":"Calculate_HCF_VG – FTDSS","text":"public function Calculate_HCF_VG(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_HCF_VG Source Code function Calculate_HCF_VG ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw if ( h < 0 ) then Sw = ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) else Sw = 1.0d0 end if kr = Sw ** Instance_HCF % l * ( 1.0d0 - ( 1.0d0 - Sw ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) ** 2.0d0 end function Calculate_HCF_VG","tags":"","loc":"proc/calculate_hcf_vg.html"},{"title":"Calculate_HCF_KO – FTDSS","text":"public function Calculate_HCF_KO(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_HCF_KO Source Code function Calculate_HCF_KO ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw if ( h < 0 ) then Sw = 0.5d0 * erfc ( log ( h / Instance_HCF % alpha1 ) / ( Instance_HCF % n1 * sqrt ( 2.0d0 ))) kr = Sw ** 0.5d0 * ( 0.5d0 * erfc ( log ( h / Instance_HCF % alpha1 ) / ( Instance_HCF % n1 * sqrt ( 2.0d0 )) + Instance_HCF % n1 / sqrt ( 2.0d0 ))) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_KO","tags":"","loc":"proc/calculate_hcf_ko.html"},{"title":"Calculate_HCF_MVG – FTDSS","text":"public function Calculate_HCF_MVG(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_HCF_MVG Source Code function Calculate_HCF_MVG ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw , thetaM thetaM = Instance_HCF % thetaR + ( Instance_HCF % thetaS - Instance_HCF % thetaR ) * ( 1.0d0 + abs ( Instance_HCF % alpha1 * Instance_HCF % hcrit ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) if ( h < Instance_HCF % hcrit ) then Sw = ( Instance_HCF % thetaS - Instance_HCF % thetaR ) / ( thetaM - Instance_HCF % thetaR ) * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) kr = Sw ** Instance_HCF % l * (( 1.0d0 - ( 1.0d0 - Sw ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) / ( 1.0d0 - ( 1.0d0 - 1.0d0 ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 )) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_MVG","tags":"","loc":"proc/calculate_hcf_mvg.html"},{"title":"Calculate_HCF_Durner – FTDSS","text":"public function Calculate_HCF_Durner(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_HCF_Durner Source Code function Calculate_HCF_Durner ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw1 , Sw2 if ( h < 0 ) then Sw1 = Instance_HCF % w1 * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) Sw2 = Instance_HCF % w2 * ( 1.0d0 + abs ( Instance_HCF % alpha2 * h ) ** Instance_HCF % n2 ) ** ( - Instance_HCF % m2 ) kr = ( Instance_HCF % w1 * Sw1 + Instance_HCF % w2 * Sw2 ) ** Instance_HCF % l & * ( Instance_HCF % w1 * Instance_HCF % alpha1 * ( 1.0d0 - ( 1.0d0 - Sw1 ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) & + Instance_HCF % w2 * Instance_HCF % alpha2 * ( 1.0d0 - ( 1.0d0 - Sw2 ** ( 1.0d0 / Instance_HCF % m2 )) ** Instance_HCF % m2 )) ** 2.0d0 & / ( Instance_HCF % w1 * Instance_HCF % alpha1 + Instance_HCF % w2 * Instance_HCF % alpha2 ) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_Durner","tags":"","loc":"proc/calculate_hcf_durner.html"},{"title":"Calculate_HCF_DVGCH – FTDSS","text":"public function Calculate_HCF_DVGCH(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_HCF_DVGCH Source Code function Calculate_HCF_DVGCH ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw1 , Sw2 if ( h < 0 ) then Sw1 = Instance_HCF % w1 * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) Sw2 = Instance_HCF % w2 * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n2 ) ** ( - Instance_HCF % m2 ) kr = ( Instance_HCF % w1 * Sw1 + Instance_HCF % w2 * Sw2 ) ** Instance_HCF % l & * ( Instance_HCF % w1 * Instance_HCF % alpha1 * ( 1.0d0 - ( 1.0d0 - Sw1 ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) & + Instance_HCF % w2 * Instance_HCF % alpha1 * ( 1.0d0 - ( 1.0d0 - Sw2 ** ( 1.0d0 / Instance_HCF % m2 )) ** Instance_HCF % m2 )) ** 2.0d0 & / ( Instance_HCF % w1 * Instance_HCF % alpha1 + Instance_HCF % w2 * Instance_HCF % alpha2 ) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_DVGCH","tags":"","loc":"proc/calculate_hcf_dvgch.html"},{"title":"Calc_HCF_mu_Exponential – FTDSS","text":"public function Calc_HCF_mu_Exponential(T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64) Contents Source Code Calc_HCF_mu_Exponential Source Code function Calc_HCF_mu_Exponential ( T ) result ( mu ) implicit none real ( real64 ), intent ( in ) :: T real ( real64 ) :: mu mu = 2.1d-6 * exp ( 180 8.5d0 / ( T + 27 3.15d0 )) end function Calc_HCF_mu_Exponential","tags":"","loc":"proc/calc_hcf_mu_exponential.html"},{"title":"Calc_HCF_mu_Exponential_Supercooled – FTDSS","text":"public function Calc_HCF_mu_Exponential_Supercooled(T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64) Contents Source Code Calc_HCF_mu_Exponential_Supercooled Source Code function Calc_HCF_mu_Exponential_Supercooled ( T ) result ( mu ) implicit none real ( real64 ), intent ( in ) :: T real ( real64 ) :: mu mu = 1.3788d-4 * (( 27 3.15d0 + T ) / 22 5.66d0 - 1.0d0 ) ** ( - 1.6438 ) end function Calc_HCF_mu_Exponential_Supercooled","tags":"","loc":"proc/calc_hcf_mu_exponential_supercooled.html"},{"title":"HCF – FTDSS","text":"public interface HCF Calls interface~~hcf~~CallsGraph interface~hcf HCF proc~hcf_constructor HCF_Constructor interface~hcf->proc~hcf_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~hcf~~CalledByGraph interface~hcf HCF proc~heat_constructor Heat_Constructor proc~heat_constructor->interface~hcf interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures HCF_Constructor Module Procedures public function HCF_Constructor (in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in_HCF_Parameters (:) integer(kind=int32), intent(in) :: HCF_Model_id integer(kind=int32), intent(in) :: Kflh_Model_id Return Value type( HCF )","tags":"","loc":"interface/hcf.html"},{"title":"Matrix_Vector_Product_CRS – FTDSS","text":"public subroutine Matrix_Vector_Product_CRS(A, x, y) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A real(kind=real64), intent(in) :: x (:) real(kind=real64), intent(inout) :: y (:) Called by proc~~matrix_vector_product_crs~~CalledByGraph proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~matrix_vector_product_crs proc~solver_bicgstab Solver_BiCGStab proc~solver_bicgstab->proc~matrix_vector_product_crs proc~assemble_gm_water Assemble_GM_Water proc~assemble_gm_water->proc~matrix_vector_product_crs proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~assemble_gm_heat_ic->proc~matrix_vector_product_crs proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Matrix_Vector_Product_CRS Source Code subroutine Matrix_Vector_Product_CRS ( A , x , y ) implicit none type ( CRS ), intent ( in ) :: A real ( real64 ), intent ( in ) :: x (:) real ( real64 ), intent ( inout ) :: y (:) real ( real64 ) :: vtemp integer ( int32 ) :: i , j , is , ie integer ( int32 ) :: matrix_size matrix_size = size ( A % ptr ) - 1 y (:) = 0.0d0 !$omp parallel do private(vtemp, i, j, is, ie) do i = 1 , matrix_size vtemp = 0.0d0 is = A % ptr ( i - 1 ) ie = A % ptr ( i ) - 1 do j = is , ie vtemp = vtemp + A % val ( j ) * x ( A % ind ( j ) + 1 ) end do y ( i ) = vtemp end do !$omp end parallel do end subroutine Matrix_Vector_Product_CRS","tags":"","loc":"proc/matrix_vector_product_crs.html"},{"title":"Calculate_WRF_BC – FTDSS","text":"public function Calculate_WRF_BC(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_BC ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_WRF_BC Source Code function Calculate_WRF_BC ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_BC ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < - 1.0d0 / structure_WRF % alpha1 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * ( structure_WRF % alpha1 / h ) ** structure_WRF % n1 else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_BC","tags":"","loc":"proc/calculate_wrf_bc.html"},{"title":"Calculate_WRF_Derivative_BC – FTDSS","text":"public function Calculate_WRF_Derivative_BC(structure_WRF, h) result(Cw) Arguments Type Intent Optional Attributes Name type( Type_WRF_BC ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_WRF_Derivative_BC Source Code function Calculate_WRF_Derivative_BC ( structure_WRF , h ) result ( Cw ) type ( Type_WRF_BC ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: Cw if ( h < - 1.0d0 / structure_WRF % alpha1 ) then Cw = ( structure_WRF % thetaS - structure_WRF % thetaR ) * structure_WRF % n1 * ( structure_WRF % alpha1 / h ) ** ( structure_WRF % n1 + 1.0d0 ) / structure_WRF % alpha1 else Cw = 0.0d0 end if end function Calculate_WRF_Derivative_BC","tags":"","loc":"proc/calculate_wrf_derivative_bc.html"},{"title":"Calculate_WRF_VG – FTDSS","text":"public function Calculate_WRF_VG(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_VG ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_WRF_VG Source Code function Calculate_WRF_VG ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_VG ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * ( 1.0d0 + ( - structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_VG","tags":"","loc":"proc/calculate_wrf_vg.html"},{"title":"Calculate_WRF_KO – FTDSS","text":"public function Calculate_WRF_KO(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_KO ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_WRF_KO Source Code function Calculate_WRF_KO ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_KO ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * 0.5d0 * erfc ( log ( h / structure_WRF % alpha1 ) / ( structure_WRF % n1 * sqrt ( 2.0d0 ))) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_KO","tags":"","loc":"proc/calculate_wrf_ko.html"},{"title":"Calculate_WRF_MVG – FTDSS","text":"public function Calculate_WRF_MVG(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_MVG ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_WRF_MVG Source Code function Calculate_WRF_MVG ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_MVG ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < structure_WRF % hcrit ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_MVG","tags":"","loc":"proc/calculate_wrf_mvg.html"},{"title":"Calculate_WRF_Durner – FTDSS","text":"public function Calculate_WRF_Durner(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_Durner ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_WRF_Durner Source Code function Calculate_WRF_Durner ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_Durner ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * & ( structure_WRF % w1 * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) & + structure_WRF % w2 * ( 1.0d0 + abs ( structure_WRF % alpha2 * h ) ** structure_WRF % n2 ) ** ( - structure_WRF % m2 )) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_Durner","tags":"","loc":"proc/calculate_wrf_durner.html"},{"title":"Calculate_WRF_DVGCH – FTDSS","text":"public function Calculate_WRF_DVGCH(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_DVGCH ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents Source Code Calculate_WRF_DVGCH Source Code function Calculate_WRF_DVGCH ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_DVGCH ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * & ( structure_WRF % w1 * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) & + structure_WRF % w2 * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n2 ) ** ( - structure_WRF % m2 )) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_DVGCH","tags":"","loc":"proc/calculate_wrf_dvgch.html"},{"title":"Update_Parameters_Heat – FTDSS","text":"public subroutine Update_Parameters_Heat(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~update_parameters_heat~~CallsGraph proc~update_parameters_heat Update_Parameters_Heat proc~update_theta Update_theta proc~update_parameters_heat->proc~update_theta proc~update_cadiv Update_Cadiv proc~update_parameters_heat->proc~update_cadiv proc~update_variables_arithmetic Update_Variables_Arithmetic proc~update_parameters_heat->proc~update_variables_arithmetic proc~update_flux Update_Flux proc~update_parameters_heat->proc~update_flux proc~update_cpa_power Update_Cpa_Power proc~update_parameters_heat->proc~update_cpa_power proc~update_variables_geometric Update_Variables_Geometric proc~update_parameters_heat->proc~update_variables_geometric proc~update_cpa_gcc Update_Cpa_GCC proc~update_parameters_heat->proc~update_cpa_gcc proc~update_phase Update_Phase proc~update_parameters_heat->proc~update_phase proc~update_gradient Update_Gradient proc~update_parameters_heat->proc~update_gradient proc~update_heat_flux Update_Heat_Flux proc~update_parameters_heat->proc~update_heat_flux Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_parameters_heat~~CalledByGraph proc~update_parameters_heat Update_Parameters_Heat proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Parameters_Heat Source Code subroutine Update_Parameters_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Update_theta ( Solver ) call Update_Variables_Geometric ( Solver % Heat % Variables % lambda % pre (:), Solver % Heat % Constants % ThermalConductivity , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) call Update_Variables_Arithmetic ( Solver % Heat % Variables % rho % pre (:), Solver % Heat % Constants % Density , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) call Update_Variables_Arithmetic ( Solver % Heat % Variables % Cp % pre (:), Solver % Heat % Constants % HeatCapacity , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) call Update_Variables_Arithmetic ( Solver % Heat % Variables % Cs % pre (:), Solver % Heat % Constants % SpecificHeat , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) if ( Solver % Flags % isGCC ) then call Update_Cpa_GCC ( Solver ) else if ( Solver % Flags % isPower ) then call Update_Cpa_Power ( Solver ) end if if ( Solver % Flags % isGCC . or . Solver % Flags % isPower ) then call Update_Phase ( Solver ) call Update_Cadiv ( Solver ) end if if ( Solver % isWater ) then call Update_Gradient ( Solver , Solver % P % pre (:), Solver % Water % Variables % hGrad ) call Update_Flux ( Solver % Water % Variables % wFlux , Solver % Water % Variables % Klh % pre (:), Solver % Water % Variables % hGrad ) call Update_Gradient ( Solver , Solver % T % pre (:), Solver % Heat % Variables % TGrad ) ! print*,Solver%Heat%Constants%HeatCapacity%water ! print*,Solver%Water%Variables%wFlux%x(1:30)*Solver%T%pre(1:30)*Solver%Heat%Constants%HeatCapacity%water ! stop call Update_Heat_Flux ( Solver % Heat % Variables % TFlux , Solver % Heat % Variables % lambda % pre (:), Solver % Heat % Variables % TGrad , Solver % Heat % Constants % HeatCapacity % water , Solver % Water % Variables % wFlux , Solver % T % pre ) end if end subroutine Update_Parameters_Heat","tags":"","loc":"proc/update_parameters_heat.html"},{"title":"Update_Parameters_Water – FTDSS","text":"public subroutine Update_Parameters_Water(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~update_parameters_water~~CallsGraph proc~update_parameters_water Update_Parameters_Water proc~update_variables_log Update_Variables_Log proc~update_parameters_water->proc~update_variables_log Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_parameters_water~~CalledByGraph proc~update_parameters_water Update_Parameters_Water proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~fix_initialcondition_gradient_water->proc~update_parameters_water proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_water Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Parameters_Water Source Code subroutine Update_Parameters_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Update_Variables_Log ( Solver % Water % Variables % Klh % pre (:), Solver % Water % Constants % HydraulicConductivity , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) end subroutine Update_Parameters_Water","tags":"","loc":"proc/update_parameters_water.html"},{"title":"Update_theta – FTDSS","text":"public subroutine Update_theta(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Called by proc~~update_theta~~CalledByGraph proc~update_theta Update_theta proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_theta proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_theta Source Code subroutine Update_theta ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN real ( real64 ) :: Porosity Porosity = Solver % Heat % Constants % Porosity do iN = 1 , Solver % N % node Solver % mwater % pre ( iN ) = Porosity * ( 1 - Solver % Si % pre ( iN )) ! Water content is limited to the range of threshold to Porosity if ( Solver % mwater % pre ( iN ) < Porosity * threshold ) then Solver % mwater % pre ( iN ) = Porosity * threshold else if ( Solver % mwater % pre ( iN ) > Porosity ) then Solver % mwater % pre ( iN ) = Porosity end if ! Ice content is limited to the range of threshold to Porosity Solver % mIce % pre ( iN ) = Porosity * Solver % Si % pre ( iN ) Solver % mIce % dif ( iN ) = Solver % mIce % pre ( iN ) - Solver % mIce % old ( iN ) if ( Solver % mIce % dif ( iN ) > Porosity ) then Solver % mIce % dif ( iN ) = Porosity else if ( Solver % mIce % dif ( iN ) < - Porosity ) then Solver % mIce % dif ( iN ) = - Porosity end if end do end subroutine Update_theta","tags":"","loc":"proc/update_theta.html"},{"title":"Update_Variables_Arithmetic – FTDSS","text":"private subroutine Update_Variables_Arithmetic(Targets, Const, Si, Porosity, Flags) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: Targets (:) type( Phases ), intent(in) :: Const real(kind=real64), intent(in) :: Si (:) real(kind=real64), intent(in) :: Porosity type( Flag ), intent(in) :: Flags Called by proc~~update_variables_arithmetic~~CalledByGraph proc~update_variables_arithmetic Update_Variables_Arithmetic proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_variables_arithmetic proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Variables_Arithmetic Source Code subroutine Update_Variables_Arithmetic ( Targets , Const , Si , Porosity , Flags ) implicit none real ( real64 ), intent ( inout ) :: Targets (:) type ( Phases ), intent ( in ) :: Const real ( real64 ), intent ( in ) :: Si (:) real ( real64 ), intent ( in ) :: Porosity type ( Flag ), intent ( in ) :: Flags real ( real64 ) :: unfrozen , frozen integer ( int32 ) :: iN , nTarget nTarget = size ( Targets ) unfrozen = Const % soil * ( 1.0d0 - Porosity ) + Const % water * Porosity frozen = Const % soil * ( 1.0d0 - Porosity ) + Const % ice * Porosity if ( Flags % isTRM . and . Flags % isSwitchTRM ) then do iN = 1 , nTarget if ( Si ( iN ) == 1.0d0 ) Targets ( iN ) = frozen end do else do iN = 1 , nTarget Targets ( iN ) = Si ( iN ) * frozen + ( 1.0d0 - Si ( iN )) * unfrozen end do end if end subroutine Update_Variables_Arithmetic","tags":"","loc":"proc/update_variables_arithmetic.html"},{"title":"Update_Variables_Geometric – FTDSS","text":"private subroutine Update_Variables_Geometric(Targets, Const, Si, Porosity, Flags) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: Targets (:) type( Phases ), intent(in) :: Const real(kind=real64), intent(in) :: Si (:) real(kind=real64), intent(in) :: Porosity type( Flag ), intent(in) :: Flags Called by proc~~update_variables_geometric~~CalledByGraph proc~update_variables_geometric Update_Variables_Geometric proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_variables_geometric proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Variables_Geometric Source Code subroutine Update_Variables_Geometric ( Targets , Const , Si , Porosity , Flags ) implicit none real ( real64 ), intent ( inout ) :: Targets (:) type ( Phases ), intent ( in ) :: Const real ( real64 ), intent ( in ) :: Si (:) real ( real64 ), intent ( in ) :: Porosity type ( Flag ), intent ( in ) :: Flags real ( real64 ) :: unfrozen , frozen , rtWI integer ( int32 ) :: iN , nTarget nTarget = size ( Targets ) unfrozen = Const % soil ** ( 1.0d0 - Porosity ) * Const % water ** Porosity frozen = Const % soil ** ( 1.0d0 - Porosity ) * Const % ice ** Porosity rtWI = Const % ice / Const % water if ( Flags % isTRM . and . Flags % isSwitchTRM ) then do iN = 1 , nTarget if ( Si ( iN ) == 1.0d0 ) Targets ( iN ) = frozen end do else do iN = 1 , nTarget Targets ( iN ) = unfrozen * rtWI ** ( Porosity * Si ( iN )) end do end if end subroutine Update_Variables_Geometric","tags":"","loc":"proc/update_variables_geometric.html"},{"title":"Update_Variables_Log – FTDSS","text":"private subroutine Update_Variables_Log(Targets, Const, Si, Porosity, Flags) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: Targets (:) type( Phases ), intent(in) :: Const real(kind=real64), intent(in) :: Si (:) real(kind=real64), intent(in) :: Porosity type( Flag ), intent(in) :: Flags Called by proc~~update_variables_log~~CalledByGraph proc~update_variables_log Update_Variables_Log proc~update_parameters_water Update_Parameters_Water proc~update_parameters_water->proc~update_variables_log proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~fix_initialcondition_gradient_water->proc~update_parameters_water proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_water Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Variables_Log Source Code subroutine Update_Variables_Log ( Targets , Const , Si , Porosity , Flags ) implicit none real ( real64 ), intent ( inout ) :: Targets (:) type ( Phases ), intent ( in ) :: Const real ( real64 ), intent ( in ) :: Si (:) real ( real64 ), intent ( in ) :: Porosity type ( Flag ), intent ( in ) :: Flags real ( real64 ) :: k integer ( int32 ) :: iN , nTarget nTarget = size ( Targets ) k = log10 ( Const % ice / Const % soil ) ! if (Flags%isTRM .and. Flags%isSwitchTRM) then !     do iN = 1, nTarget ! \t\tif (Si(iN) == 1.0d0) Targets(iN) = Const%soil !     end do ! else do iN = 1 , nTarget Targets ( iN ) = Const % soil * 10 ** ( k * Si ( iN )) end do ! end if end subroutine Update_Variables_Log","tags":"","loc":"proc/update_variables_log.html"},{"title":"Update_Cpa_GCC – FTDSS","text":"private subroutine Update_Cpa_GCC(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Called by proc~~update_cpa_gcc~~CalledByGraph proc~update_cpa_gcc Update_Cpa_GCC proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_cpa_gcc proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Cpa_GCC Source Code subroutine Update_Cpa_GCC ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ) :: Qs , Qr , alpha , n , m , Tf , Lf , Dice , Cp real ( real64 ) :: A , B , C , T integer ( int32 ) :: iN Qs = Solver % Heat % Latent % GCC % thetaS Qr = Solver % Heat % Latent % GCC % thetaR alpha = Solver % Heat % Latent % GCC % alpha n = Solver % Heat % Latent % GCC % n m = Solver % Heat % Latent % GCC % m Tf = Solver % Heat % Latent % GCC % Tf Lf = Solver % Heat % Latent % Lf Dice = Solver % Heat % Latent % rhoI A = Qs - Qr B = alpha * Lf / g do iN = 1 , Solver % N % node T = Solver % T % pre ( iN ) Cp = Solver % Heat % Variables % Cp % pre ( iN ) if ( T < Tf ) then C = ( T + TtoK ) / ( Tf + TtoK ) Solver % Heat % Variables % Ca % pre ( iN ) = Cp - Lf * Dice * ( A * B ** 2 * n * m * log ( C ) * abs ( B * log ( C )) ** ( n - 2.d0 )) & / (( T + TtoK ) * ( 1.d0 + abs ( B * log ( C )) ** n ) ** ( m + 1.d0 )) else Solver % Heat % Variables % Ca % pre ( iN ) = Cp end if end do end subroutine Update_Cpa_GCC","tags":"","loc":"proc/update_cpa_gcc.html"},{"title":"Update_Cpa_Power – FTDSS","text":"private subroutine Update_Cpa_Power(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Called by proc~~update_cpa_power~~CalledByGraph proc~update_cpa_power Update_Cpa_Power proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_cpa_power proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Cpa_Power Source Code subroutine Update_Cpa_Power ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ) :: Lf , Dice , phi , Tf , a , Cp , T integer ( int32 ) :: iN Lf = Solver % Heat % Latent % Lf Dice = Solver % Heat % Latent % rhoI phi = Solver % Heat % Latent % Power % phi Tf = Solver % Heat % Latent % Power % Tf a = Solver % Heat % Latent % Power % a do iN = 1 , Solver % N % node T = Solver % T % pre ( iN ) Cp = Solver % Heat % Variables % Cp % pre ( iN ) if ( T < Tf ) then Solver % Heat % Variables % Ca % pre ( iN ) = Cp - Lf * Dice * phi * a * ( 1.0d0 - T + Tf ) ** ( a - 1.0d0 ) else Solver % Heat % Variables % Ca % pre ( iN ) = Cp end if end do end subroutine Update_Cpa_Power","tags":"","loc":"proc/update_cpa_power.html"},{"title":"Update_Phase – FTDSS","text":"private subroutine Update_Phase(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Called by proc~~update_phase~~CalledByGraph proc~update_phase Update_Phase proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_phase proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Phase Source Code subroutine Update_Phase ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN real ( real64 ) :: Tp , To do iN = 1 , Solver % N % node Tp = Solver % T % pre ( iN ) To = Solver % T % old ( iN ) if ( Tp >= 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = Linear else if ( Tp < 0.0d0 . and . To < 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = NonLinear else if ( Tp < 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = pTransition else Solver % Heat % Variables % Phase ( iN ) = nTransition end if end do end subroutine Update_Phase","tags":"","loc":"proc/update_phase.html"},{"title":"Update_Phase_Revise – FTDSS","text":"public subroutine Update_Phase_Revise(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~update_phase_revise~~CallsGraph proc~update_phase_revise Update_Phase_Revise proc~binary_finding Binary_finding proc~update_phase_revise->proc~binary_finding proc~calc_latentheatterm Calc_LatentHeatTerm proc~binary_finding->proc~calc_latentheatterm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Phase_Revise Source Code subroutine Update_Phase_Revise ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN real ( real64 ) :: Tp , To do iN = 1 , Solver % N % node Tp = Solver % T % pre ( iN ) To = Solver % T % old ( iN ) if ( Tp >= 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = Linear else if ( Tp < 0.0d0 . and . To < 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = NonLinear else if ( Tp < 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = pTransition ! call Secant_method(Solver, iN) call Binary_finding ( Solver , iN ) else Solver % Heat % Variables % Phase ( iN ) = nTransition end if end do end subroutine Update_Phase_Revise","tags":"","loc":"proc/update_phase_revise.html"},{"title":"Update_Cadiv – FTDSS","text":"private subroutine Update_Cadiv(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Called by proc~~update_cadiv~~CalledByGraph proc~update_cadiv Update_Cadiv proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_cadiv proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Cadiv Source Code subroutine Update_Cadiv ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN do iN = 1 , Solver % N % node if ( Solver % Heat % Variables % Phase ( iN ) == Linear ) then Solver % Heat % Variables % Ca % div ( iN ) = Solver % Heat % Variables % Ca % pre ( iN ) else if ( Solver % Heat % Variables % Phase ( iN ) == pTransition ) then if ( Solver % Flags % isGCC ) then Solver % Heat % Variables % Ca % div ( iN ) = ( Solver % Heat % Variables % Ca % pre ( iN ) * Solver % Heat % Latent % GCC % Ca_max ) ** 0.5d0 else if ( Solver % Flags % isPower ) then Solver % Heat % Variables % Ca % div ( iN ) = ( Solver % Heat % Variables % Ca % pre ( iN ) * Solver % Heat % Latent % Power % Ca_max ) ** 0.5d0 end if else if ( Solver % Heat % Variables % Phase ( iN ) == NonLinear ) then Solver % Heat % Variables % Ca % div ( iN ) = ( Solver % Heat % Variables % Ca % pre ( iN ) * Solver % Heat % Variables % Ca % old ( iN )) ** 0.5d0 end if end do end subroutine Update_Cadiv","tags":"","loc":"proc/update_cadiv.html"},{"title":"Update_Si – FTDSS","text":"public subroutine Update_Si(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents Source Code Update_Si Source Code subroutine Update_Si ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ) :: A , B , C real ( real64 ) :: Qs , Qr , alpha , n , m , Lf , Dice , Tf integer ( int32 ) :: iN if ( Solver % Flags % isGCC ) then Qs = Solver % Heat % Latent % GCC % thetaS Qr = Solver % Heat % Latent % GCC % thetaR alpha = Solver % Heat % Latent % GCC % alpha n = Solver % Heat % Latent % GCC % n m = Solver % Heat % Latent % GCC % m Lf = Solver % Heat % Latent % Lf Dice = Solver % Heat % Latent % rhoI Tf = Solver % Heat % Latent % GCC % Tf A = Qs - Qr B = alpha * Lf / g do iN = 1 , Solver % N % node C = ( Solver % T % pre ( iN ) + TtoK ) / ( Tf + TtoK ) if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = ( A * ( 1.0d0 - ( 1.0d0 + abs ( B * log ( C )) ** n ) ** ( - m ))) / Qs else Solver % Si % pre ( iN ) = 0.0d0 end if end do else if ( Solver % Flags % isPower ) then Tf = Solver % Heat % Latent % Power % Tf alpha = Solver % Heat % Latent % Power % a do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = 1.0d0 - ( 1.0d0 - Solver % T % pre ( iN ) + Tf ) ** alpha else Solver % Si % pre ( iN ) = 0.0d0 end if end do end if end subroutine Update_Si","tags":"","loc":"proc/update_si.html"},{"title":"Update_Gradient – FTDSS","text":"public subroutine Update_Gradient(Solver, ar, Grad) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver real(kind=real64), intent(in) :: ar (:) type( DP2d ), intent(inout) :: Grad Called by proc~~update_gradient~~CalledByGraph proc~update_gradient Update_Gradient proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_gradient proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Gradient Source Code subroutine Update_Gradient ( Solver , ar , Grad ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ), intent ( in ) :: ar (:) type ( DP2d ), intent ( inout ) :: Grad integer ( int32 ) :: counter ( SOlver % N % node ) integer ( int32 ) :: iN , p1 , p2 , p3 real ( real64 ) :: gx , gy counter (:) = 0 Grad % x (:) = 0.0d0 Grad % y (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) gx = ( Solver % N % Basis % b ( 1 , iN ) * ar ( p1 ) + Solver % N % Basis % b ( 2 , iN ) * ar ( p2 ) + Solver % N % Basis % b ( 3 , iN ) * ar ( p3 )) / ( 2.0d0 * Solver % N % eArea ( iN )) gy = ( Solver % N % Basis % c ( 1 , iN ) * ar ( p1 ) + Solver % N % Basis % c ( 2 , iN ) * ar ( p2 ) + Solver % N % Basis % c ( 3 , iN ) * ar ( p3 )) / ( 2.0d0 * Solver % N % eArea ( iN )) Grad % x ( p1 ) = Grad % x ( p1 ) + gx Grad % y ( p1 ) = Grad % y ( p1 ) + gy Grad % x ( p2 ) = Grad % x ( p2 ) + gx Grad % y ( p2 ) = Grad % y ( p2 ) + gy Grad % x ( p3 ) = Grad % x ( p3 ) + gx Grad % y ( p3 ) = Grad % y ( p3 ) + gy counter ( p1 ) = counter ( p1 ) + 1 counter ( p2 ) = counter ( p2 ) + 1 counter ( p3 ) = counter ( p3 ) + 1 end do Grad % x (:) = Grad % x (:) / counter (:) Grad % y (:) = Grad % y (:) / counter (:) end subroutine Update_Gradient","tags":"","loc":"proc/update_gradient.html"},{"title":"Update_Flux – FTDSS","text":"private subroutine Update_Flux(Flux, C, Grad) Arguments Type Intent Optional Attributes Name type( DP2d ), intent(inout) :: Flux real(kind=real64), intent(in) :: C (:) type( DP2d ), intent(in) :: Grad Called by proc~~update_flux~~CalledByGraph proc~update_flux Update_Flux proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_flux proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Flux Source Code subroutine Update_Flux ( Flux , C , Grad ) implicit none type ( DP2d ), intent ( inout ) :: Flux type ( DP2d ), intent ( in ) :: Grad real ( real64 ), intent ( in ) :: C (:) Flux % x (:) = - C (:) * Grad % x (:) Flux % y (:) = - C (:) * Grad % y (:) end subroutine Update_Flux","tags":"","loc":"proc/update_flux.html"},{"title":"Update_Heat_Flux – FTDSS","text":"private subroutine Update_Heat_Flux(TFlux, C, TGrad, Cw, Qw, T) Arguments Type Intent Optional Attributes Name type( DP2d ), intent(inout) :: TFlux real(kind=real64), intent(in) :: C (:) type( DP2d ), intent(in) :: TGrad real(kind=real64), intent(in) :: Cw type( DP2d ), intent(in) :: Qw real(kind=real64), intent(in) :: T (:) Called by proc~~update_heat_flux~~CalledByGraph proc~update_heat_flux Update_Heat_Flux proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_heat_flux proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Update_Heat_Flux Source Code subroutine Update_Heat_Flux ( TFlux , C , TGrad , Cw , Qw , T ) implicit none type ( DP2d ), intent ( inout ) :: TFlux type ( DP2d ), intent ( in ) :: TGrad real ( real64 ), intent ( in ) :: C (:) real ( real64 ), intent ( in ) :: Cw type ( DP2d ), intent ( in ) :: Qw real ( real64 ), intent ( in ) :: T (:) TFlux % x (:) = - C (:) * TGrad % x (:) TFlux % y (:) = - C (:) * TGrad % y (:) ! print*, TFlux%x(:) ! stop end subroutine Update_Heat_Flux","tags":"","loc":"proc/update_heat_flux.html"},{"title":"Count_if_int32 – FTDSS","text":"public function Count_if_int32(array, Condition) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value logical Return Value integer Called by proc~~count_if_int32~~CalledByGraph proc~count_if_int32 Count_if_int32 interface~count_if Count_if interface~count_if->proc~count_if_int32 proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->interface~count_if proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Count_if_int32 Source Code function Count_if_int32 ( array , Condition ) result ( count ) implicit none interface logical function Condition ( x ) integer , intent ( in ) :: x end function Condition end interface integer , intent ( in ) :: array (:) ! 入力配列 integer :: count ! 条件を満たす要素の個数 integer :: i count = 0 do i = 1 , size ( array ) if ( Condition ( array ( i ))) count = count + 1 end do end function Count_if_int32","tags":"","loc":"proc/count_if_int32.html"},{"title":"Count_if_int32_Array – FTDSS","text":"public function Count_if_int32_Array(array, Condition, condition_array) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x, condition_array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: condition_array (:) Return Value logical integer, intent(in) :: condition_array (:) Return Value integer Called by proc~~count_if_int32_array~~CalledByGraph proc~count_if_int32_array Count_if_int32_Array interface~count_if Count_if interface~count_if->proc~count_if_int32_array proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->interface~count_if proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Count_if_int32_Array Source Code function Count_if_int32_Array ( array , condition , condition_array ) result ( count ) implicit none interface logical function Condition ( x , condition_array ) integer , intent ( in ) :: x integer , intent ( in ) :: condition_array (:) end function Condition end interface integer , intent ( in ) :: array (:) ! 入力配列 integer , intent ( in ) :: condition_array (:) ! 条件配列 integer :: count ! 条件を満たす要素の個数 integer :: i count = 0 do i = 1 , size ( array ) if ( Condition ( array ( i ), condition_array )) count = count + 1 end do end function Count_if_int32_Array","tags":"","loc":"proc/count_if_int32_array.html"},{"title":"Count_if – FTDSS","text":"public interface Count_if Calls interface~~count_if~~CallsGraph interface~count_if Count_if proc~count_if_int32 Count_if_int32 interface~count_if->proc~count_if_int32 proc~count_if_int32_array Count_if_int32_Array interface~count_if->proc~count_if_int32_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~count_if~~CalledByGraph interface~count_if Count_if proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->interface~count_if proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Count_if_int32 Count_if_int32_Array Module Procedures public function Count_if_int32 (array, Condition) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value logical Return Value integer public function Count_if_int32_Array (array, Condition, condition_array) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x, condition_array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: condition_array (:) Return Value logical integer, intent(in) :: condition_array (:) Return Value integer","tags":"","loc":"interface/count_if.html"},{"title":"TRMethod – FTDSS","text":"public subroutine TRMethod(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents Source Code TRMethod Source Code subroutine TRMethod ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ), parameter :: vTf = 0.0d0 real ( real64 ) :: Fr_tmp real ( real64 ) :: C , TRM_BTM , tmpSi integer ( int32 ) :: iN , vector_size if ( Solver % Flags % isSwitchOnceTRM ) then TRM_BTM = 1.0d0 / Solver % Heat % Constants % Density % water * Solver % Heat % Constants % Porosity * Solver % Heat % Constants % LatentHeat ! $omp parallel do private(iN, C, tmpSi) do iN = 1 , Solver % N % node C = Solver % Heat % Variables % rho % pre ( iN ) * Solver % Heat % Variables % Cs % pre ( iN ) * TRM_BTM tmpSi = Solver % Si % old ( iN ) + C * ( vTf - Solver % T % new ( iN )) if ( tmpSi <= 0.0d0 . and . Solver % Si % old ( iN ) == 0.0d0 ) then Solver % Si % new ( iN ) = 0.0d0 else if ( tmpSi >= 1.0d0 . and . Solver % Si % old ( iN ) == 1.0d0 ) then Solver % Si % new ( iN ) = 1.0d0 else if ( 0.0d0 < tmpSi . and . tmpSi < 1.0d0 . and . Solver % Si % old ( iN ) <= 1.0d0 ) then Solver % T % new ( iN ) = vTf Solver % Si % new ( iN ) = tmpSi else if ( 0.0d0 < Solver % Si % old ( iN ) . and . Solver % Si % old ( iN ) < 1.0d0 . and . tmpSi >= 1.0d0 ) then Solver % T % new ( iN ) = vTf + ( 1.0d0 - tmpSi ) / C Solver % Si % new ( iN ) = 1.0d0 end if end do ! $omp end parallel do else ! $omp parallel do private(iN, C, tmpSi, TRM_BTM) ! print*,Solver%Heat%Variables%Cs%pre(:) ! stop do iN = 1 , Solver % N % node TRM_BTM = Solver % Heat % Constants % Density % water * Solver % Heat % Constants % LatentHeat C = Solver % Heat % Variables % rho % pre ( iN ) * Solver % Heat % Variables % Cs % pre ( iN ) / ( Solver % mWater % pre ( iN ) * TRM_BTM ) tmpSi = Solver % Si % old ( iN ) + C * ( vTf - Solver % T % new ( iN )) if ( tmpSi <= 0.0d0 . and . Solver % Si % old ( iN ) == 0.0d0 ) then Solver % Si % new ( iN ) = 0.0d0 else if ( tmpSi >= 1.0d0 . and . Solver % Si % old ( iN ) == 1.0d0 ) then Solver % Si % new ( iN ) = 1.0d0 else if ( 0.0d0 < tmpSi . and . tmpSi < 1.0d0 . and . Solver % Si % old ( iN ) <= 1.0d0 ) then Solver % T % new ( iN ) = vTf Solver % Si % new ( iN ) = tmpSi else if ( 0.0d0 < Solver % Si % old ( iN ) . and . Solver % Si % old ( iN ) < 1.0d0 . and . tmpSi >= 1.0d0 ) then Solver % T % new ( iN ) = vTf + ( 1.0d0 - tmpSi ) / C Solver % Si % new ( iN ) = 1.0d0 end if end do ! $omp end parallel do end if ! stop ! do iN = 250,260 ! \tprint*,Solver%Si%new(iN), Solver%T%new(iN) ! end do end subroutine TRMethod","tags":"","loc":"proc/trmethod.html"},{"title":"is_in_triangle – FTDSS","text":"private function is_in_triangle(x, y, p1, p2, p3) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y type( Vector2D ), intent(in) :: p1 type( Vector2D ), intent(in) :: p2 type( Vector2D ), intent(in) :: p3 Return Value logical Called by proc~~is_in_triangle~~CalledByGraph proc~is_in_triangle is_in_triangle proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->proc~is_in_triangle interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code is_in_triangle Source Code logical function is_in_triangle ( x , y , p1 , p2 , p3 ) implicit none type ( Vector2d ), intent ( in ) :: p1 , p2 , p3 real ( real64 ), intent ( in ) :: x , y is_in_triangle = . false . if ( 0.0d0 <= ( p2 % y - p3 % y ) * ( x - p3 % x ) + ( p3 % x - p2 % x ) * ( y - p3 % y ) . and . & & 0.0d0 <= ( p3 % y - p1 % y ) * ( x - p1 % x ) + ( p1 % x - p3 % x ) * ( y - p1 % y ) . and . & & 0.0d0 <= ( p1 % y - p2 % y ) * ( x - p2 % x ) + ( p2 % x - p1 % x ) * ( y - p2 % y )) then is_in_triangle = . true . end if end function is_in_triangle","tags":"","loc":"proc/is_in_triangle.html"},{"title":"Set_Obs_COO_31 – FTDSS","text":"private subroutine Set_Obs_COO_31(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~set_obs_coo_31~~CallsGraph proc~set_obs_coo_31 Set_Obs_COO_31 interface~allocate_vector Allocate_Vector proc~set_obs_coo_31->interface~allocate_vector proc~is_in_triangle is_in_triangle proc~set_obs_coo_31->proc~is_in_triangle interface~set_point Set_Point proc~set_obs_coo_31->interface~set_point interface~allocate_matrix Allocate_Matrix proc~set_obs_coo_31->interface~allocate_matrix proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~set_point_31 Set_Point_31 interface~set_point->proc~set_point_31 proc~check_allocate_rank2_real64 Check_Allocate_rank2_real64 interface~allocate_matrix->proc~check_allocate_rank2_real64 proc~check_allocate_rank2_int32 Check_Allocate_rank2_int32 interface~allocate_matrix->proc~check_allocate_rank2_int32 proc~error_message error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_real64->proc~error_message proc~set_point_31->proc~error_message proc~check_allocate_rank2_real64->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message proc~check_allocate_rank2_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_obs_coo_31~~CalledByGraph proc~set_obs_coo_31 Set_Obs_COO_31 interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Set_Obs_COO_31 Source Code subroutine Set_Obs_COO_31 ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver type ( Vector2d ) :: p1 , p2 , p3 integer ( int32 ) :: iE , iObs , iS real ( real64 ) :: x , y , s call Allocate_Vector ( Solver % Obs % nAreaObs , Solver % Obs % nObs ) call Allocate_Matrix ( Solver % Obs % vAreaObs , Solver % N % ShCoe , Solver % Obs % nObs ) do iObs = 1 , Solver % Obs % nObs x = Solver % Obs % obsCOO % x ( iObs ) y = Solver % Obs % obsCOO % y ( iObs ) do iE = 1 , Solver % N % Element call Set_Point ( Solver % N , iE , p1 , p2 , p3 ) if ( is_in_triangle ( x , y , p1 , p2 , p3 )) then s = Solver % N % eArea ( iE ) do iS = 1 , Solver % N % ShCoe Solver % Obs % vAreaObs ( iS , iObs ) = ( Solver % N % Basis % a ( iS , iE ) + Solver % N % Basis % b ( iS , iE ) * x & & + Solver % N % Basis % c ( iS , iE ) * y ) / ( 2.0d0 * s ) end do Solver % Obs % nAreaObs ( iObs ) = iE exit end if end do end do end subroutine Set_Obs_COO_31","tags":"","loc":"proc/set_obs_coo_31.html"},{"title":"Set_Obs_COO – FTDSS","text":"public interface Set_Obs_COO Calls interface~~set_obs_coo~~CallsGraph interface~set_obs_coo Set_Obs_COO proc~set_obs_coo_31 Set_Obs_COO_31 interface~set_obs_coo->proc~set_obs_coo_31 interface~allocate_vector Allocate_Vector proc~set_obs_coo_31->interface~allocate_vector proc~is_in_triangle is_in_triangle proc~set_obs_coo_31->proc~is_in_triangle interface~set_point Set_Point proc~set_obs_coo_31->interface~set_point interface~allocate_matrix Allocate_Matrix proc~set_obs_coo_31->interface~allocate_matrix proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~set_point_31 Set_Point_31 interface~set_point->proc~set_point_31 proc~check_allocate_rank2_real64 Check_Allocate_rank2_real64 interface~allocate_matrix->proc~check_allocate_rank2_real64 proc~check_allocate_rank2_int32 Check_Allocate_rank2_int32 interface~allocate_matrix->proc~check_allocate_rank2_int32 proc~error_message error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_real64->proc~error_message proc~set_point_31->proc~error_message proc~check_allocate_rank2_real64->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message proc~check_allocate_rank2_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Set_Obs_COO_31 Module Procedures private subroutine Set_Obs_COO_31 (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"interface/set_obs_coo.html"},{"title":"Calc_LatentHeatTerm – FTDSS","text":"public function Calc_LatentHeatTerm(T, Tnew, Latent) result(res) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tnew type( LatentHeatTreatment ), intent(in) :: Latent Return Value real(kind=real64) Called by proc~~calc_latentheatterm~~CalledByGraph proc~calc_latentheatterm Calc_LatentHeatTerm proc~binary_finding Binary_finding proc~binary_finding->proc~calc_latentheatterm proc~secant_method Secant_method proc~secant_method->proc~calc_latentheatterm proc~update_phase_revise Update_Phase_Revise proc~update_phase_revise->proc~binary_finding Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_LatentHeatTerm Source Code function Calc_LatentHeatTerm ( T , Tnew , Latent ) result ( res ) implicit none real ( real64 ) :: res real ( real64 ), intent ( in ) :: T , Tnew type ( LatentHeatTreatment ), intent ( in ) :: Latent ! 20: GCC, 30: Power if ( Latent % useModel == 20 ) then res = Latent % Cp_unf * ( T - Tnew ) - Latent % Lf * Latent % rhoI * ( Latent % GCC % thetaS - Latent % GCC % thetaR ) & * ( 1.0d0 - ( 1.0d0 + abs ( Latent % GCC % alpha * Latent % Lf * log (( TtoK + T ) / TtoK ) / g ) ** Latent % GCC % n ) ** ( - Latent % GCC % m )) else if ( Latent % useModel == 30 ) then res = Latent % Cp_unf * ( T - Tnew ) / ( Latent % Lf * Latent % rhoI * Latent % Power % phi ) & + ( 1.0d0 - T + Latent % Power % Tf ) ** Latent % Power % a - 1.0d0 end if end function Calc_LatentHeatTerm","tags":"","loc":"proc/calc_latentheatterm.html"},{"title":"Calc_Ca_GCC – FTDSS","text":"private function Calc_Ca_GCC(Heat, T) result(Ca) Arguments Type Intent Optional Attributes Name type( HeatFields ), intent(in) :: Heat real(kind=real64), intent(in) :: T Return Value real(kind=real64) Called by proc~~calc_ca_gcc~~CalledByGraph proc~calc_ca_gcc Calc_Ca_GCC proc~find_ca_max Find_Ca_max proc~find_ca_max->proc~calc_ca_gcc proc~initialize_solver Initialize_Solver proc~initialize_solver->proc~find_ca_max Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_Ca_GCC Source Code function Calc_Ca_GCC ( Heat , T ) result ( Ca ) implicit none type ( HeatFields ), intent ( in ) :: Heat real ( real64 ), intent ( in ) :: T real ( real64 ) :: Ca real ( real64 ) :: Cp , Si , A , B , C real ( real64 ) :: Qs , Qr , alpha , n , m , Lf , Dice , Tf Qs = Heat % Latent % GCC % thetaS Qr = Heat % Latent % GCC % thetaR alpha = Heat % Latent % GCC % alpha n = Heat % Latent % GCC % n m = Heat % Latent % GCC % m Lf = Heat % Latent % Lf Dice = Heat % Latent % rhoI Tf = Heat % Latent % GCC % Tf A = Qs - Qr B = alpha * Lf / g C = ( T + TtoK ) / ( Tf + TtoK ) if ( T < Tf ) then Si = ( A * ( 1.0d0 - ( 1.0d0 + abs ( B * log ( C )) ** n ) ** ( - m ))) / Qs else Si = 0.0d0 end if Cp = Heat % Constants % HeatCapacity % soil * ( 1.0d0 - Heat % Constants % Porosity ) & + Heat % Constants % HeatCapacity % water * Heat % Constants % Porosity * ( 1.0d0 - Si ) & + Heat % Constants % HeatCapacity % ice * Heat % Constants % Porosity * Si if ( T < Tf ) then Ca = Cp - Lf * Dice * ( A * B ** 2 * n * m * log ( C ) * abs ( B * log ( C )) ** ( n - 2.d0 )) & / (( T + TtoK ) * ( 1.d0 + abs ( B * log ( C )) ** n ) ** ( m + 1.d0 )) else Ca = Cp end if end function Calc_Ca_GCC","tags":"","loc":"proc/calc_ca_gcc.html"},{"title":"Find_Ca_max – FTDSS","text":"public subroutine Find_Ca_max(Heat) Arguments Type Intent Optional Attributes Name type( HeatFields ), intent(inout) :: Heat Calls proc~~find_ca_max~~CallsGraph proc~find_ca_max Find_Ca_max proc~calc_ca_gcc Calc_Ca_GCC proc~find_ca_max->proc~calc_ca_gcc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~find_ca_max~~CalledByGraph proc~find_ca_max Find_Ca_max proc~initialize_solver Initialize_Solver proc~initialize_solver->proc~find_ca_max Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Find_Ca_max Source Code subroutine Find_Ca_max ( Heat ) implicit none type ( HeatFields ), intent ( inout ) :: Heat real ( real64 ) :: x0 , x1 , x2 , x3 , f1 , f2 , tau real ( real64 ), parameter :: epsilon = 1.0d-15 if ( Heat % Latent % useModel == 20 ) then tau = ( sqrt ( 5.d0 ) - 1.d0 ) / 2.d0 ! 黄金比 x0 = 0.0d0 x3 = - 1.0d0 x1 = x0 + ( 1.d0 - tau ) * ( x3 - x0 ) x2 = x0 + tau * ( x3 - x0 ) f1 = Calc_Ca_GCC ( Heat , x1 ) f2 = Calc_Ca_GCC ( Heat , x2 ) do while ( abs ( x3 - x0 ) > epsilon ) if ( f2 > f1 ) then x0 = x1 x1 = x2 x2 = x0 + tau * ( x3 - x0 ) f1 = f2 f2 = Calc_Ca_GCC ( Heat , x2 ) else x3 = x2 x2 = x1 x1 = x0 + ( 1.d0 - tau ) * ( x3 - x0 ) f2 = f1 f1 = Calc_Ca_GCC ( Heat , x1 ) end if end do Heat % Latent % GCC % Ca_max = Calc_Ca_GCC ( Heat , ( x1 + x2 ) / 2.d0 ) else if ( Heat % Latent % useModel == 30 ) then Heat % Latent % Power % Ca_max = Heat % Latent % Cp_unf - Heat % Latent % Lf * Heat % Latent % rhoI * Heat % Latent % Power % phi * Heat % Latent % Power % a end if end subroutine Find_Ca_max","tags":"","loc":"proc/find_ca_max.html"},{"title":"Calculate_GCC_NonSegregation_kPa – FTDSS","text":"private function Calculate_GCC_NonSegregation_kPa(T, Tf, Lf, rhoW) result(Suction_kPa) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW Return Value real(kind=real64) Called by proc~~calculate_gcc_nonsegregation_kpa~~CalledByGraph proc~calculate_gcc_nonsegregation_kpa Calculate_GCC_NonSegregation_kPa interface~calculate_gcc_nonsegregation Calculate_GCC_NonSegregation interface~calculate_gcc_nonsegregation->proc~calculate_gcc_nonsegregation_kpa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calculate_GCC_NonSegregation_kPa Source Code function Calculate_GCC_NonSegregation_kPa ( T , Tf , Lf , rhoW ) result ( Suction_kPa ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf , rhoW real ( real64 ) :: Suction_kPa if ( T <= Tf ) then Suction_kPa = - Lf * rhoW * log (( T + TtoK ) / ( Tf + TtoK )) else Suction_kPa = 0.0d0 end if end function Calculate_GCC_NonSegregation_kPa","tags":"","loc":"proc/calculate_gcc_nonsegregation_kpa.html"},{"title":"Calculate_GCC_NonSegregation_m – FTDSS","text":"private function Calculate_GCC_NonSegregation_m(T, Tf, Lf) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf Return Value real(kind=real64) Called by proc~~calculate_gcc_nonsegregation_m~~CalledByGraph proc~calculate_gcc_nonsegregation_m Calculate_GCC_NonSegregation_m interface~calculate_gcc_nonsegregation Calculate_GCC_NonSegregation interface~calculate_gcc_nonsegregation->proc~calculate_gcc_nonsegregation_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calculate_GCC_NonSegregation_m Source Code function Calculate_GCC_NonSegregation_m ( T , Tf , Lf ) result ( Suction_m ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf real ( real64 ) :: Suction_m if ( T <= Tf ) then Suction_m = - Lf * log (( T + TtoK ) / ( Tf + TtoK )) / g else Suction_m = 0.0d0 end if end function Calculate_GCC_NonSegregation_m","tags":"","loc":"proc/calculate_gcc_nonsegregation_m.html"},{"title":"Calculate_GCC_NonSegregation_Derivative_kPa – FTDSS","text":"private function Calculate_GCC_NonSegregation_Derivative_kPa(T, Tf, Lf, rhoW) result(Suction_kPa_Derivative) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW Return Value real(kind=real64) Called by proc~~calculate_gcc_nonsegregation_derivative_kpa~~CalledByGraph proc~calculate_gcc_nonsegregation_derivative_kpa Calculate_GCC_NonSegregation_Derivative_kPa interface~calculate_gcc_nonsegregation_derivative Calculate_GCC_NonSegregation_Derivative interface~calculate_gcc_nonsegregation_derivative->proc~calculate_gcc_nonsegregation_derivative_kpa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calculate_GCC_NonSegregation_Derivative_kPa Source Code function Calculate_GCC_NonSegregation_Derivative_kPa ( T , Tf , Lf , rhoW ) result ( Suction_kPa_Derivative ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf , rhoW real ( real64 ) :: Suction_kPa_Derivative if ( T <= Tf ) then Suction_kPa_Derivative = - Lf * rhoW / ( T + TtoK ) else Suction_kPa_Derivative = 0.0d0 end if end function Calculate_GCC_NonSegregation_Derivative_kPa","tags":"","loc":"proc/calculate_gcc_nonsegregation_derivative_kpa.html"},{"title":"Calculate_GCC_NonSegregation_Derivative_m – FTDSS","text":"private function Calculate_GCC_NonSegregation_Derivative_m(T, Tf, Lf) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf Return Value real(kind=real64) Called by proc~~calculate_gcc_nonsegregation_derivative_m~~CalledByGraph proc~calculate_gcc_nonsegregation_derivative_m Calculate_GCC_NonSegregation_Derivative_m interface~calculate_gcc_nonsegregation_derivative Calculate_GCC_NonSegregation_Derivative interface~calculate_gcc_nonsegregation_derivative->proc~calculate_gcc_nonsegregation_derivative_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calculate_GCC_NonSegregation_Derivative_m Source Code function Calculate_GCC_NonSegregation_Derivative_m ( T , Tf , Lf ) result ( Suction_m ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf real ( real64 ) :: Suction_m if ( T <= Tf ) then Suction_m = - Lf / (( T + TtoK ) * g ) else Suction_m = 0.0d0 end if end function Calculate_GCC_NonSegregation_Derivative_m","tags":"","loc":"proc/calculate_gcc_nonsegregation_derivative_m.html"},{"title":"Calculate_GCC_Segregation_kPa – FTDSS","text":"private function Calculate_GCC_Segregation_kPa(T, Pw_kPa, Tf, Lf, rhoW, rhoI) result(Suction_kPa) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Pw_kPa real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW real(kind=real64), intent(in) :: rhoI Return Value real(kind=real64) Contents Source Code Calculate_GCC_Segregation_kPa Source Code function Calculate_GCC_Segregation_kPa ( T , Pw_kPa , Tf , Lf , rhoW , rhoI ) result ( Suction_kPa ) implicit none real ( real64 ), intent ( in ) :: T , Pw_kPa , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_kPa if ( T <= Tf ) then Suction_kPa = ( rhoI / rhoW - 1.0d0 ) * Pw_kPa - Lf * rhoI * log (( T + TtoK ) / ( Tf + TtoK )) else Suction_kPa = 0.0d0 end if end function Calculate_GCC_Segregation_kPa","tags":"","loc":"proc/calculate_gcc_segregation_kpa.html"},{"title":"Calculate_GCC_Segregation_m – FTDSS","text":"private function Calculate_GCC_Segregation_m(T, Pw_m, Tf, Lf, rhoW, rhoI) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Pw_m real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW real(kind=real64), intent(in) :: rhoI Return Value real(kind=real64) Contents Source Code Calculate_GCC_Segregation_m Source Code function Calculate_GCC_Segregation_m ( T , Pw_m , Tf , Lf , rhoW , rhoI ) result ( Suction_m ) implicit none real ( real64 ), intent ( in ) :: T , Pw_m , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_m if ( T <= Tf ) then Suction_m = (( rhoI / rhoW - 1.0d0 ) * Pw_m - Lf * rhoI * log (( T + TtoK ) / ( Tf + TtoK ))) / ( rhoW * g ) else Suction_m = 0.0d0 end if end function Calculate_GCC_Segregation_m","tags":"","loc":"proc/calculate_gcc_segregation_m.html"},{"title":"Calculate_GCC_Segregation_Derivative_kPa – FTDSS","text":"private function Calculate_GCC_Segregation_Derivative_kPa(T, Pw_kPa, Tf, Lf, rhoW, rhoI) result(Suction_kPa_Derivative) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Pw_kPa real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW real(kind=real64), intent(in) :: rhoI Return Value real(kind=real64) Contents Source Code Calculate_GCC_Segregation_Derivative_kPa Source Code function Calculate_GCC_Segregation_Derivative_kPa ( T , Pw_kPa , Tf , Lf , rhoW , rhoI ) result ( Suction_kPa_Derivative ) implicit none real ( real64 ), intent ( in ) :: T , Pw_kPa , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_kPa_Derivative if ( T <= Tf ) then Suction_kPa_Derivative = - Lf * rhoW / ( T + TtoK ) else Suction_kPa_Derivative = 0.0d0 end if end function Calculate_GCC_Segregation_Derivative_kPa","tags":"","loc":"proc/calculate_gcc_segregation_derivative_kpa.html"},{"title":"Calculate_GCC_Segregation_Derivative_m – FTDSS","text":"private function Calculate_GCC_Segregation_Derivative_m(T, Pw_m, Tf, Lf, rhoW, rhoI) result(Suction_m_Derivative) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Pw_m real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW real(kind=real64), intent(in) :: rhoI Return Value real(kind=real64) Contents Source Code Calculate_GCC_Segregation_Derivative_m Source Code function Calculate_GCC_Segregation_Derivative_m ( T , Pw_m , Tf , Lf , rhoW , rhoI ) result ( Suction_m_Derivative ) implicit none real ( real64 ), intent ( in ) :: T , Pw_m , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_m_Derivative if ( T <= Tf ) then Suction_m_Derivative = - Lf / (( T + TtoK ) * g ) else Suction_m_Derivative = 0.0d0 end if end function Calculate_GCC_Segregation_Derivative_m","tags":"","loc":"proc/calculate_gcc_segregation_derivative_m.html"},{"title":"Set_Calculate_GCC_Segregation – FTDSS","text":"public subroutine Set_Calculate_GCC_Segregation(Segregation_type) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: Segregation_type Contents Source Code Set_Calculate_GCC_Segregation Source Code subroutine Set_Calculate_GCC_Segregation ( Segregation_type ) implicit none integer ( int32 ), intent ( in ) :: Segregation_type if ( associated ( Calculate_GCC_Segregation )) nullify ( Calculate_GCC_Segregation ) if ( associated ( Calculate_GCC_Segregation_Derivative )) nullify ( Calculate_GCC_Segregation_Derivative ) select case ( Segregation_type ) case ( 1 ) Calculate_GCC_Segregation => Calculate_GCC_Segregation_kPa Calculate_GCC_Segregation_Derivative => Calculate_GCC_Segregation_Derivative_kPa case ( 2 ) Calculate_GCC_Segregation => Calculate_GCC_Segregation_m Calculate_GCC_Segregation_Derivative => Calculate_GCC_Segregation_Derivative_m end select end subroutine Set_Calculate_GCC_Segregation","tags":"","loc":"proc/set_calculate_gcc_segregation.html"},{"title":"Calculate_GCC_NonSegregation – FTDSS","text":"public interface Calculate_GCC_NonSegregation Calls interface~~calculate_gcc_nonsegregation~~CallsGraph interface~calculate_gcc_nonsegregation Calculate_GCC_NonSegregation proc~calculate_gcc_nonsegregation_kpa Calculate_GCC_NonSegregation_kPa interface~calculate_gcc_nonsegregation->proc~calculate_gcc_nonsegregation_kpa proc~calculate_gcc_nonsegregation_m Calculate_GCC_NonSegregation_m interface~calculate_gcc_nonsegregation->proc~calculate_gcc_nonsegregation_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Calculate_GCC_NonSegregation_kPa Calculate_GCC_NonSegregation_m Module Procedures private function Calculate_GCC_NonSegregation_kPa (T, Tf, Lf, rhoW) result(Suction_kPa) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW Return Value real(kind=real64) private function Calculate_GCC_NonSegregation_m (T, Tf, Lf) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf Return Value real(kind=real64)","tags":"","loc":"interface/calculate_gcc_nonsegregation.html"},{"title":"Calculate_GCC_NonSegregation_Derivative – FTDSS","text":"private interface Calculate_GCC_NonSegregation_Derivative Calls interface~~calculate_gcc_nonsegregation_derivative~~CallsGraph interface~calculate_gcc_nonsegregation_derivative Calculate_GCC_NonSegregation_Derivative proc~calculate_gcc_nonsegregation_derivative_kpa Calculate_GCC_NonSegregation_Derivative_kPa interface~calculate_gcc_nonsegregation_derivative->proc~calculate_gcc_nonsegregation_derivative_kpa proc~calculate_gcc_nonsegregation_derivative_m Calculate_GCC_NonSegregation_Derivative_m interface~calculate_gcc_nonsegregation_derivative->proc~calculate_gcc_nonsegregation_derivative_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Calculate_GCC_NonSegregation_Derivative_kPa Calculate_GCC_NonSegregation_Derivative_m Module Procedures private function Calculate_GCC_NonSegregation_Derivative_kPa (T, Tf, Lf, rhoW) result(Suction_kPa_Derivative) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW Return Value real(kind=real64) private function Calculate_GCC_NonSegregation_Derivative_m (T, Tf, Lf) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf Return Value real(kind=real64)","tags":"","loc":"interface/calculate_gcc_nonsegregation_derivative.html"},{"title":"Calc_Shape_31 – FTDSS","text":"public subroutine Calc_Shape_31(Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry Calls proc~~calc_shape_31~~CallsGraph proc~calc_shape_31 Calc_Shape_31 interface~set_point Set_Point proc~calc_shape_31->interface~set_point proc~error_message error_message proc~calc_shape_31->proc~error_message proc~set_point_31 Set_Point_31 interface~set_point->proc~set_point_31 mpi_finalize mpi_finalize proc~error_message->mpi_finalize proc~set_point_31->proc~error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~calc_shape_31~~CalledByGraph proc~calc_shape_31 Calc_Shape_31 interface~calc_shape Calc_Shape interface~calc_shape->proc~calc_shape_31 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Calc_Shape_31 Source Code subroutine Calc_Shape_31 ( Geometry ) implicit none type ( Geometry2d ), intent ( inout ) :: Geometry type ( Vector2d ) :: p1 , p2 , p3 integer ( int32 ) :: iE do iE = 1 , Geometry % Element call set_point ( Geometry , iE , p1 , p2 , p3 ) if ( iE < 1 . or . iE > Geometry % Element ) then call error_message ( 932 ) else Geometry % Basis % a ( 1 , iE ) = p2 % x * p3 % y - p3 % x * p2 % y Geometry % Basis % a ( 2 , iE ) = p3 % x * p1 % y - p1 % x * p3 % y Geometry % Basis % a ( 3 , iE ) = p1 % x * p2 % y - p2 % x * p1 % y Geometry % Basis % b ( 1 , iE ) = p2 % y - p3 % y Geometry % Basis % b ( 2 , iE ) = p3 % y - p1 % y Geometry % Basis % b ( 3 , iE ) = p1 % y - p2 % y Geometry % Basis % c ( 1 , iE ) = p3 % x - p2 % x Geometry % Basis % c ( 2 , iE ) = p1 % x - p3 % x Geometry % Basis % c ( 3 , iE ) = p2 % x - p1 % x end if end do end subroutine Calc_Shape_31","tags":"","loc":"proc/calc_shape_31.html"},{"title":"Calc_Shape – FTDSS","text":"public interface Calc_Shape Calls interface~~calc_shape~~CallsGraph interface~calc_shape Calc_Shape proc~calc_shape_31 Calc_Shape_31 interface~calc_shape->proc~calc_shape_31 interface~set_point Set_Point proc~calc_shape_31->interface~set_point proc~error_message error_message proc~calc_shape_31->proc~error_message proc~set_point_31 Set_Point_31 interface~set_point->proc~set_point_31 mpi_finalize mpi_finalize proc~error_message->mpi_finalize proc~set_point_31->proc~error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Calc_Shape_31 Module Procedures public subroutine Calc_Shape_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry","tags":"","loc":"interface/calc_shape.html"},{"title":"norm_2 – FTDSS","text":"public function norm_2(N, x) result(norm) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: x (:) Return Value real(kind=real64) Called by proc~~norm_2~~CalledByGraph proc~norm_2 norm_2 proc~solver_bicgstab Solver_BiCGStab proc~solver_bicgstab->proc~norm_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code norm_2 Source Code function norm_2 ( N , x ) result ( norm ) implicit none integer ( int32 ), intent ( in ) :: N real ( real64 ), intent ( in ) :: x (:) real ( real64 ) :: norm integer ( int32 ) :: iN , ithread , nthreads real ( real64 ), allocatable :: partial_sums (:) ! nthreads = omp_get_max_threads() ! allocate(partial_sums(nthreads)) ! partial_sums = 0.0d0 norm = 0.0d0 ! $omp parallel private(iN, ithread) ! ithread = omp_get_thread_num() + 1 ! $omp do do iN = 1 , N norm = norm + x ( iN ) ** 2 end do ! $omp end do ! $omp end parallel ! メモリ解放 deallocate ( partial_sums ) end function norm_2","tags":"","loc":"proc/norm_2.html"},{"title":"ddots – FTDSS","text":"public function ddots(N, x, y) result(dot) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: x (:) real(kind=real64), intent(in) :: y (:) Return Value real(kind=real64) Called by proc~~ddots~~CalledByGraph proc~ddots ddots proc~solver_bicgstab Solver_BiCGStab proc~solver_bicgstab->proc~ddots Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ddots Source Code function ddots ( N , x , y ) result ( dot ) implicit none integer ( int32 ), intent ( in ) :: N real ( real64 ), intent ( in ) :: x (:), y (:) real ( real64 ) :: dot integer ( int32 ) :: iN , ithread , nthreads real ( real64 ), allocatable :: partial_sums (:) ! nthreads = omp_get_max_threads() ! allocate(partial_sums(nthreads)) ! partial_sums = 0.0d0 dot = 0.0d0 ! $omp parallel private(iN, ithread) ! ithread = omp_get_thread_num() + 1 ! $omp do do iN = 1 , N dot = dot + x ( iN ) * y ( iN ) end do ! $omp end do ! $omp end parallel ! dot = sum(partial_sums) end function ddots","tags":"","loc":"proc/ddots.html"},{"title":"Solve_Initialize_BiCGStab – FTDSS","text":"private function Solve_Initialize_BiCGStab(Solver, MCRS) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(in) :: MCRS Return Value type( ILS ) Calls proc~~solve_initialize_bicgstab~~CallsGraph proc~solve_initialize_bicgstab Solve_Initialize_BiCGStab interface~allocate_matrix Allocate_Matrix proc~solve_initialize_bicgstab->interface~allocate_matrix proc~duplicate_crs Duplicate_CRS proc~solve_initialize_bicgstab->proc~duplicate_crs proc~check_allocate_rank2_int32 Check_Allocate_rank2_int32 interface~allocate_matrix->proc~check_allocate_rank2_int32 proc~check_allocate_rank2_real64 Check_Allocate_rank2_real64 interface~allocate_matrix->proc~check_allocate_rank2_real64 proc~error_message error_message proc~check_allocate_rank2_int32->proc~error_message proc~check_allocate_rank2_real64->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~solve_initialize_bicgstab~~CalledByGraph proc~solve_initialize_bicgstab Solve_Initialize_BiCGStab interface~ils ILS interface~ils->proc~solve_initialize_bicgstab Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Solve_Initialize_BiCGStab Source Code type ( ILS ) function Solve_Initialize_BiCGStab ( Solver , MCRS ) implicit none type ( SolverInfo ), intent ( in ) :: Solver type ( CRS ), intent ( in ) :: MCRS call Allocate_Matrix ( work , Solver % N % node , 11 ) Solve_Initialize_BiCGStab % M => work (:, 1 ) Solve_Initialize_BiCGStab % p => work (:, 2 ) Solve_Initialize_BiCGStab % phat => work (:, 3 ) Solve_Initialize_BiCGStab % s => work (:, 4 ) Solve_Initialize_BiCGStab % shat => work (:, 5 ) Solve_Initialize_BiCGStab % r => work (:, 6 ) Solve_Initialize_BiCGStab % r0 => work (:, 7 ) Solve_Initialize_BiCGStab % t => work (:, 8 ) Solve_Initialize_BiCGStab % v => work (:, 9 ) Solve_Initialize_BiCGStab % x => work (:, 10 ) Solve_Initialize_BiCGStab % b => work (:, 11 ) call Duplicate_CRS ( MCRS , Solve_Initialize_BiCGStab % CRS_A ) end function Solve_Initialize_BiCGStab","tags":"","loc":"proc/solve_initialize_bicgstab.html"},{"title":"Solve_Initialize_LU – FTDSS","text":"private function Solve_Initialize_LU(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ) :: Solver Return Value type( DLS ) Called by proc~~solve_initialize_lu~~CalledByGraph proc~solve_initialize_lu Solve_Initialize_LU interface~dls DLS interface~dls->proc~solve_initialize_lu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Solve_Initialize_LU Source Code type ( DLS ) function Solve_Initialize_LU ( Solver ) implicit none type ( SolverInfo ) :: Solver Solve_Initialize_LU % N = Solver % N % node end function Solve_Initialize_LU","tags":"","loc":"proc/solve_initialize_lu.html"},{"title":"Solver_BiCGStab – FTDSS","text":"private subroutine Solver_BiCGStab(self, Solver, BiCG_A, BiCG_b, BiCG_x, status) Arguments Type Intent Optional Attributes Name class( ILS ) :: self type( SolverInfo ), intent(inout) :: Solver type( CRS ), intent(in) :: BiCG_A real(kind=real64), intent(in) :: BiCG_b (:) real(kind=real64), intent(inout) :: BiCG_x (:) integer(kind=int32), intent(inout) :: status Calls proc~~solver_bicgstab~~CallsGraph proc~solver_bicgstab Solver_BiCGStab proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~solver_bicgstab->proc~matrix_vector_product_crs proc~norm_2 norm_2 proc~solver_bicgstab->proc~norm_2 proc~create_precond_jacobi Create_Precond_Jacobi proc~solver_bicgstab->proc~create_precond_jacobi proc~ddots ddots proc~solver_bicgstab->proc~ddots proc~apply_precond_jacobi Apply_Precond_Jacobi proc~solver_bicgstab->proc~apply_precond_jacobi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Solver_BiCGStab Source Code subroutine Solver_BiCGStab ( self , Solver , BiCG_A , BiCG_b , BiCG_x , status ) implicit none class ( ILS ) :: self type ( SolverInfo ), intent ( inout ) :: Solver type ( CRS ), intent ( in ) :: BiCG_A real ( real64 ), intent ( in ) :: BiCG_b (:) real ( real64 ), intent ( inout ) :: BiCG_x (:) integer ( int32 ), intent ( inout ) :: status real ( real64 ) :: rho , rho_old , alpha , beta , omega real ( real64 ) :: tol , resid real ( real64 ) :: ddot , dnrm2 integer ( int32 ) :: maxiter , iter , N , iN ! 1:Initialize N = Solver % N % node tol = 1.0d-12 maxiter = N * 100 maxiter = 50000 self % CRS_A % Val (:) = BiCG_A % Val (:) self % b (:) = BiCG_b (:) rho = 1.0d0 rho_old = 1.0d0 alpha = 1.0d0 beta = 1.0d0 omega = 1.0d0 do iN = 1 , N self % p ( iN ) = 0.0d0 self % s ( iN ) = 0.0d0 self % phat ( iN ) = 0.0d0 self % shat ( iN ) = 0.0d0 end do ! 2: Set an initial value x0 self % x (:) = 0.0d0 ! 3: r0 = b-Ax0 call SpMV ( self % CRS_A , self % x , self % r ) do iN = 1 , N self % r ( iN ) = self % b ( iN ) - self % r ( iN ) end do ! 4: Create preconditioned matrix call Create_Precond_Jacobi ( N , self % CRS_A , self % M ) ! 5: &#94;r0 = r0, (r*0, r0)!=0 self % r0 (:) = self % r (:) do iter = 1 , maxiter , 1 ! 7: (&#94;r0, rk) rho = dot ( N , self % r , self % r0 ) ! rho = ddot(N, self%r, 1, self%r0, 1) ! 8: rho check if ( rho == 0.0d0 ) then status = 0 BiCG_x (:) = self % x (:) return end if if ( iter == 1 ) then ! 10: p0 = r0 self % p (:) = self % r (:) else ! 12: beta = (rho / rho_old) * (alpha_k / omega_k) beta = ( rho / rho_old ) * ( alpha / omega ) ! 13: p_k = r_k + beta_k(p_(k-1) - omega_k * Av) do iN = 1 , N self % p ( iN ) = self % r ( iN ) + beta * ( self % p ( iN ) - omega * self % v ( iN )) end do end if ! 15: phat = M&#94;-1 * p call Apply_Precond_Jacobi ( N , self % M , self % p , self % phat ) ! 16: v = A * phat call SpMV ( self % CRS_A , self % phat , self % v ) ! 17: alpha_k = rho / (&#94;r0, v) alpha = rho / dot ( N , self % r0 , self % v ) ! alpha = rho / ddot(N, self%r0, 1, self%v, 1) ! 18: s = r_k - alpha_k * v do iN = 1 , N self % s ( iN ) = self % r ( iN ) - alpha * self % v ( iN ) end do ! 19: shat = M&#94;-1 * s call Apply_Precond_Jacobi ( N , self % M , self % s , self % shat ) ! 20: t = A * shat call SpMV ( self % CRS_A , self % shat , self % t ) ! 21: omega_k = (t,s)/(t,t) omega = dot ( N , self % t , self % s ) / dot ( N , self % t , self % t ) ! omega = ddot(N, self%t, 1, self%s, 1) / ddot(N, self%t, 1, self%t, 1) ! 22: omega breakdown check if ( omega == 0.0d0 ) then status = - 1 return end if do iN = 1 , N ! 23: x(i) = x(i-1) + alpha * M&#94;-1 p(i-1) + omega * M&#94;-1 s(i) self % x ( iN ) = self % x ( iN ) + alpha * self % phat ( iN ) + omega * self % shat ( iN ) end do do iN = 1 , N ! 24: r(i) = s(i-1) - omega * AM&#94;-1 s(i-1) self % r ( iN ) = self % s ( iN ) - omega * self % t ( iN ) end do ! 25: ||r_k+1||_2 ! resid = dnrm2(N, self%r(:), 1) resid = norm ( N , self % r (:)) if ( resid < tol ) then status = 0 BiCG_x (:) = self % x (:) return end if rho_old = rho end do status = - 2 end subroutine Solver_BiCGStab","tags":"","loc":"proc/solver_bicgstab.html"},{"title":"Solver_Check_Error – FTDSS","text":"private subroutine Solver_Check_Error(self, ierr, time) Arguments Type Intent Optional Attributes Name class( ILS ) :: self integer(kind=int32), intent(in) :: ierr real(kind=real64), intent(in) :: time Contents Source Code Solver_Check_Error Source Code subroutine Solver_Check_Error ( self , ierr , time ) implicit none class ( ILS ) :: self integer ( int32 ), intent ( in ) :: ierr real ( real64 ), intent ( in ) :: time if ( ierr /= 0 ) then if ( ierr == - 1 ) then write ( * , '(a,es13.4,a)' ), \"BiCGStab:\" , time , \" Day: Temperature solver occures BREAKDOWN.\" else if ( ierr == - 2 ) then write ( * , '(a,es13.4,a)' ), \"BiCGStab:\" , time , \" Day: Temperature solver occures MAXITER.\" end if stop end if end subroutine Solver_Check_Error","tags":"","loc":"proc/solver_check_error.html"},{"title":"ILS_Destructor – FTDSS","text":"private subroutine ILS_Destructor(self) Arguments Type Intent Optional Attributes Name type( ILS ) :: self Contents Source Code ILS_Destructor Source Code subroutine ILS_Destructor ( self ) implicit none type ( ILS ) :: self ! ポインタコンポーネントをnullify nullify ( self % M ) nullify ( self % p ) nullify ( self % phat ) nullify ( self % s ) nullify ( self % shat ) nullify ( self % r ) nullify ( self % r0 ) nullify ( self % t ) nullify ( self % v ) nullify ( self % x ) nullify ( self % b ) ! CRS_Aのリソースを解放 if ( allocated ( self % CRS_A % Val )) deallocate ( self % CRS_A % Val ) if ( allocated ( self % CRS_A % Ind )) deallocate ( self % CRS_A % Ind ) if ( allocated ( self % CRS_A % Ptr )) deallocate ( self % CRS_A % Ptr ) end subroutine ILS_Destructor","tags":"","loc":"proc/ils_destructor.html"},{"title":"Solver_LU – FTDSS","text":"private subroutine Solver_LU(self, LU_A, LU_b, LU_x) Arguments Type Intent Optional Attributes Name class( DLS ) :: self real(kind=real64), intent(inout) :: LU_A (:,:) real(kind=real64), intent(inout) :: LU_b (:) real(kind=real64), intent(inout) :: LU_x (:) Calls proc~~solver_lu~~CallsGraph proc~solver_lu Solver_LU dgetrf dgetrf proc~solver_lu->dgetrf proc~error_message error_message proc~solver_lu->proc~error_message dgetrs dgetrs proc~solver_lu->dgetrs mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Solver_LU Source Code subroutine Solver_LU ( self , LU_A , LU_b , LU_x ) implicit none class ( DLS ) :: self real ( real64 ), intent ( inout ) :: LU_A (:,:), LU_b (:), LU_x (:) ! integer(int32), intent(in)    :: n integer ( int32 ) :: ipiv ( self % N ), info !* LU decomposition call Dgetrf ( self % N , self % N , LU_A , self % N , ipiv , info ) if ( info /= 0 ) call error_message ( 942 ) !* solve linear equation call Dgetrs ( 'N' , self % N , 1 , LU_A , self % N , ipiv , LU_b , self % N , info ) if ( info /= 0 ) call error_message ( 943 ) LU_x (:) = LU_b (:) end subroutine Solver_LU","tags":"","loc":"proc/solver_lu.html"},{"title":"ILS – FTDSS","text":"public interface ILS Calls interface~~ils~~CallsGraph interface~ils ILS proc~solve_initialize_bicgstab Solve_Initialize_BiCGStab interface~ils->proc~solve_initialize_bicgstab interface~allocate_matrix Allocate_Matrix proc~solve_initialize_bicgstab->interface~allocate_matrix proc~duplicate_crs Duplicate_CRS proc~solve_initialize_bicgstab->proc~duplicate_crs proc~check_allocate_rank2_int32 Check_Allocate_rank2_int32 interface~allocate_matrix->proc~check_allocate_rank2_int32 proc~check_allocate_rank2_real64 Check_Allocate_rank2_real64 interface~allocate_matrix->proc~check_allocate_rank2_real64 proc~error_message error_message proc~check_allocate_rank2_int32->proc~error_message proc~check_allocate_rank2_real64->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Solve_Initialize_BiCGStab Module Procedures private function Solve_Initialize_BiCGStab (Solver, MCRS) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(in) :: MCRS Return Value type( ILS )","tags":"","loc":"interface/ils.html"},{"title":"DLS – FTDSS","text":"public interface DLS Calls interface~~dls~~CallsGraph interface~dls DLS proc~solve_initialize_lu Solve_Initialize_LU interface~dls->proc~solve_initialize_lu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Solve_Initialize_LU Module Procedures private function Solve_Initialize_LU (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ) :: Solver Return Value type( DLS )","tags":"","loc":"interface/dls.html"},{"title":"has_nan_real64_scalar – FTDSS","text":"private function has_nan_real64_scalar(scalar) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar Return Value logical Called by proc~~has_nan_real64_scalar~~CalledByGraph proc~has_nan_real64_scalar has_nan_real64_scalar interface~has_nan has_nan interface~has_nan->proc~has_nan_real64_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code has_nan_real64_scalar Source Code logical function has_nan_real64_scalar ( scalar ) implicit none real ( real64 ), intent ( in ) :: scalar has_nan_real64_scalar = ieee_is_nan ( scalar ) end function has_nan_real64_scalar","tags":"","loc":"proc/has_nan_real64_scalar.html"},{"title":"has_nan_real64_rank1 – FTDSS","text":"private function has_nan_real64_rank1(array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Return Value logical Called by proc~~has_nan_real64_rank1~~CalledByGraph proc~has_nan_real64_rank1 has_nan_real64_rank1 interface~has_nan has_nan interface~has_nan->proc~has_nan_real64_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code has_nan_real64_rank1 Source Code logical function has_nan_real64_rank1 ( array ) implicit none real ( real64 ), intent ( in ) :: array (:) has_nan_real64_rank1 = any ( ieee_is_nan ( array )) end function has_nan_real64_rank1","tags":"","loc":"proc/has_nan_real64_rank1.html"},{"title":"has_nan_real64_rank2 – FTDSS","text":"private function has_nan_real64_rank2(array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:,:) Return Value logical Called by proc~~has_nan_real64_rank2~~CalledByGraph proc~has_nan_real64_rank2 has_nan_real64_rank2 interface~has_nan has_nan interface~has_nan->proc~has_nan_real64_rank2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code has_nan_real64_rank2 Source Code logical function has_nan_real64_rank2 ( array ) implicit none real ( real64 ), intent ( in ) :: array (:, :) has_nan_real64_rank2 = any ( ieee_is_nan ( array )) end function has_nan_real64_rank2","tags":"","loc":"proc/has_nan_real64_rank2.html"},{"title":"value_in_range_int32 – FTDSS","text":"private function value_in_range_int32(value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max Return Value logical Called by proc~~value_in_range_int32~~CalledByGraph proc~value_in_range_int32 value_in_range_int32 interface~value_in_range value_in_range interface~value_in_range->proc~value_in_range_int32 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code value_in_range_int32 Source Code function value_in_range_int32 ( value , min , max ) result ( in_range ) implicit none integer ( int32 ), intent ( in ) :: value , min , max logical :: in_range in_range = . true . if ( value < min . or . value > max ) then in_range = . false . end if end function value_in_range_int32","tags":"","loc":"proc/value_in_range_int32.html"},{"title":"value_in_range_real64 – FTDSS","text":"private function value_in_range_real64(value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: value real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max Return Value logical Called by proc~~value_in_range_real64~~CalledByGraph proc~value_in_range_real64 value_in_range_real64 interface~value_in_range value_in_range interface~value_in_range->proc~value_in_range_real64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code value_in_range_real64 Source Code function value_in_range_real64 ( value , min , max ) result ( in_range ) implicit none real ( real64 ), intent ( in ) :: value , min , max logical :: in_range in_range = . true . if ( value < min . or . value > max ) then in_range = . false . end if end function value_in_range_real64","tags":"","loc":"proc/value_in_range_real64.html"},{"title":"error_message – FTDSS","text":"public subroutine error_message(err_number, myrank, opt, opt_file_name, copt1, copt2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: err_number integer(kind=int32), intent(in), optional :: myrank real(kind=real64), intent(in), optional :: opt character, intent(in), optional :: opt_file_name character, intent(in), optional :: copt1 character, intent(in), optional :: copt2 Calls proc~~error_message~~CallsGraph proc~error_message error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~error_message~~CalledByGraph proc~error_message error_message proc~check_allocate_rank2_real64 Check_Allocate_rank2_real64 proc~check_allocate_rank2_real64->proc~error_message proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 proc~check_allocate_rank1_real64->proc~error_message proc~inout_output_all_vtk Inout_Output_All_vtk proc~inout_output_all_vtk->proc~error_message proc~set_point_31 Set_Point_31 proc~set_point_31->proc~error_message proc~calc_area_31 Calc_Area_31 proc~calc_area_31->proc~error_message interface~set_point Set_Point proc~calc_area_31->interface~set_point proc~calc_shape_31 Calc_Shape_31 proc~calc_shape_31->proc~error_message proc~calc_shape_31->interface~set_point proc~check_allocate_pointer_real64 Check_Allocate_Pointer_real64 proc~check_allocate_pointer_real64->proc~error_message proc~check_allocate_rank2_int32 Check_Allocate_rank2_int32 proc~check_allocate_rank2_int32->proc~error_message proc~check_allocate_rank1_logical Check_Allocate_rank1_logical proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 proc~check_allocate_rank1_int32->proc~error_message proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify proc~check_allocate_rank1_real64_specify->proc~error_message proc~inout_setprojectpath_setprojectpath Inout_SetProjectPath_SetProjectPath proc~inout_setprojectpath_setprojectpath->proc~error_message proc~inout_output_all_dat Inout_Output_All_Dat proc~inout_output_all_dat->proc~error_message proc~solver_lu Solver_LU proc~solver_lu->proc~error_message proc~check_allocate_pointer_int32 Check_Allocate_Pointer_int32 proc~check_allocate_pointer_int32->proc~error_message proc~inout_output_all Inout_Output_All proc~inout_output_all->proc~inout_output_all_vtk proc~inout_output_all->proc~inout_output_all_dat interface~set_point->proc~set_point_31 interface~allocate_pointer Allocate_Pointer interface~allocate_pointer->proc~check_allocate_pointer_real64 interface~allocate_pointer->proc~check_allocate_pointer_int32 interface~allocate_matrix Allocate_Matrix interface~allocate_matrix->proc~check_allocate_rank2_real64 interface~allocate_matrix->proc~check_allocate_rank2_int32 interface~calc_area Calc_Area interface~calc_area->proc~calc_area_31 interface~allocate_vector Allocate_Vector interface~allocate_vector->proc~check_allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_real64_specify interface~calc_shape Calc_Shape interface~calc_shape->proc~calc_shape_31 proc~inout_setprojectpath_getprojectpath Inout_SetProjectPath_GetProjectPath proc~inout_setprojectpath_getprojectpath->proc~inout_setprojectpath_setprojectpath proc~initialize_solver Initialize_Solver proc~initialize_solver->interface~allocate_pointer proc~solve_initialize_bicgstab Solve_Initialize_BiCGStab proc~solve_initialize_bicgstab->interface~allocate_matrix proc~output_constructor Output_Constructor proc~output_constructor->interface~allocate_vector proc~output_constructor->proc~inout_setprojectpath_getprojectpath proc~allocate_dp2d Allocate_DP2d proc~allocate_dp2d->interface~allocate_vector proc~allocate_bcinfo Allocate_BCinfo proc~allocate_bcinfo->interface~allocate_vector proc~allocate_int2d Allocate_INT2d proc~allocate_bcinfo->proc~allocate_int2d proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~set_point proc~set_obs_coo_31->interface~allocate_matrix proc~set_obs_coo_31->interface~allocate_vector proc~calc_gm_time_trm_f Calc_GM_Time_TRM_F proc~calc_gm_time_trm_f->interface~allocate_matrix proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_matrix proc~allocate_solver->interface~allocate_vector proc~allocate_solver->proc~allocate_dp2d proc~allocate_df Allocate_DF proc~allocate_solver->proc~allocate_df proc~convert_crs Convert_CRS proc~convert_crs->interface~allocate_vector proc~allocate_df->interface~allocate_vector proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->interface~allocate_vector proc~allocate_int2d->interface~allocate_vector interface~ils ILS interface~ils->proc~solve_initialize_bicgstab proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 interface~output Output interface~output->proc~output_constructor interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code error_message Source Code subroutine error_message ( err_number , myrank , opt , opt_file_name , copt1 , copt2 ) implicit none integer ( int32 ), intent ( in ) :: err_number real ( real64 ), optional , intent ( in ) :: opt integer ( int32 ), optional , intent ( in ) :: myrank character ( 256 ) :: msg character ( * ), optional , intent ( in ) :: opt_file_name , copt1 , copt2 integer ( int32 ) :: ierr if ( err_number == 901 ) then write ( msg , '(3a)' ) \"Error: Does not exit file '\" , trim ( adjustl ( opt_file_name )), \"'.\" else if ( err_number == 902 ) then write ( msg , '(3a)' ) \"Error: Can not open file '\" , trim ( adjustl ( opt_file_name )), \"'.\" else if ( err_number == 903 ) then write ( msg , '(3a)' ) \"Error: Selected \" , trim ( adjustl ( copt1 )), \" number is invalid.\" else if ( err_number == 904 ) then msg = \"Error: Opening file 'coordinate.in'\" else if ( err_number == 905 ) then msg = \"Error: Opening file 'top.in'\" else if ( err_number == 906 ) then msg = \"Error: Opening file 'coordinate.in'\" else if ( err_number == 911 ) then msg = \"Error: The number of elements must be positive.\" else if ( err_number == 912 ) then msg = \"Error: The number of nodal must be positive.\" else if ( err_number == 913 ) then msg = \"Error: The number of shape must be positive.\" else if ( err_number == 914 ) then msg = \"Error: The number of dimention must be positive.\" else if ( err_number == 915 ) then msg = \"Error: Dirichlet boundary conditions for water transport must be positive.\" else if ( err_number == 916 ) then msg = \"Error: Dirichlet boundary conditions for heat transport must be positive.\" else if ( err_number == 917 ) then msg = \"Error: The value of porosity must be positive.\" else if ( err_number == 918 ) then msg = \"Error: The value of density must be positive.\" else if ( err_number == 919 ) then msg = \"Error: The value of hydrulic conductivity must be positive.\" else if ( err_number == 920 ) then msg = \"Error: The value of thermal conductivity must be positive.\" else if ( err_number == 921 ) then msg = \"Error: The value of specific heat must be positive.\" else if ( err_number == 922 ) then msg = \"Error: The value of latent heat must be positive.\" else if ( err_number == 923 ) then msg = \"Error: The number of concering time information must be positive.\" else if ( err_number == 924 ) then msg = \"Error: The initial and coolant temperature are same.\" else if ( err_number == 928 ) then msg = \"Error: Two or more points are the same.\" else if ( err_number == 929 ) then msg = \"Error: The number of array elements must be positive.\" else if ( err_number == 930 ) then msg = \"Error: The number of matrix elements must be positive.\" else if ( err_number == 931 ) then msg = \"Error: opening output file\" else if ( err_number == 932 ) then msg = \"Error: Invalid element index\" else if ( err_number == 933 ) then msg = \"Error: Solver type is not selected.\" else if ( err_number == 934 ) then msg = \"Error: Freezing calculation is not selected.\" else if ( err_number == 941 ) then msg = \"Error: The solution to the simultaneous linear equations could not be found.\" else if ( err_number == 942 ) then msg = \"Error: LU decomposition could not be successed.\" else if ( err_number == 943 ) then msg = \"Error: The inverse matrix could not be found.\" else if ( err_number == 944 ) then msg = \"Error: The target result is too high.\" else if ( err_number == 945 ) then msg = \"Error: The target result is too low.\" else if ( err_number == 946 ) then msg = \"Error: The solution has been diverged.\" else if ( err_number == 951 ) then write ( msg , '(a)' ) \"Error: The number of vector elements must be positive.\" else if ( err_number == 952 ) then write ( msg , '(a)' ) \"Error: The number of matrix elements must be positive.\" else if ( err_number == 953 ) then write ( msg , '(a)' ) \"Error: Vector has already allocated.\" else if ( err_number == 954 ) then write ( msg , '(a)' ) \"Error: Matrix has already allocated.\" else if ( err_number == 955 ) then write ( msg , '(a)' ) \"Error: Pointer has already allocated.\" else msg = \"Error: Unknown error\" end if #ifdef _MPI if ( myrank == 0 ) then call MPI_Finalize ( ierr ) #endif write ( * , '(a)' ) msg stop #ifdef _MPI end if #endif end subroutine error_message","tags":"","loc":"proc/error_message.html"},{"title":"has_nan – FTDSS","text":"public interface has_nan Calls interface~~has_nan~~CallsGraph interface~has_nan has_nan proc~has_nan_real64_scalar has_nan_real64_scalar interface~has_nan->proc~has_nan_real64_scalar proc~has_nan_real64_rank2 has_nan_real64_rank2 interface~has_nan->proc~has_nan_real64_rank2 proc~has_nan_real64_rank1 has_nan_real64_rank1 interface~has_nan->proc~has_nan_real64_rank1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures has_nan_real64_scalar has_nan_real64_rank1 has_nan_real64_rank2 Module Procedures private function has_nan_real64_scalar (scalar) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar Return Value logical private function has_nan_real64_rank1 (array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Return Value logical private function has_nan_real64_rank2 (array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:,:) Return Value logical","tags":"","loc":"interface/has_nan.html"},{"title":"value_in_range – FTDSS","text":"public interface value_in_range Calls interface~~value_in_range~~CallsGraph interface~value_in_range value_in_range proc~value_in_range_int32 value_in_range_int32 interface~value_in_range->proc~value_in_range_int32 proc~value_in_range_real64 value_in_range_real64 interface~value_in_range->proc~value_in_range_real64 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures value_in_range_int32 value_in_range_real64 Module Procedures private function value_in_range_int32 (value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max Return Value logical private function value_in_range_real64 (value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: value real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max Return Value logical","tags":"","loc":"interface/value_in_range.html"},{"title":"Create_Precond_Jacobi – FTDSS","text":"public subroutine Create_Precond_Jacobi(N, A, M) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N type( CRS ), intent(in) :: A real(kind=real64), intent(inout) :: M (:) Called by proc~~create_precond_jacobi~~CalledByGraph proc~create_precond_jacobi Create_Precond_Jacobi proc~solver_bicgstab Solver_BiCGStab proc~solver_bicgstab->proc~create_precond_jacobi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Create_Precond_Jacobi Source Code subroutine Create_Precond_Jacobi ( N , A , M ) implicit none integer ( int32 ), intent ( in ) :: N type ( CRS ), intent ( in ) :: A real ( real64 ), intent ( inout ) :: M (:) integer ( int32 ) :: i , j M (:) = 0.0d0 !$omp parallel do private(i, j) do i = 1 , N do j = A % Ptr ( i - 1 ), A % Ptr ( i ) - 1 if (( i - 1 ) == A % Ind ( j )) then M ( i ) = 1.0d0 / A % Val ( j ) end if end do end do !$omp end parallel do end subroutine Create_Precond_Jacobi","tags":"","loc":"proc/create_precond_jacobi.html"},{"title":"Apply_Precond_Jacobi – FTDSS","text":"public subroutine Apply_Precond_Jacobi(N, M, r, z) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: M (:) real(kind=real64), intent(in) :: r (:) real(kind=real64), intent(inout) :: z (:) Called by proc~~apply_precond_jacobi~~CalledByGraph proc~apply_precond_jacobi Apply_Precond_Jacobi proc~solver_bicgstab Solver_BiCGStab proc~solver_bicgstab->proc~apply_precond_jacobi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Apply_Precond_Jacobi Source Code subroutine Apply_Precond_Jacobi ( N , M , r , z ) implicit none integer ( int32 ), intent ( in ) :: N real ( real64 ), intent ( in ) :: M (:) real ( real64 ), intent ( in ) :: r (:) real ( real64 ), intent ( inout ) :: z (:) integer ( int32 ) :: i ! $omp parallel do private(i) do i = 1 , N z ( i ) = M ( i ) * r ( i ) end do ! $omp end parallel do end subroutine Apply_Precond_Jacobi","tags":"","loc":"proc/apply_precond_jacobi.html"},{"title":"Init_Copy_Temperature – FTDSS","text":"public subroutine Init_Copy_Temperature(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents Source Code Init_Copy_Temperature Source Code subroutine Init_Copy_Temperature ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver Solver % T % old (:) = Solver % T % pre (:) Solver % Si % old (:) = Solver % Si % pre (:) Solver % mWater % old (:) = Solver % mWater % pre (:) Solver % mIce % old (:) = Solver % mIce % pre (:) Solver % Heat % Variables % Ca % old (:) = Solver % Heat % Variables % Ca % pre (:) end subroutine Init_Copy_Temperature","tags":"","loc":"proc/init_copy_temperature.html"},{"title":"Init_Copy_Pressure – FTDSS","text":"public subroutine Init_Copy_Pressure(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents Source Code Init_Copy_Pressure Source Code subroutine Init_Copy_Pressure ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver Solver % P % old (:) = Solver % P % pre (:) Solver % Water % Variables % Klh % old (:) = Solver % Water % Variables % Klh % pre (:) end subroutine Init_Copy_Pressure","tags":"","loc":"proc/init_copy_pressure.html"},{"title":"Convert_TimeUnit – FTDSS","text":"private function Convert_TimeUnit(Time, num) result(conv_time) Arguments Type Intent Optional Attributes Name type( TimeInfo ), intent(in) :: Time integer(kind=int32), intent(in) :: num Return Value real(kind=real64) Called by proc~~convert_timeunit~~CalledByGraph proc~convert_timeunit Convert_TimeUnit proc~initialize_solver Initialize_Solver proc~initialize_solver->proc~convert_timeunit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Convert_TimeUnit Source Code function Convert_TimeUnit ( Time , num ) result ( conv_time ) implicit none type ( TimeInfo ), intent ( in ) :: Time integer ( int32 ), intent ( in ) :: num real ( real64 ) :: conv_time if ( Time % tUnit ( num : num ) == \"1\" ) then conv_time = 1.0d0 else if ( Time % tUnit ( num : num ) == \"2\" ) then conv_time = 6 0.d0 else if ( Time % tUnit ( num : num ) == \"3\" ) then conv_time = 6 0.d0 * 6 0.d0 else if ( Time % tUnit ( num : num ) == \"4\" ) then conv_time = 6 0.d0 * 6 0.d0 * 2 4.0d0 else if ( Time % tUnit ( num : num ) == \"5\" ) then conv_time = 6 0.d0 * 6 0.d0 * 2 4.0d0 * 3 0.d0 else if ( Time % tUnit ( num : num ) == \"6\" ) then conv_time = 6 0.d0 * 6 0.d0 * 2 4.0d0 * 36 5.0d0 end if end function Convert_TimeUnit","tags":"","loc":"proc/convert_timeunit.html"},{"title":"Initialize_Solver – FTDSS","text":"public subroutine Initialize_Solver(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~initialize_solver~~CallsGraph proc~initialize_solver Initialize_Solver interface~allocate_pointer Allocate_Pointer proc~initialize_solver->interface~allocate_pointer proc~convert_timeunit Convert_TimeUnit proc~initialize_solver->proc~convert_timeunit proc~find_ca_max Find_Ca_max proc~initialize_solver->proc~find_ca_max proc~check_allocate_pointer_real64 Check_Allocate_Pointer_real64 interface~allocate_pointer->proc~check_allocate_pointer_real64 proc~check_allocate_pointer_int32 Check_Allocate_Pointer_int32 interface~allocate_pointer->proc~check_allocate_pointer_int32 proc~calc_ca_gcc Calc_Ca_GCC proc~find_ca_max->proc~calc_ca_gcc proc~error_message error_message proc~check_allocate_pointer_real64->proc~error_message proc~check_allocate_pointer_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Initialize_Solver Source Code subroutine Initialize_Solver ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: i call Allocate_Pointer ( Solver % Time % tst ) call Allocate_Pointer ( Solver % Time % dt ) call Allocate_Pointer ( Solver % Time % odt ) ! Time settings converting to seconds Solver % Time % ts = 0.0d0 Solver % Time % tst = 0.0d0 Solver % Time % te = Solver % Time % cTime * Convert_TimeUnit ( Solver % Time , 1 ) Solver % Time % dt = Solver % Time % cdt * Convert_TimeUnit ( Solver % Time , 2 ) Solver % Time % odt = Solver % Time % dt Solver % Time % max_dt = 1.0d-8 Solver % Time % min_dt = 30 0.0d0 Solver % Time % tconv = 1.0d0 / Convert_TimeUnit ( Solver % Time , 1 ) call Allocate_Pointer ( Solver % Iter % iter ) call Allocate_Pointer ( Solver % Iter % titer ) call Allocate_Pointer ( Solver % Iter % iNL ) ! Iteration settings Solver % Iter % iter = 1 Solver % Iter % itermax = nint ( Solver % Time % te / Solver % Time % cinterval ) Solver % Iter % titer = 1 Solver % Iter % iNL = 1 Solver % Iter % iNLmax = 50 Solver % Iter % iNI = 1 Solver % Iter % digits_itermax = int ( log10 ( dble ( Solver % Iter % itermax ))) + 1 ! Output format settings write ( Solver % fmt_Stdout , '(a,i0,a,i0,a)' ), & '(a,i' , Solver % Iter % digits_itermax , ',a,i' , Solver % Iter % digits_itermax , ',a,f9.4,a,f11.4,a)' write ( Solver % fmt_Fileout , '(a,i0,a,i0,a)' ), & '(2a,i' , Solver % Iter % digits_itermax , '.' , Solver % Iter % digits_itermax , ',a)' Solver % Heat % Latent % Cp_unf = Solver % Heat % Constants % HeatCapacity % soil * ( 1.0d0 - Solver % Heat % Constants % Porosity ) & + Solver % Heat % Constants % HeatCapacity % water * Solver % Heat % Constants % Porosity ! Find the maximum value of Ca call Find_Ca_max ( Solver % Heat ) if ( Solver % BC % numEdges > 0 ) then do i = 1 , Solver % BC % numEdges ! print*,(Solver%N%vCood%x(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%x(Solver%BC%Heat%Edges%x(i))),(Solver%N%vCood%y(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%y(Solver%BC%Heat%Edges%x(i))) Solver % BC % Heat % EdgesDistance ( i ) = sqrt (( Solver % N % vCood % x ( Solver % BC % Heat % Edges % y ( i )) - Solver % N % vCood % x ( Solver % BC % Heat % Edges % x ( i ))) ** 2.0d0 + ( Solver % N % vCood % y ( Solver % BC % Heat % Edges % y ( i )) - Solver % N % vCood % y ( Solver % BC % Heat % Edges % x ( i ))) ** 2.0d0 ) end do end if end subroutine Initialize_Solver","tags":"","loc":"proc/initialize_solver.html"},{"title":"Binary_finding – FTDSS","text":"public subroutine Binary_finding(Solver, ind) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: ind Calls proc~~binary_finding~~CallsGraph proc~binary_finding Binary_finding proc~calc_latentheatterm Calc_LatentHeatTerm proc~binary_finding->proc~calc_latentheatterm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~binary_finding~~CalledByGraph proc~binary_finding Binary_finding proc~update_phase_revise Update_Phase_Revise proc~update_phase_revise->proc~binary_finding Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Binary_finding Source Code subroutine Binary_finding ( Solver , ind ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: ind real ( real64 ) :: Tnew real ( real64 ) :: x0 , x1 , x2 , f0 , f1 , err integer ( int32 ) :: i x0 = 0.0d0 x1 = Solver % T % new ( ind ) Tnew = Solver % T % new ( ind ) do i = 1 , max_iter f0 = Calc_LatentHeatTerm ( x0 , Tnew , Solver % Heat % Latent ) f1 = Calc_LatentHeatTerm ( x1 , Tnew , Solver % Heat % Latent ) if ( f0 * f1 > 0.0d0 ) then write ( * , \"(a)\" ), \"Binary_finding_Power: f0 * f1 > 0\" stop end if x2 = ( x0 + x1 ) / 2.0d0 if ( f0 * Calc_LatentHeatTerm ( x2 , Tnew , Solver % Heat % Latent ) < 0.0d0 ) then x1 = x2 else x0 = x2 end if if ( abs ( x1 - x0 ) < eps ) exit end do if ( i >= max_iter ) then if ( Solver % Flags % isGCC ) then write ( * , \"(a)\" ), \"Binary_finding_GCC: iteration limit exceeded\" else if ( Solver % Flags % isPower ) then write ( * , \"(a)\" ), \"Binary_finding_Power: iteration limit exceeded\" end if stop end if Solver % T % new ( ind ) = x2 end subroutine Binary_finding","tags":"","loc":"proc/binary_finding.html"},{"title":"Secant_method – FTDSS","text":"public subroutine Secant_method(Solver, ind) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: ind Calls proc~~secant_method~~CallsGraph proc~secant_method Secant_method proc~calc_latentheatterm Calc_LatentHeatTerm proc~secant_method->proc~calc_latentheatterm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Secant_method Source Code subroutine Secant_method ( Solver , ind ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: ind real ( real64 ) :: Tnew real ( real64 ) :: x0 , x1 , x2 , f0 , f1 , err integer ( int32 ) :: i x0 = 0.0d0 x1 = Solver % T % new ( ind ) Tnew = Solver % T % new ( ind ) do i = 1 , max_iter f0 = Calc_LatentHeatTerm ( x0 , Tnew , Solver % Heat % Latent ) f1 = Calc_LatentHeatTerm ( x1 , Tnew , Solver % Heat % Latent ) if ( abs ( f1 - f0 ) < epsilon ( 1.0d0 )) then stop else err = f1 * ( x1 - x0 ) / ( f1 - f0 ) x2 = x1 - err if ( abs ( err ) < eps ) exit x0 = x1 x1 = x2 end if end do if ( i >= max_iter ) then if ( Solver % Flags % isGCC ) then write ( * , \"(a)\" ), \"Secant_method_GCC: iteration limit exceeded\" else if ( Solver % Flags % isPower ) then write ( * , \"(a)\" ), \"Secant_method_Power: iteration limit exceeded\" end if stop end if if ( ieee_is_nan ( x2 )) x2 = 0.0d0 Solver % T % new ( ind ) = x2 end subroutine Secant_method","tags":"","loc":"proc/secant_method.html"},{"title":"Allocate_DF – FTDSS","text":"public subroutine Allocate_DF(ar_DF, n) Arguments Type Intent Optional Attributes Name type( DF ), intent(inout) :: ar_DF integer(kind=int32), intent(in) :: n Calls proc~~allocate_df~~CallsGraph proc~allocate_df Allocate_DF interface~allocate_vector Allocate_Vector proc~allocate_df->interface~allocate_vector proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~error_message error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_df~~CalledByGraph proc~allocate_df Allocate_DF proc~allocate_solver Allocate_Solver proc~allocate_solver->proc~allocate_df Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Allocate_DF Source Code subroutine Allocate_DF ( ar_DF , n ) implicit none type ( DF ), intent ( inout ) :: ar_DF integer ( int32 ), intent ( in ) :: n call Allocate_Vector ( ar_DF % old , n ) call Allocate_Vector ( ar_DF % pre , n ) call Allocate_Vector ( ar_DF % new , n ) call Allocate_Vector ( ar_DF % dif , n ) call Allocate_Vector ( ar_DF % div , n ) call Allocate_Vector ( ar_DF % tmp , n ) end subroutine Allocate_DF","tags":"","loc":"proc/allocate_df.html"},{"title":"Allocate_DP2d – FTDSS","text":"public subroutine Allocate_DP2d(ar_DP2d, n) Arguments Type Intent Optional Attributes Name type( DP2d ), intent(inout) :: ar_DP2d integer(kind=int32), intent(in) :: n Calls proc~~allocate_dp2d~~CallsGraph proc~allocate_dp2d Allocate_DP2d interface~allocate_vector Allocate_Vector proc~allocate_dp2d->interface~allocate_vector proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~error_message error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_dp2d~~CalledByGraph proc~allocate_dp2d Allocate_DP2d proc~allocate_solver Allocate_Solver proc~allocate_solver->proc~allocate_dp2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Allocate_DP2d Source Code subroutine Allocate_DP2d ( ar_DP2d , n ) implicit none type ( DP2d ), intent ( inout ) :: ar_DP2d integer ( int32 ), intent ( in ) :: n call Allocate_Vector ( ar_DP2d % x , n ) call Allocate_Vector ( ar_DP2d % y , n ) end subroutine Allocate_DP2d","tags":"","loc":"proc/allocate_dp2d.html"},{"title":"Allocate_INT2d – FTDSS","text":"private subroutine Allocate_INT2d(ar_INT2d, n) Arguments Type Intent Optional Attributes Name type( INT2d ), intent(inout) :: ar_INT2d integer(kind=int32), intent(in) :: n Calls proc~~allocate_int2d~~CallsGraph proc~allocate_int2d Allocate_INT2d interface~allocate_vector Allocate_Vector proc~allocate_int2d->interface~allocate_vector proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~error_message error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_int2d~~CalledByGraph proc~allocate_int2d Allocate_INT2d proc~allocate_bcinfo Allocate_BCinfo proc~allocate_bcinfo->proc~allocate_int2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Allocate_INT2d Source Code subroutine Allocate_INT2d ( ar_INT2d , n ) implicit none type ( INT2d ), intent ( inout ) :: ar_INT2d integer ( int32 ), intent ( in ) :: n call Allocate_Vector ( ar_INT2d % x , n ) call Allocate_Vector ( ar_INT2d % y , n ) end subroutine Allocate_INT2d","tags":"","loc":"proc/allocate_int2d.html"},{"title":"Allocate_BCinfo – FTDSS","text":"public subroutine Allocate_BCinfo(BCinfo, nNode, nType, nEdge) Arguments Type Intent Optional Attributes Name type( BoudaryConditionInfo ), intent(inout) :: BCinfo integer(kind=int32), intent(in) :: nNode integer(kind=int32), intent(in) :: nType integer(kind=int32), intent(in), optional :: nEdge Calls proc~~allocate_bcinfo~~CallsGraph proc~allocate_bcinfo Allocate_BCinfo interface~allocate_vector Allocate_Vector proc~allocate_bcinfo->interface~allocate_vector proc~allocate_int2d Allocate_INT2d proc~allocate_bcinfo->proc~allocate_int2d proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~allocate_int2d->interface~allocate_vector proc~error_message error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Allocate_BCinfo Source Code subroutine Allocate_BCinfo ( BCinfo , nNode , nType , nEdge ) implicit none type ( BoudaryConditionInfo ), intent ( inout ) :: BCinfo integer ( int32 ), intent ( in ) :: nNode , nType integer ( int32 ), intent ( in ), optional :: nEdge call Allocate_Vector ( BCinfo % Node , nNode ) call Allocate_Vector ( BCinfo % TypeKey , nNode ) call Allocate_Vector ( BCinfo % type , nType ) call Allocate_Vector ( BCinfo % value , nType ) if ( present ( nEdge )) then ! print*, nEdge call Allocate_INT2d ( BCinfo % Edges , nEdge ) call Allocate_Vector ( BCinfo % EdgesDirection , nEdge ) call Allocate_Vector ( BCinfo % EdgesDistance , nEdge ) end if end subroutine Allocate_BCinfo","tags":"","loc":"proc/allocate_bcinfo.html"},{"title":"Allocate_Solver – FTDSS","text":"public subroutine Allocate_Solver(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~allocate_solver~~CallsGraph proc~allocate_solver Allocate_Solver interface~allocate_matrix Allocate_Matrix proc~allocate_solver->interface~allocate_matrix proc~allocate_df Allocate_DF proc~allocate_solver->proc~allocate_df interface~allocate_vector Allocate_Vector proc~allocate_solver->interface~allocate_vector proc~allocate_dp2d Allocate_DP2d proc~allocate_solver->proc~allocate_dp2d proc~check_allocate_rank2_real64 Check_Allocate_rank2_real64 interface~allocate_matrix->proc~check_allocate_rank2_real64 proc~check_allocate_rank2_int32 Check_Allocate_rank2_int32 interface~allocate_matrix->proc~check_allocate_rank2_int32 proc~allocate_df->interface~allocate_vector proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~allocate_dp2d->interface~allocate_vector proc~error_message error_message proc~check_allocate_rank2_real64->proc~error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank2_int32->proc~error_message proc~check_allocate_rank1_int32->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Allocate_Solver Source Code subroutine Allocate_Solver ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver !* Allocate Geometry2d call Allocate_Matrix ( Solver % N % pElement , Solver % N % shape , Solver % N % element ) call Allocate_Vector ( Solver % N % vCood % x , Solver % N % node ) call Allocate_Vector ( Solver % N % vCood % y , Solver % N % node ) call Allocate_Vector ( Solver % N % eArea , Solver % N % element ) call Allocate_Matrix ( Solver % N % Basis % a , Solver % N % ShCoe , Solver % N % element ) call Allocate_Matrix ( Solver % N % Basis % b , Solver % N % ShCoe , Solver % N % element ) call Allocate_Matrix ( Solver % N % Basis % c , Solver % N % ShCoe , Solver % N % element ) if ( Solver % N % ShCoe == 4 ) call Allocate_Matrix ( Solver % N % Basis % d , Solver % N % ShCoe , Solver % N % element ) call Allocate_Vector ( Solver % mWater % old , Solver % N % node ) call Allocate_Vector ( Solver % mWater % pre , Solver % N % node ) call Allocate_Vector ( Solver % mIce % old , Solver % N % node ) call Allocate_Vector ( Solver % mIce % pre , Solver % N % node ) call Allocate_Vector ( Solver % mIce % dif , Solver % N % node ) call Allocate_DF ( Solver % Si , Solver % N % node ) if ( Solver % isHeat ) then call Allocate_DF ( Solver % Heat % Variables % Cs , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % Cp , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % lambda , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % rho , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % Ca , Solver % N % node ) call Allocate_DF ( Solver % T , Solver % N % node ) call Allocate_Vector ( Solver % Heat % Rhs , Solver % N % node ) call Allocate_Vector ( Solver % Heat % Variables % Phase , Solver % N % node ) call Allocate_Matrix ( Solver % Heat % RA , Solver % N % node , Solver % N % node ) call Allocate_DP2d ( Solver % Heat % Variables % Tgrad , Solver % N % node ) call Allocate_DP2d ( Solver % Heat % Variables % TFlux , Solver % N % node ) end if if ( Solver % isWater ) then call Allocate_DF ( Solver % Water % Variables % Klh , Solver % N % node ) call Allocate_DP2d ( Solver % Water % Variables % wFlux , Solver % N % node ) call Allocate_DP2d ( Solver % Water % Variables % hGrad , Solver % N % node ) call Allocate_DF ( Solver % P , Solver % N % node ) call Allocate_Vector ( Solver % Water % Rhs , Solver % N % node ) call Allocate_Matrix ( Solver % Water % RA , Solver % N % node , Solver % N % node ) end if end subroutine Allocate_Solver","tags":"","loc":"proc/allocate_solver.html"},{"title":"Allocate_Structure_Thermal_Type – FTDSS","text":"public subroutine Allocate_Structure_Thermal_Type(Structure_Thermal, Flags) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal type( Type_Region_Flags ), intent(in) :: Flags Contents Source Code Allocate_Structure_Thermal_Type Source Code subroutine Allocate_Structure_Thermal_Type ( Structure_Thermal , Flags ) ! Allocate thermal structure type implicit none type ( Type_Thermal ), intent ( inout ) :: Structure_Thermal ! Thermal structure type ( Type_Region_Flags ), intent ( in ) :: Flags ! Region flags if ( allocated ( Structure_Thermal % Density )) deallocate ( Structure_Thermal % Density ) if ( allocated ( Structure_Thermal % SpecificHeat )) deallocate ( Structure_Thermal % SpecificHeat ) if ( allocated ( Structure_Thermal % ThermalConductivity )) deallocate ( Structure_Thermal % ThermalConductivity ) if ( Flags % is1Phase ) then allocate ( Type_Density_1Phase :: Structure_Thermal % Density ) allocate ( Type_SpecificHeat_1Phase :: Structure_Thermal % SpecificHeat ) allocate ( Type_ThermalConductivity_1Phase :: Structure_Thermal % ThermalConductivity ) else if ( Flags % is2Phase ) then allocate ( Type_Density_2Phase :: Structure_Thermal % Density ) allocate ( Type_SpecificHeat_2Phase :: Structure_Thermal % SpecificHeat ) allocate ( Type_ThermalConductivity_2Phase :: Structure_Thermal % ThermalConductivity ) else if ( Flags % is3Phase ) then allocate ( Type_Density_3Phase :: Structure_Thermal % Density ) allocate ( Type_SpecificHeat_3Phase :: Structure_Thermal % SpecificHeat ) if ( Flags % isDispersity ) then allocate ( Type_ThermalConductivity_3Phase_Dispersity_2D :: Structure_Thermal % ThermalConductivity ) ! allocate (Type_ThermalConductivity_3Phase_Dispersity_3D :: Structure_Thermal%ThermalConductivity) else allocate ( Type_ThermalConductivity_3Phase :: Structure_Thermal % ThermalConductivity ) end if end if end subroutine Allocate_Structure_Thermal_Type","tags":"","loc":"proc/allocate_structure_thermal_type.html"},{"title":"Allocate_Structure_Ice_Type – FTDSS","text":"public subroutine Allocate_Structure_Ice_Type(Structure_Thermal, QiceModelType) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal integer(kind=int32), intent(in) :: QiceModelType Contents Source Code Allocate_Structure_Ice_Type Source Code subroutine Allocate_Structure_Ice_Type ( Structure_Thermal , QiceModelType ) ! Allocate ice model type implicit none type ( Type_Thermal ), intent ( inout ) :: Structure_Thermal ! Thermal structure integer ( int32 ), intent ( in ) :: QiceModelType ! Ice model type if ( allocated ( Structure_Thermal % Ice )) deallocate ( Structure_Thermal % Ice ) if ( QiceModelType == 1 ) then allocate ( Type_Ice_TRM :: Structure_Thermal % Ice ) else if ( QiceModelType == 2 ) then allocate ( Type_Ice_GCC :: Structure_Thermal % Ice ) else if ( QiceModelType == 3 ) then allocate ( Type_Ice_EXP :: Structure_Thermal % Ice ) end if end subroutine Allocate_Structure_Ice_Type","tags":"","loc":"proc/allocate_structure_ice_type.html"},{"title":"Allocate_Structure_WRF_Type – FTDSS","text":"public subroutine Allocate_Structure_WRF_Type(Structure_Thermal, WRFModelType) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal integer(kind=int32), intent(in) :: WRFModelType Contents Source Code Allocate_Structure_WRF_Type Source Code subroutine Allocate_Structure_WRF_Type ( Structure_Thermal , WRFModelType ) ! Allocate WRF model type implicit none type ( Type_Thermal ), intent ( inout ) :: Structure_Thermal ! Thermal structure integer ( int32 ), intent ( in ) :: WRFModelType ! WRF model type if (. not . allocated ( Structure_Thermal % Ice )) then print * , \"Error: Ice structure is not allocated.\" return end if select type ( Ice => Structure_Thermal % Ice ) type is ( Type_Ice_GCC ) select case ( WRFModelType ) case ( 1 ) allocate ( Type_WRF_BC :: Ice % WRF ) case ( 2 ) allocate ( Type_WRF_VG :: Ice % WRF ) case ( 3 ) allocate ( Type_WRF_KO :: Ice % WRF ) case ( 4 ) allocate ( Type_WRF_MVG :: Ice % WRF ) case ( 5 ) allocate ( Type_WRF_Durner :: Ice % WRF ) case ( 6 ) allocate ( Type_WRF_DVGCH :: Ice % WRF ) case default print * , \"Error: WRFModelType is not defined.\" end select end select end subroutine Allocate_Structure_WRF_Type","tags":"","loc":"proc/allocate_structure_wrf_type.html"},{"title":"Allocate_Structure_Hydraulic_Type – FTDSS","text":"public subroutine Allocate_Structure_Hydraulic_Type(Structure_Hydraulic) Arguments Type Intent Optional Attributes Name type( Type_Hydraulic ), intent(inout) :: Structure_Hydraulic Calls proc~~allocate_structure_hydraulic_type~~CallsGraph proc~allocate_structure_hydraulic_type Allocate_Structure_Hydraulic_Type proc~allocate_structure_hcf_type Allocate_Structure_HCF_Type proc~allocate_structure_hydraulic_type->proc~allocate_structure_hcf_type Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Allocate_Structure_Hydraulic_Type Source Code subroutine Allocate_Structure_Hydraulic_Type ( Structure_Hydraulic ) ! Allocate hydraulic structure type implicit none type ( Type_Hydraulic ), intent ( inout ) :: Structure_Hydraulic ! Hydraulic structure if ( Structure_Hydraulic % useHCF > 0 ) then call Allocate_Structure_HCF_Type ( Structure_Hydraulic ) end if if ( Structure_Hydraulic % useImpedance ) then allocate ( Type_Impedance :: Structure_Hydraulic % Impedance ) end if select case ( Structure_Hydraulic % useKTDynamics ) case ( 1 : 2 ) allocate ( Type_KTDynamics :: Structure_Hydraulic % KTDynamics ) end select end subroutine Allocate_Structure_Hydraulic_Type","tags":"","loc":"proc/allocate_structure_hydraulic_type.html"},{"title":"Allocate_Structure_HCF_Type – FTDSS","text":"private subroutine Allocate_Structure_HCF_Type(Structure_Hydraulic) Arguments Type Intent Optional Attributes Name type( Type_Hydraulic ), intent(inout) :: Structure_Hydraulic Called by proc~~allocate_structure_hcf_type~~CalledByGraph proc~allocate_structure_hcf_type Allocate_Structure_HCF_Type proc~allocate_structure_hydraulic_type Allocate_Structure_Hydraulic_Type proc~allocate_structure_hydraulic_type->proc~allocate_structure_hcf_type Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Allocate_Structure_HCF_Type Source Code subroutine Allocate_Structure_HCF_Type ( Structure_Hydraulic ) ! Allocate WRF model type implicit none type ( Type_Hydraulic ), intent ( inout ) :: Structure_Hydraulic ! Hydraulic structure select case ( Structure_Hydraulic % useHCF ) case ( 1 ) allocate ( Type_HCF_BC :: Structure_Hydraulic % HCF ) case ( 2 ) allocate ( Type_HCF_VG :: Structure_Hydraulic % HCF ) case ( 3 ) allocate ( Type_HCF_KO :: Structure_Hydraulic % HCF ) case ( 4 ) allocate ( Type_HCF_MVG :: Structure_Hydraulic % HCF ) case ( 5 ) allocate ( Type_HCF_Durner :: Structure_Hydraulic % HCF ) case ( 6 ) allocate ( Type_HCF_DVGCH :: Structure_Hydraulic % HCF ) case default print * , \"Error: HCFModelType is not defined.\" end select end subroutine Allocate_Structure_HCF_Type","tags":"","loc":"proc/allocate_structure_hcf_type.html"},{"title":"Check_Allocate_rank1_int32 – FTDSS","text":"private subroutine Check_Allocate_rank1_int32(iar, ar_size) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_size Calls proc~~check_allocate_rank1_int32~~CallsGraph proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 proc~error_message error_message proc~check_allocate_rank1_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_allocate_rank1_int32~~CalledByGraph proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector Allocate_Vector interface~allocate_vector->proc~check_allocate_rank1_int32 proc~output_constructor Output_Constructor proc~output_constructor->interface~allocate_vector proc~allocate_bcinfo Allocate_BCinfo proc~allocate_bcinfo->interface~allocate_vector proc~allocate_int2d Allocate_INT2d proc~allocate_bcinfo->proc~allocate_int2d proc~allocate_dp2d Allocate_DP2d proc~allocate_dp2d->interface~allocate_vector proc~allocate_df Allocate_DF proc~allocate_df->interface~allocate_vector proc~convert_crs Convert_CRS proc~convert_crs->interface~allocate_vector proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~allocate_vector proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->interface~allocate_vector proc~allocate_int2d->interface~allocate_vector proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_vector proc~allocate_solver->proc~allocate_dp2d proc~allocate_solver->proc~allocate_df interface~output Output interface~output->proc~output_constructor proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Check_Allocate_rank1_int32 Source Code subroutine Check_Allocate_rank1_int32 ( iar , ar_size ) implicit none integer ( int32 ), intent ( in ) :: ar_size integer ( int32 ), intent ( inout ), allocatable :: iar (:) if ( ar_size <= 0 ) call error_message ( 951 ) if (. not . allocated ( iar )) then allocate ( iar ( ar_size )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_int32","tags":"","loc":"proc/check_allocate_rank1_int32.html"},{"title":"Check_Allocate_rank1_real64 – FTDSS","text":"private subroutine Check_Allocate_rank1_real64(dar, ar_size) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_size Calls proc~~check_allocate_rank1_real64~~CallsGraph proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 proc~error_message error_message proc~check_allocate_rank1_real64->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_allocate_rank1_real64~~CalledByGraph proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector Allocate_Vector interface~allocate_vector->proc~check_allocate_rank1_real64 proc~output_constructor Output_Constructor proc~output_constructor->interface~allocate_vector proc~allocate_bcinfo Allocate_BCinfo proc~allocate_bcinfo->interface~allocate_vector proc~allocate_int2d Allocate_INT2d proc~allocate_bcinfo->proc~allocate_int2d proc~allocate_dp2d Allocate_DP2d proc~allocate_dp2d->interface~allocate_vector proc~allocate_df Allocate_DF proc~allocate_df->interface~allocate_vector proc~convert_crs Convert_CRS proc~convert_crs->interface~allocate_vector proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~allocate_vector proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->interface~allocate_vector proc~allocate_int2d->interface~allocate_vector proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_vector proc~allocate_solver->proc~allocate_dp2d proc~allocate_solver->proc~allocate_df interface~output Output interface~output->proc~output_constructor proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Check_Allocate_rank1_real64 Source Code subroutine Check_Allocate_rank1_real64 ( dar , ar_size ) implicit none integer ( int32 ), intent ( in ) :: ar_size real ( real64 ), intent ( inout ), allocatable :: dar (:) if ( ar_size <= 0 ) call error_message ( 951 ) if (. not . allocated ( dar )) then allocate ( dar ( ar_size )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_real64","tags":"","loc":"proc/check_allocate_rank1_real64.html"},{"title":"Check_Allocate_rank1_logical – FTDSS","text":"private subroutine Check_Allocate_rank1_logical(lar, ar_size) Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: lar (:) integer(kind=int32), intent(in) :: ar_size Calls proc~~check_allocate_rank1_logical~~CallsGraph proc~check_allocate_rank1_logical Check_Allocate_rank1_logical proc~error_message error_message proc~check_allocate_rank1_logical->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_allocate_rank1_logical~~CalledByGraph proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector Allocate_Vector interface~allocate_vector->proc~check_allocate_rank1_logical proc~output_constructor Output_Constructor proc~output_constructor->interface~allocate_vector proc~allocate_bcinfo Allocate_BCinfo proc~allocate_bcinfo->interface~allocate_vector proc~allocate_int2d Allocate_INT2d proc~allocate_bcinfo->proc~allocate_int2d proc~allocate_dp2d Allocate_DP2d proc~allocate_dp2d->interface~allocate_vector proc~allocate_df Allocate_DF proc~allocate_df->interface~allocate_vector proc~convert_crs Convert_CRS proc~convert_crs->interface~allocate_vector proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~allocate_vector proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->interface~allocate_vector proc~allocate_int2d->interface~allocate_vector proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_vector proc~allocate_solver->proc~allocate_dp2d proc~allocate_solver->proc~allocate_df interface~output Output interface~output->proc~output_constructor proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Check_Allocate_rank1_logical Source Code subroutine Check_Allocate_rank1_logical ( lar , ar_size ) implicit none integer ( int32 ), intent ( in ) :: ar_size logical , intent ( inout ), allocatable :: lar (:) if ( ar_size <= 0 ) call error_message ( 951 ) if (. not . allocated ( lar )) then allocate ( lar ( ar_size )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_logical","tags":"","loc":"proc/check_allocate_rank1_logical.html"},{"title":"Check_Allocate_rank1_int32_specify – FTDSS","text":"private subroutine Check_Allocate_rank1_int32_specify(iar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last Calls proc~~check_allocate_rank1_int32_specify~~CallsGraph proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify proc~error_message error_message proc~check_allocate_rank1_int32_specify->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_allocate_rank1_int32_specify~~CalledByGraph proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector Allocate_Vector interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~output_constructor Output_Constructor proc~output_constructor->interface~allocate_vector proc~allocate_bcinfo Allocate_BCinfo proc~allocate_bcinfo->interface~allocate_vector proc~allocate_int2d Allocate_INT2d proc~allocate_bcinfo->proc~allocate_int2d proc~allocate_dp2d Allocate_DP2d proc~allocate_dp2d->interface~allocate_vector proc~allocate_df Allocate_DF proc~allocate_df->interface~allocate_vector proc~convert_crs Convert_CRS proc~convert_crs->interface~allocate_vector proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~allocate_vector proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->interface~allocate_vector proc~allocate_int2d->interface~allocate_vector proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_vector proc~allocate_solver->proc~allocate_dp2d proc~allocate_solver->proc~allocate_df interface~output Output interface~output->proc~output_constructor proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Check_Allocate_rank1_int32_specify Source Code subroutine Check_Allocate_rank1_int32_specify ( iar , ar_first , ar_last ) implicit none integer ( int32 ), intent ( in ) :: ar_first , ar_last integer ( int32 ), intent ( inout ), allocatable :: iar (:) if (. not . allocated ( iar )) then allocate ( iar ( ar_first : ar_last )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_int32_specify","tags":"","loc":"proc/check_allocate_rank1_int32_specify.html"},{"title":"Check_Allocate_rank1_real64_specify – FTDSS","text":"private subroutine Check_Allocate_rank1_real64_specify(dar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last Calls proc~~check_allocate_rank1_real64_specify~~CallsGraph proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify proc~error_message error_message proc~check_allocate_rank1_real64_specify->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_allocate_rank1_real64_specify~~CalledByGraph proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector Allocate_Vector interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~output_constructor Output_Constructor proc~output_constructor->interface~allocate_vector proc~allocate_bcinfo Allocate_BCinfo proc~allocate_bcinfo->interface~allocate_vector proc~allocate_int2d Allocate_INT2d proc~allocate_bcinfo->proc~allocate_int2d proc~allocate_dp2d Allocate_DP2d proc~allocate_dp2d->interface~allocate_vector proc~allocate_df Allocate_DF proc~allocate_df->interface~allocate_vector proc~convert_crs Convert_CRS proc~convert_crs->interface~allocate_vector proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~allocate_vector proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->interface~allocate_vector proc~allocate_int2d->interface~allocate_vector proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_vector proc~allocate_solver->proc~allocate_dp2d proc~allocate_solver->proc~allocate_df interface~output Output interface~output->proc~output_constructor proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Check_Allocate_rank1_real64_specify Source Code subroutine Check_Allocate_rank1_real64_specify ( dar , ar_first , ar_last ) implicit none integer ( int32 ), intent ( in ) :: ar_first , ar_last real ( real64 ), intent ( inout ), allocatable :: dar (:) if (. not . allocated ( dar )) then allocate ( dar ( ar_first : ar_last )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_real64_specify","tags":"","loc":"proc/check_allocate_rank1_real64_specify.html"},{"title":"Check_Allocate_rank2_int32 – FTDSS","text":"private subroutine Check_Allocate_rank2_int32(imt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: imt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2 Calls proc~~check_allocate_rank2_int32~~CallsGraph proc~check_allocate_rank2_int32 Check_Allocate_rank2_int32 proc~error_message error_message proc~check_allocate_rank2_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_allocate_rank2_int32~~CalledByGraph proc~check_allocate_rank2_int32 Check_Allocate_rank2_int32 interface~allocate_matrix Allocate_Matrix interface~allocate_matrix->proc~check_allocate_rank2_int32 proc~calc_gm_time_trm_f Calc_GM_Time_TRM_F proc~calc_gm_time_trm_f->interface~allocate_matrix proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~allocate_matrix proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_matrix proc~solve_initialize_bicgstab Solve_Initialize_BiCGStab proc~solve_initialize_bicgstab->interface~allocate_matrix interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 interface~ils ILS interface~ils->proc~solve_initialize_bicgstab Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Check_Allocate_rank2_int32 Source Code subroutine Check_Allocate_rank2_int32 ( imt , mt_size_1 , mt_size_2 ) implicit none integer ( int32 ), intent ( in ) :: mt_size_1 , mt_size_2 integer ( int32 ), intent ( inout ), allocatable :: imt (:,:) if ( mt_size_1 <= 0 . or . mt_size_2 <= 0 ) call error_message ( 952 ) if (. not . allocated ( imt )) then allocate ( imt ( mt_size_1 , mt_size_2 )) else call error_message ( 954 ) end if end subroutine Check_Allocate_rank2_int32","tags":"","loc":"proc/check_allocate_rank2_int32.html"},{"title":"Check_Allocate_rank2_real64 – FTDSS","text":"private subroutine Check_Allocate_rank2_real64(dmt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dmt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2 Calls proc~~check_allocate_rank2_real64~~CallsGraph proc~check_allocate_rank2_real64 Check_Allocate_rank2_real64 proc~error_message error_message proc~check_allocate_rank2_real64->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_allocate_rank2_real64~~CalledByGraph proc~check_allocate_rank2_real64 Check_Allocate_rank2_real64 interface~allocate_matrix Allocate_Matrix interface~allocate_matrix->proc~check_allocate_rank2_real64 proc~calc_gm_time_trm_f Calc_GM_Time_TRM_F proc~calc_gm_time_trm_f->interface~allocate_matrix proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~allocate_matrix proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_matrix proc~solve_initialize_bicgstab Solve_Initialize_BiCGStab proc~solve_initialize_bicgstab->interface~allocate_matrix interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 interface~ils ILS interface~ils->proc~solve_initialize_bicgstab Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Check_Allocate_rank2_real64 Source Code subroutine Check_Allocate_rank2_real64 ( dmt , mt_size_1 , mt_size_2 ) implicit none integer ( int32 ), intent ( in ) :: mt_size_1 , mt_size_2 real ( real64 ), intent ( inout ), allocatable :: dmt (:,:) if ( mt_size_1 <= 0 . or . mt_size_2 <= 0 ) call error_message ( 952 ) if (. not . allocated ( dmt )) then allocate ( dmt ( mt_size_1 , mt_size_2 )) else call error_message ( 954 ) end if end subroutine Check_Allocate_rank2_real64","tags":"","loc":"proc/check_allocate_rank2_real64.html"},{"title":"Check_Allocate_Pointer_int32 – FTDSS","text":"private subroutine Check_Allocate_Pointer_int32(iptr) Arguments Type Intent Optional Attributes Name integer(kind=int32), pointer :: iptr Calls proc~~check_allocate_pointer_int32~~CallsGraph proc~check_allocate_pointer_int32 Check_Allocate_Pointer_int32 proc~error_message error_message proc~check_allocate_pointer_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_allocate_pointer_int32~~CalledByGraph proc~check_allocate_pointer_int32 Check_Allocate_Pointer_int32 interface~allocate_pointer Allocate_Pointer interface~allocate_pointer->proc~check_allocate_pointer_int32 proc~initialize_solver Initialize_Solver proc~initialize_solver->interface~allocate_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Check_Allocate_Pointer_int32 Source Code subroutine Check_Allocate_Pointer_int32 ( iptr ) implicit none integer ( int32 ), pointer :: iptr if (. not . associated ( iptr )) then allocate ( iptr ) else call error_message ( 955 ) end if end subroutine Check_Allocate_Pointer_int32","tags":"","loc":"proc/check_allocate_pointer_int32.html"},{"title":"Check_Allocate_Pointer_real64 – FTDSS","text":"private subroutine Check_Allocate_Pointer_real64(dptr) Arguments Type Intent Optional Attributes Name real(kind=real64), pointer :: dptr Calls proc~~check_allocate_pointer_real64~~CallsGraph proc~check_allocate_pointer_real64 Check_Allocate_Pointer_real64 proc~error_message error_message proc~check_allocate_pointer_real64->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~check_allocate_pointer_real64~~CalledByGraph proc~check_allocate_pointer_real64 Check_Allocate_Pointer_real64 interface~allocate_pointer Allocate_Pointer interface~allocate_pointer->proc~check_allocate_pointer_real64 proc~initialize_solver Initialize_Solver proc~initialize_solver->interface~allocate_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Check_Allocate_Pointer_real64 Source Code subroutine Check_Allocate_Pointer_real64 ( dptr ) implicit none real ( real64 ), pointer :: dptr if (. not . associated ( dptr )) then allocate ( dptr ) else call error_message ( 955 ) end if end subroutine Check_Allocate_Pointer_real64","tags":"","loc":"proc/check_allocate_pointer_real64.html"},{"title":"Duplicate_CRS – FTDSS","text":"public subroutine Duplicate_CRS(A, B) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A type( CRS ), intent(inout) :: B Called by proc~~duplicate_crs~~CalledByGraph proc~duplicate_crs Duplicate_CRS proc~init_assemble Init_Assemble proc~init_assemble->proc~duplicate_crs proc~solve_initialize_bicgstab Solve_Initialize_BiCGStab proc~solve_initialize_bicgstab->proc~duplicate_crs interface~ils ILS interface~ils->proc~solve_initialize_bicgstab Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Duplicate_CRS Source Code subroutine Duplicate_CRS ( A , B ) implicit none type ( CRS ), intent ( in ) :: A type ( CRS ), intent ( inout ) :: B B % nnz = A % nnz if (. not . allocated ( B % Ptr )) then allocate ( B % Ptr , source = A % Ptr ) else ! call error_message(951) end if if (. not . allocated ( B % Ind )) then allocate ( B % Ind , source = A % Ind ) else ! call error_message(951) end if if (. not . allocated ( B % val )) then allocate ( B % val , source = A % Val ) else ! call error_message(951) end if B % val = 0.0d0 end subroutine Duplicate_CRS","tags":"","loc":"proc/duplicate_crs.html"},{"title":"Allocate_Vector – FTDSS","text":"public interface Allocate_Vector Calls interface~~allocate_vector~~CallsGraph interface~allocate_vector Allocate_Vector proc~check_allocate_rank1_int32_specify Check_Allocate_rank1_int32_specify interface~allocate_vector->proc~check_allocate_rank1_int32_specify proc~check_allocate_rank1_real64 Check_Allocate_rank1_real64 interface~allocate_vector->proc~check_allocate_rank1_real64 proc~check_allocate_rank1_logical Check_Allocate_rank1_logical interface~allocate_vector->proc~check_allocate_rank1_logical proc~check_allocate_rank1_real64_specify Check_Allocate_rank1_real64_specify interface~allocate_vector->proc~check_allocate_rank1_real64_specify proc~check_allocate_rank1_int32 Check_Allocate_rank1_int32 interface~allocate_vector->proc~check_allocate_rank1_int32 proc~error_message error_message proc~check_allocate_rank1_int32_specify->proc~error_message proc~check_allocate_rank1_real64->proc~error_message proc~check_allocate_rank1_logical->proc~error_message proc~check_allocate_rank1_real64_specify->proc~error_message proc~check_allocate_rank1_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~allocate_vector~~CalledByGraph interface~allocate_vector Allocate_Vector proc~output_constructor Output_Constructor proc~output_constructor->interface~allocate_vector proc~allocate_bcinfo Allocate_BCinfo proc~allocate_bcinfo->interface~allocate_vector proc~allocate_int2d Allocate_INT2d proc~allocate_bcinfo->proc~allocate_int2d proc~allocate_dp2d Allocate_DP2d proc~allocate_dp2d->interface~allocate_vector proc~allocate_df Allocate_DF proc~allocate_df->interface~allocate_vector proc~convert_crs Convert_CRS proc~convert_crs->interface~allocate_vector proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~allocate_vector proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->interface~allocate_vector proc~allocate_int2d->interface~allocate_vector proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_vector proc~allocate_solver->proc~allocate_dp2d proc~allocate_solver->proc~allocate_df interface~output Output interface~output->proc~output_constructor proc~heat_constructor Heat_Constructor proc~heat_constructor->proc~set_boundary_condition_infomations interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 interface~heat Heat interface~heat->proc~heat_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Check_Allocate_rank1_int32 Check_Allocate_rank1_real64 Check_Allocate_rank1_logical Check_Allocate_rank1_int32_specify Check_Allocate_rank1_real64_specify Module Procedures private subroutine Check_Allocate_rank1_int32 (iar, ar_size) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_real64 (dar, ar_size) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_logical (lar, ar_size) Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: lar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_int32_specify (iar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last private subroutine Check_Allocate_rank1_real64_specify (dar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last","tags":"","loc":"interface/allocate_vector.html"},{"title":"Allocate_Matrix – FTDSS","text":"public interface Allocate_Matrix Calls interface~~allocate_matrix~~CallsGraph interface~allocate_matrix Allocate_Matrix proc~check_allocate_rank2_int32 Check_Allocate_rank2_int32 interface~allocate_matrix->proc~check_allocate_rank2_int32 proc~check_allocate_rank2_real64 Check_Allocate_rank2_real64 interface~allocate_matrix->proc~check_allocate_rank2_real64 proc~error_message error_message proc~check_allocate_rank2_int32->proc~error_message proc~check_allocate_rank2_real64->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~allocate_matrix~~CalledByGraph interface~allocate_matrix Allocate_Matrix proc~calc_gm_time_trm_f Calc_GM_Time_TRM_F proc~calc_gm_time_trm_f->interface~allocate_matrix proc~set_obs_coo_31 Set_Obs_COO_31 proc~set_obs_coo_31->interface~allocate_matrix proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_matrix proc~solve_initialize_bicgstab Solve_Initialize_BiCGStab proc~solve_initialize_bicgstab->interface~allocate_matrix interface~set_obs_coo Set_Obs_COO interface~set_obs_coo->proc~set_obs_coo_31 interface~ils ILS interface~ils->proc~solve_initialize_bicgstab Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Check_Allocate_rank2_int32 Check_Allocate_rank2_real64 Module Procedures private subroutine Check_Allocate_rank2_int32 (imt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: imt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2 private subroutine Check_Allocate_rank2_real64 (dmt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dmt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2","tags":"","loc":"interface/allocate_matrix.html"},{"title":"Allocate_Pointer – FTDSS","text":"public interface Allocate_Pointer Calls interface~~allocate_pointer~~CallsGraph interface~allocate_pointer Allocate_Pointer proc~check_allocate_pointer_real64 Check_Allocate_Pointer_real64 interface~allocate_pointer->proc~check_allocate_pointer_real64 proc~check_allocate_pointer_int32 Check_Allocate_Pointer_int32 interface~allocate_pointer->proc~check_allocate_pointer_int32 proc~error_message error_message proc~check_allocate_pointer_real64->proc~error_message proc~check_allocate_pointer_int32->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~allocate_pointer~~CalledByGraph interface~allocate_pointer Allocate_Pointer proc~initialize_solver Initialize_Solver proc~initialize_solver->interface~allocate_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures Check_Allocate_Pointer_real64 Check_Allocate_Pointer_int32 Module Procedures private subroutine Check_Allocate_Pointer_real64 (dptr) Arguments Type Intent Optional Attributes Name real(kind=real64), pointer :: dptr private subroutine Check_Allocate_Pointer_int32 (iptr) Arguments Type Intent Optional Attributes Name integer(kind=int32), pointer :: iptr","tags":"","loc":"interface/allocate_pointer.html"},{"title":"Fix_InitialCondition – FTDSS","text":"public subroutine Fix_InitialCondition(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~fix_initialcondition~~CallsGraph proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat proc~fix_initialcondition_freezingrate Fix_InitialCondition_FreezingRate proc~fix_initialcondition->proc~fix_initialcondition_freezingrate proc~fix_initialcondtion_constant_heat Fix_InitialCondtion_Constant_Heat proc~fix_initialcondition->proc~fix_initialcondtion_constant_heat proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~fix_initialcondition->proc~fix_initialcondition_gradient_water proc~fix_initialcondtion_constant_water Fix_InitialCondtion_Constant_Water proc~fix_initialcondition->proc~fix_initialcondtion_constant_water proc~update_parameters_heat Update_Parameters_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~fix_boundaryconditions Fix_BoundaryConditions proc~fix_initialcondition_gradient_heat->proc~fix_boundaryconditions proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~fix_initialcondition_gradient_water->proc~fix_boundaryconditions proc~assemble_gm_water_ic Assemble_GM_Water_IC proc~fix_initialcondition_gradient_water->proc~assemble_gm_water_ic proc~update_parameters_water Update_Parameters_Water proc~fix_initialcondition_gradient_water->proc~update_parameters_water proc~update_theta Update_theta proc~update_parameters_heat->proc~update_theta proc~update_flux Update_Flux proc~update_parameters_heat->proc~update_flux proc~update_cpa_gcc Update_Cpa_GCC proc~update_parameters_heat->proc~update_cpa_gcc proc~update_cadiv Update_Cadiv proc~update_parameters_heat->proc~update_cadiv proc~update_variables_geometric Update_Variables_Geometric proc~update_parameters_heat->proc~update_variables_geometric proc~update_heat_flux Update_Heat_Flux proc~update_parameters_heat->proc~update_heat_flux proc~update_cpa_power Update_Cpa_Power proc~update_parameters_heat->proc~update_cpa_power proc~update_gradient Update_Gradient proc~update_parameters_heat->proc~update_gradient proc~update_variables_arithmetic Update_Variables_Arithmetic proc~update_parameters_heat->proc~update_variables_arithmetic proc~update_phase Update_Phase proc~update_parameters_heat->proc~update_phase proc~fix_dirichletboundarycondition_water_f Fix_DirichletBoundaryCondition_Water_F proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_water_f proc~fix_dirichletboundarycondition_temperature Fix_DirichletBoundaryCondition_Temperature proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_temperature proc~calc_gm_diffusion_richards_f Calc_GM_Diffusion_Richards_F proc~assemble_gm_water_ic->proc~calc_gm_diffusion_richards_f proc~calc_gm_time_trm Calc_GM_Time_TRM proc~assemble_gm_heat_ic->proc~calc_gm_time_trm proc~calc_gm_diffusion_trm Calc_GM_Diffusion_TRM proc~assemble_gm_heat_ic->proc~calc_gm_diffusion_trm proc~calc_gm_diffusion Calc_GM_Diffusion proc~assemble_gm_heat_ic->proc~calc_gm_diffusion proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~assemble_gm_heat_ic->proc~matrix_vector_product_crs proc~calc_gm_time_divide Calc_GM_Time_Divide proc~assemble_gm_heat_ic->proc~calc_gm_time_divide proc~update_variables_log Update_Variables_Log proc~update_parameters_water->proc~update_variables_log proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_time_trm->proc~find_crs_indexes proc~calc_gm_diffusion_trm->proc~find_crs_indexes proc~find_crs_index Find_CRS_Index proc~fix_dirichletboundarycondition_temperature->proc~find_crs_index proc~calc_gm_diffusion->proc~find_crs_indexes proc~calc_gm_time_divide->proc~find_crs_indexes proc~set_c Set_C proc~calc_gm_time_divide->proc~set_c proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Fix_InitialCondition Source Code subroutine Fix_InitialCondition ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver if ( Solver % isHeat ) then if ( Solver % IC % Heat % type == 1 ) then call Fix_InitialCondtion_Constant_Heat ( Solver ) else if ( Solver % IC % Heat % type == 2 ) then call Fix_InitialCondition_Gradient_Heat ( Solver ) Solver % IC % Heat % isSet = . false . end if if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) \"Set initial value of Temperature.\" end if if ( Solver % isWater ) then if ( Solver % IC % Water % type == 1 ) then call Fix_InitialCondtion_Constant_Water ( Solver ) else if ( Solver % IC % Water % type == 2 ) then call Fix_InitialCondition_Gradient_Water ( Solver ) Solver % IC % Water % isSet = . false . end if if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) \"Set initial value of Pressure.\" end if if ( Solver % isStress ) then ! To be implemented ! if (Solver%IC%Stress%type == 1) then !     call Fix_InitialCondtion_Constant(Solver) ! else if (Solver%IC%Stress%type == 2) then !     call Fix_InitialCondition_Gradient(Solver) ! end if ! if (Solver%Flags%isStdOut) write(*,'(a)') \"Set initial value of Stress.\" end if call Fix_InitialCondition_FreezingRate ( Solver ) end subroutine Fix_InitialCondition","tags":"","loc":"proc/fix_initialcondition.html"},{"title":"Fix_InitialCondtion_Constant_Heat – FTDSS","text":"private subroutine Fix_InitialCondtion_Constant_Heat(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Called by proc~~fix_initialcondtion_constant_heat~~CalledByGraph proc~fix_initialcondtion_constant_heat Fix_InitialCondtion_Constant_Heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondtion_constant_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Fix_InitialCondtion_Constant_Heat Source Code subroutine Fix_InitialCondtion_Constant_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , iBC integer ( int32 ) :: ntBC , nBC do iN = 1 , Solver % N % node Solver % T % pre ( iN ) = Solver % IC % Heat % Value end do ! 初期温度場への境界条件の設定 do iBC = 1 , Solver % BC % numNode ntBC = Solver % BC % Heat % Type ( Solver % BC % Heat % TypeKey ( iBC )) if ( 10 <= ntBC . and . ntBC <= 19 ) then Solver % T % pre ( Solver % BC % Heat % Node ( iBC )) = Solver % BC % Heat % Value ( Solver % BC % Heat % TypeKey ( iBC )) end if end do end subroutine Fix_InitialCondtion_Constant_Heat","tags":"","loc":"proc/fix_initialcondtion_constant_heat.html"},{"title":"Fix_InitialCondtion_Constant_Water – FTDSS","text":"private subroutine Fix_InitialCondtion_Constant_Water(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Called by proc~~fix_initialcondtion_constant_water~~CalledByGraph proc~fix_initialcondtion_constant_water Fix_InitialCondtion_Constant_Water proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondtion_constant_water Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Fix_InitialCondtion_Constant_Water Source Code subroutine Fix_InitialCondtion_Constant_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , iBC integer ( int32 ) :: ntBC , nBC do iN = 1 , Solver % N % node Solver % P % pre ( iN ) = Solver % IC % Water % Value end do ! 初期圧力場への境界条件の設定 do iBC = 1 , Solver % BC % numNode ntBC = Solver % BC % Water % Type ( Solver % BC % Water % TypeKey ( iBC )) if ( 20 <= ntBC . and . ntBC <= 29 ) then Solver % P % pre ( Solver % BC % Water % Node ( iBC )) = Solver % BC % Water % Value ( Solver % BC % Water % TypeKey ( iBC )) end if end do end subroutine Fix_InitialCondtion_Constant_Water","tags":"","loc":"proc/fix_initialcondtion_constant_water.html"},{"title":"Fix_InitialCondition_Gradient_Heat – FTDSS","text":"private subroutine Fix_InitialCondition_Gradient_Heat(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~fix_initialcondition_gradient_heat~~CallsGraph proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~update_parameters_heat Update_Parameters_Heat proc~fix_initialcondition_gradient_heat->proc~update_parameters_heat proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~fix_initialcondition_gradient_heat->proc~assemble_gm_heat_ic proc~fix_boundaryconditions Fix_BoundaryConditions proc~fix_initialcondition_gradient_heat->proc~fix_boundaryconditions proc~update_theta Update_theta proc~update_parameters_heat->proc~update_theta proc~update_cadiv Update_Cadiv proc~update_parameters_heat->proc~update_cadiv proc~update_variables_arithmetic Update_Variables_Arithmetic proc~update_parameters_heat->proc~update_variables_arithmetic proc~update_flux Update_Flux proc~update_parameters_heat->proc~update_flux proc~update_cpa_power Update_Cpa_Power proc~update_parameters_heat->proc~update_cpa_power proc~update_variables_geometric Update_Variables_Geometric proc~update_parameters_heat->proc~update_variables_geometric proc~update_cpa_gcc Update_Cpa_GCC proc~update_parameters_heat->proc~update_cpa_gcc proc~update_phase Update_Phase proc~update_parameters_heat->proc~update_phase proc~update_gradient Update_Gradient proc~update_parameters_heat->proc~update_gradient proc~update_heat_flux Update_Heat_Flux proc~update_parameters_heat->proc~update_heat_flux proc~calc_gm_time_trm Calc_GM_Time_TRM proc~assemble_gm_heat_ic->proc~calc_gm_time_trm proc~calc_gm_diffusion Calc_GM_Diffusion proc~assemble_gm_heat_ic->proc~calc_gm_diffusion proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~assemble_gm_heat_ic->proc~matrix_vector_product_crs proc~calc_gm_diffusion_trm Calc_GM_Diffusion_TRM proc~assemble_gm_heat_ic->proc~calc_gm_diffusion_trm proc~calc_gm_time_divide Calc_GM_Time_Divide proc~assemble_gm_heat_ic->proc~calc_gm_time_divide proc~fix_dirichletboundarycondition_water_f Fix_DirichletBoundaryCondition_Water_F proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_water_f proc~fix_dirichletboundarycondition_temperature Fix_DirichletBoundaryCondition_Temperature proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_temperature proc~find_crs_indexes Find_CRS_Indexes proc~calc_gm_time_trm->proc~find_crs_indexes proc~calc_gm_diffusion->proc~find_crs_indexes proc~calc_gm_diffusion_trm->proc~find_crs_indexes proc~calc_gm_time_divide->proc~find_crs_indexes proc~set_c Set_C proc~calc_gm_time_divide->proc~set_c proc~find_crs_index Find_CRS_Index proc~fix_dirichletboundarycondition_temperature->proc~find_crs_index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fix_initialcondition_gradient_heat~~CalledByGraph proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Fix_InitialCondition_Gradient_Heat Source Code subroutine Fix_InitialCondition_Gradient_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver type ( ILS ), allocatable :: ILEQ integer ( int32 ) :: ierr ILEQ = ILS ( Solver , Solver % Heat % LHS_A ) call Update_Parameters_Heat ( Solver ) call Assemble_GM_Heat_IC ( Solver ) call Fix_BoundaryConditions ( Solver , Temperature ) call ILEQ % BiCGStab ( Solver , Solver % Heat % LHS_A , Solver % Heat % Rhs , Solver % T % pre , ierr ) call ILEQ % Chkerr ( ierr , 0.0d0 ) deallocate ( ILEQ ) end subroutine Fix_InitialCondition_Gradient_Heat","tags":"","loc":"proc/fix_initialcondition_gradient_heat.html"},{"title":"Fix_InitialCondition_Gradient_Water – FTDSS","text":"private subroutine Fix_InitialCondition_Gradient_Water(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~fix_initialcondition_gradient_water~~CallsGraph proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~update_parameters_water Update_Parameters_Water proc~fix_initialcondition_gradient_water->proc~update_parameters_water proc~fix_boundaryconditions Fix_BoundaryConditions proc~fix_initialcondition_gradient_water->proc~fix_boundaryconditions proc~assemble_gm_water_ic Assemble_GM_Water_IC proc~fix_initialcondition_gradient_water->proc~assemble_gm_water_ic proc~update_variables_log Update_Variables_Log proc~update_parameters_water->proc~update_variables_log proc~fix_dirichletboundarycondition_temperature Fix_DirichletBoundaryCondition_Temperature proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_temperature proc~fix_dirichletboundarycondition_water_f Fix_DirichletBoundaryCondition_Water_F proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_water_f proc~calc_gm_diffusion_richards_f Calc_GM_Diffusion_Richards_F proc~assemble_gm_water_ic->proc~calc_gm_diffusion_richards_f proc~find_crs_index Find_CRS_Index proc~fix_dirichletboundarycondition_temperature->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fix_initialcondition_gradient_water~~CalledByGraph proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_water Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Fix_InitialCondition_Gradient_Water Source Code subroutine Fix_InitialCondition_Gradient_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver type ( DLS ) :: DLEQ Solver % Si % old (:) = Solver % Si % pre (:) Solver % Si % pre (:) = 0.0d0 call Update_Parameters_Water ( Solver ) Solver % Si % pre (:) = Solver % Si % old (:) call Assemble_GM_Water_IC ( Solver ) call Fix_BoundaryConditions ( Solver , Pressure ) DLEQ = DLS ( Solver ) call DLEQ % LU ( Solver % Water % RA , Solver % Water % Rhs , Solver % P % pre ) end subroutine Fix_InitialCondition_Gradient_Water","tags":"","loc":"proc/fix_initialcondition_gradient_water.html"},{"title":"Fix_InitialCondition_FreezingRate – FTDSS","text":"private subroutine Fix_InitialCondition_FreezingRate(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Called by proc~~fix_initialcondition_freezingrate~~CalledByGraph proc~fix_initialcondition_freezingrate Fix_InitialCondition_FreezingRate proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_freezingrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Fix_InitialCondition_FreezingRate Source Code subroutine Fix_InitialCondition_FreezingRate ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , iBC real ( real64 ) :: Tf ! GCC model real ( real64 ) :: Qs , Qr , alpha , n , m , Lf real ( real64 ), parameter :: TtoK = 27 3.15d0 ! Power model real ( real64 ) :: a if ( Solver % Flags % isTRM ) then do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < 0.0d0 ) then Solver % Si % pre ( iN ) = 1.0d0 else Solver % Si % pre ( iN ) = 0.0d0 end if end do else if ( Solver % Flags % isGCC ) then Qs = Solver % Heat % Latent % GCC % thetaS Qr = Solver % Heat % Latent % GCC % thetaR alpha = Solver % Heat % Latent % GCC % alpha n = Solver % Heat % Latent % GCC % n m = Solver % Heat % Latent % GCC % m Lf = Solver % Heat % Latent % Lf Tf = Solver % Heat % Latent % GCC % Tf do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = (( Qs - Qr ) * ( 1.0d0 - ( 1.0d0 + abs ( alpha * Lf * log (( Solver % T % pre ( iN ) + TtoK ) / TtoK ) / g ) & ** n ) ** ( - m ))) / Qs else Solver % Si % pre ( iN ) = 0.0d0 end if end do else if ( Solver % Flags % isPower ) then Tf = Solver % Heat % Latent % Power % Tf a = Solver % Heat % Latent % Power % a do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = 1.0d0 - ( 1.0d0 - Solver % T % pre ( iN ) + Tf ) ** a else Solver % Si % pre ( iN ) = 0.0d0 end if end do end if if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) \"Set initial value of Freezing rate.\" end subroutine Fix_InitialCondition_FreezingRate","tags":"","loc":"proc/fix_initialcondition_freezingrate.html"},{"title":"Fix_BoundaryConditions – FTDSS","text":"public subroutine Fix_BoundaryConditions(Solver, inTarget) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: inTarget Calls proc~~fix_boundaryconditions~~CallsGraph proc~fix_boundaryconditions Fix_BoundaryConditions proc~fix_dirichletboundarycondition_temperature Fix_DirichletBoundaryCondition_Temperature proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_temperature proc~fix_dirichletboundarycondition_water_f Fix_DirichletBoundaryCondition_Water_F proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_water_f proc~find_crs_index Find_CRS_Index proc~fix_dirichletboundarycondition_temperature->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fix_boundaryconditions~~CalledByGraph proc~fix_boundaryconditions Fix_BoundaryConditions proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~fix_boundaryconditions proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~fix_initialcondition_gradient_water->proc~fix_boundaryconditions proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat proc~fix_initialcondition->proc~fix_initialcondition_gradient_water Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Fix_BoundaryConditions Source Code subroutine Fix_BoundaryConditions ( Solver , inTarget ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: inTarget integer ( int32 ) :: iBC , i integer ( int32 ) :: iBCType integer ( int32 ) :: p1 , p2 do iBC = 1 , Solver % BC % numNode if ( inTarget == Tmp ) then iBCType = Solver % BC % Heat % type ( Solver % BC % Heat % TypeKey ( iBC )) if ( 10 <= iBCType . and . iBCType <= 19 ) then call Fix_DirichletBoundaryCondition_Temperature ( Solver , iBC ) ! call Fix_DirichletBoundaryCondition_Temperature_F(Solver, iBC) end if else if ( inTarget == Prs ) then iBCType = Solver % BC % Water % type ( Solver % BC % Water % TypeKey ( iBC )) if ( 10 <= iBCType . and . iBCType <= 19 ) then ! call Fix_DirichletBoundaryCondition_Water(Solver, iBC) call Fix_DirichletBoundaryCondition_Water_F ( Solver , iBC ) end if end if ! stop ! Solver%Water%Variables%wFlux%y(Solver%BC%Water%TypeKey(iBC)) = 0.0d0 ! if (Solver%BC%Water%TypeKey(iBC) == 4) Solver%Water%Variables%wFlux%x(Solver%BC%Water%TypeKey(iBC)) = 0.0d0 end do if ( inTarget == Tmp . and . Solver % BC % numEdges > 0 ) then do i = 1 , Solver % BC % numEdges p1 = Solver % BC % Heat % Edges % x ( i ) p2 = Solver % BC % Heat % Edges % y ( i ) Solver % Heat % Rhs ( p1 ) = Solver % Heat % Rhs ( p1 ) - ( 2.0d0 * Solver % Heat % Variables % TFlux % x ( p1 ) + Solver % Heat % Variables % TFlux % x ( p2 )) * Solver % BC % Heat % EdgesDistance ( i ) / 6.0d0 Solver % Heat % Rhs ( p2 ) = Solver % Heat % Rhs ( p2 ) - ( Solver % Heat % Variables % TFlux % x ( p1 ) + 2.0d0 * Solver % Heat % Variables % TFlux % x ( p2 )) * Solver % BC % Heat % EdgesDistance ( i ) / 6.0d0 ! print*,Solver%Heat%Rhs(p1),Solver%Heat%Rhs(p2) ! print*,Solver%Heat%Variables%TFlux%x(p1),Solver%Heat%Variables%TFlux%x(p2) ! print*,(Solver%N%vCood%x(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%x(Solver%BC%Heat%Edges%x(i))),(Solver%N%vCood%y(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%y(Solver%BC%Heat%Edges%x(i))) end do ! print*, Solver%BC%Heat%EdgesDistance(:) ! print *, \"Water\" ! stop end if end subroutine Fix_BoundaryConditions","tags":"","loc":"proc/fix_boundaryconditions.html"},{"title":"Fix_DirichletBoundaryCondition_Temperature – FTDSS","text":"private subroutine Fix_DirichletBoundaryCondition_Temperature(Solver, iBC) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: iBC Calls proc~~fix_dirichletboundarycondition_temperature~~CallsGraph proc~fix_dirichletboundarycondition_temperature Fix_DirichletBoundaryCondition_Temperature proc~find_crs_index Find_CRS_Index proc~fix_dirichletboundarycondition_temperature->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fix_dirichletboundarycondition_temperature~~CalledByGraph proc~fix_dirichletboundarycondition_temperature Fix_DirichletBoundaryCondition_Temperature proc~fix_boundaryconditions Fix_BoundaryConditions proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_temperature proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~fix_boundaryconditions proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~fix_initialcondition_gradient_water->proc~fix_boundaryconditions proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat proc~fix_initialcondition->proc~fix_initialcondition_gradient_water Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Fix_DirichletBoundaryCondition_Temperature Source Code subroutine Fix_DirichletBoundaryCondition_Temperature ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Heat % Node ( iBC ) call Find_CRS_Index ( Solver % Heat % LHS_A , iCol , iCol , ind ) ps = Solver % Heat % LHS_A % Ptr ( iCol - 1 ) pe = Solver % Heat % LHS_A % Ptr ( iCol ) - 1 Solver % Heat % LHS_A % val ( ps : pe ) = 0.0d0 Solver % Heat % LHS_A % val ( ind ) = 1.0d0 Solver % Heat % Rhs ( iCol ) = Solver % BC % Heat % value ( Solver % BC % Heat % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Temperature","tags":"","loc":"proc/fix_dirichletboundarycondition_temperature.html"},{"title":"Fix_DirichletBoundaryCondition_Temperature_F – FTDSS","text":"private subroutine Fix_DirichletBoundaryCondition_Temperature_F(Solver, iBC) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: iBC Contents Source Code Fix_DirichletBoundaryCondition_Temperature_F Source Code subroutine Fix_DirichletBoundaryCondition_Temperature_F ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Heat % Node ( iBC ) ! print*,iCol,iBC Solver % Heat % RA ( iCol , :) = 0.0d0 Solver % Heat % RA ( iCol , iCol ) = 1.0d0 Solver % Heat % Rhs ( iCol ) = Solver % BC % Heat % value ( Solver % BC % Heat % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Temperature_F","tags":"","loc":"proc/fix_dirichletboundarycondition_temperature_f.html"},{"title":"Fix_DirichletBoundaryCondition_Water – FTDSS","text":"private subroutine Fix_DirichletBoundaryCondition_Water(Solver, iBC) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: iBC Calls proc~~fix_dirichletboundarycondition_water~~CallsGraph proc~fix_dirichletboundarycondition_water Fix_DirichletBoundaryCondition_Water proc~find_crs_index Find_CRS_Index proc~fix_dirichletboundarycondition_water->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Fix_DirichletBoundaryCondition_Water Source Code subroutine Fix_DirichletBoundaryCondition_Water ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Water % Node ( iBC ) call Find_CRS_Index ( Solver % Water % LHS_A , iCol , iCol , ind ) ps = Solver % Water % LHS_A % Ptr ( iCol - 1 ) pe = Solver % Water % LHS_A % Ptr ( iCol ) - 1 Solver % Water % LHS_A % val ( ps : pe ) = 0.0d0 Solver % Water % LHS_A % val ( ind ) = 1.0d0 Solver % Water % Rhs ( iCol ) = Solver % BC % Water % value ( Solver % BC % Water % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Water","tags":"","loc":"proc/fix_dirichletboundarycondition_water.html"},{"title":"Fix_DirichletBoundaryCondition_Water_F – FTDSS","text":"private subroutine Fix_DirichletBoundaryCondition_Water_F(Solver, iBC) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: iBC Called by proc~~fix_dirichletboundarycondition_water_f~~CalledByGraph proc~fix_dirichletboundarycondition_water_f Fix_DirichletBoundaryCondition_Water_F proc~fix_boundaryconditions Fix_BoundaryConditions proc~fix_boundaryconditions->proc~fix_dirichletboundarycondition_water_f proc~fix_initialcondition_gradient_heat Fix_InitialCondition_Gradient_Heat proc~fix_initialcondition_gradient_heat->proc~fix_boundaryconditions proc~fix_initialcondition_gradient_water Fix_InitialCondition_Gradient_Water proc~fix_initialcondition_gradient_water->proc~fix_boundaryconditions proc~fix_initialcondition Fix_InitialCondition proc~fix_initialcondition->proc~fix_initialcondition_gradient_heat proc~fix_initialcondition->proc~fix_initialcondition_gradient_water Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Fix_DirichletBoundaryCondition_Water_F Source Code subroutine Fix_DirichletBoundaryCondition_Water_F ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Water % Node ( iBC ) Solver % Water % RA ( iCol , :) = 0.0d0 Solver % Water % RA ( iCol , iCol ) = 1.0d0 Solver % Water % Rhs ( iCol ) = Solver % BC % Water % value ( Solver % BC % Water % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Water_F","tags":"","loc":"proc/fix_dirichletboundarycondition_water_f.html"},{"title":"Matrix_FindInd – FTDSS","text":"Uses iso_fortran_env Types module~~matrix_findind~~UsesGraph module~matrix_findind Matrix_FindInd iso_fortran_env iso_fortran_env module~matrix_findind->iso_fortran_env module~types Types module~matrix_findind->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~matrix_findind~~UsedByGraph module~matrix_findind Matrix_FindInd module~matrix_assemble Matrix_Assemble module~matrix_assemble->module~matrix_findind module~condition_fixboundarycondition Condition_FixBoundaryCondition module~condition_fixboundarycondition->module~matrix_findind module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~matrix_assemble module~condition_fixinitialcondition->module~condition_fixboundarycondition Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines Find_CRS_Index Find_CRS_Indexes Subroutines public subroutine Find_CRS_Index (A, serch_column, serch_index, index) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A integer(kind=int32), intent(in) :: serch_column integer(kind=int32), intent(in) :: serch_index integer(kind=int32), intent(inout) :: index public subroutine Find_CRS_Indexes (lump, A, serch_index1, serch_index2, serch_index3, indexes) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lump type( CRS ), intent(in) :: A integer(kind=int32), intent(in) :: serch_index1 integer(kind=int32), intent(in) :: serch_index2 integer(kind=int32), intent(in) :: serch_index3 integer(kind=int32), intent(inout) :: indexes (:)","tags":"","loc":"module/matrix_findind.html"},{"title":"Matrix_Assemble – FTDSS","text":"Uses Types Allocate_Structure Allocate iso_fortran_env Matrix_FindInd error omp_lib Calculate_Product module~~matrix_assemble~~UsesGraph module~matrix_assemble Matrix_Assemble module~types Types module~matrix_assemble->module~types module~allocate_structure Allocate_Structure module~matrix_assemble->module~allocate_structure omp_lib omp_lib module~matrix_assemble->omp_lib module~matrix_findind Matrix_FindInd module~matrix_assemble->module~matrix_findind module~allocate Allocate module~matrix_assemble->module~allocate iso_fortran_env iso_fortran_env module~matrix_assemble->iso_fortran_env module~error error module~matrix_assemble->module~error module~calculate_product Calculate_Product module~matrix_assemble->module~calculate_product module~types->iso_fortran_env module~allocate_structure->module~types module~allocate_structure->module~allocate module~allocate_structure->iso_fortran_env module~allocate_structure->module~error module~matrix_findind->module~types module~matrix_findind->iso_fortran_env module~allocate->module~types module~allocate->iso_fortran_env module~allocate->module~error module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~calculate_product->module~types module~calculate_product->omp_lib module~calculate_product->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~matrix_assemble~~UsedByGraph module~matrix_assemble Matrix_Assemble module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~matrix_assemble Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables D3 D4 D12 D24 tmpCRS1 tmpCRS2 tmpA Subroutines Init_Assemble Set_C Calc_GM_Time_TRM Calc_GM_Time_TRM_F Calc_GM_Time_Divide Calc_GM_Time_Richards Calc_GM_Diffusion_TRM Calc_GM_Diffusion Calc_GM_Diffusion_Richards Calc_GM_Diffusion_Richards_F Calc_GM_Diffusion_Advection_TRM Calc_GM_Diffusion_Advection_TRM_F Calc_GM_Diffusion_Advection Assemble_GM_Heat Assemble_GM_Heat_IC Assemble_GM_Water Assemble_GM_Water_IC Variables Type Visibility Attributes Name Initial real(kind=real64), private, parameter :: D3 = 0.33333333333333333333333333333d0 real(kind=real64), private, parameter :: D4 = 0.25000000000000000000000000000d0 real(kind=real64), private, parameter :: D12 = 0.08333333333333333333333333333d0 real(kind=real64), private, parameter :: D24 = 0.04166666666666666666666666666d0 type( CRS ), private :: tmpCRS1 type( CRS ), private :: tmpCRS2 real(kind=real64), private, allocatable :: tmpA (:,:) Subroutines public subroutine Init_Assemble (A) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A private subroutine Set_C (C, case, p, C1, C2) Arguments Type Intent Optional Attributes Name type( DF ), intent(in) :: C integer(kind=int32), intent(in) :: case integer(kind=int32), intent(in) :: p real(kind=real64), intent(inout) :: C1 real(kind=real64), intent(inout) :: C2 private subroutine Calc_GM_Time_TRM (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Calc_GM_Time_TRM_F (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Calc_GM_Time_Divide (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Calc_GM_Time_Richards (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Calc_GM_Diffusion_TRM (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Calc_GM_Diffusion (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Calc_GM_Diffusion_Richards (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Calc_GM_Diffusion_Richards_F (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Calc_GM_Diffusion_Advection_TRM (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Calc_GM_Diffusion_Advection_TRM_F (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Calc_GM_Diffusion_Advection (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Assemble_GM_Heat (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Assemble_GM_Heat_IC (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Assemble_GM_Water (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Assemble_GM_Water_IC (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/matrix_assemble.html"},{"title":"Matrix_ConvertCRS – FTDSS","text":"Uses Allocate iso_fortran_env Types module~~matrix_convertcrs~~UsesGraph module~matrix_convertcrs Matrix_ConvertCRS module~allocate Allocate module~matrix_convertcrs->module~allocate iso_fortran_env iso_fortran_env module~matrix_convertcrs->iso_fortran_env module~types Types module~matrix_convertcrs->module~types module~allocate->iso_fortran_env module~allocate->module~types module~error error module~allocate->module~error module~types->iso_fortran_env module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines Convert_CRS Subroutines public subroutine Convert_CRS (Solver, A) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(inout) :: A","tags":"","loc":"module/matrix_convertcrs.html"},{"title":"Main_Heat – FTDSS","text":"Uses Types Allocate_Structure Inout_Input Allocate iso_fortran_env Calculate_HCF module~~main_heat~~UsesGraph module~main_heat Main_Heat module~types Types module~main_heat->module~types module~allocate_structure Allocate_Structure module~main_heat->module~allocate_structure Inout_Input Inout_Input module~main_heat->Inout_Input module~allocate Allocate module~main_heat->module~allocate iso_fortran_env iso_fortran_env module~main_heat->iso_fortran_env module~calculate_hcf Calculate_HCF module~main_heat->module~calculate_hcf module~types->iso_fortran_env module~allocate_structure->module~types module~allocate_structure->module~allocate module~allocate_structure->iso_fortran_env module~error error module~allocate_structure->module~error module~allocate->module~types module~allocate->iso_fortran_env module~allocate->module~error module~calculate_hcf->module~types module~calculate_hcf->iso_fortran_env module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Calc_Heat Interfaces Heat Derived Types Heat Functions Heat_Constructor Condition_Heat Condition_In_BoundaryCondition Subroutines Set_Geometory_Infomation Set_Boundary_Condition_Infomations Variables Type Visibility Attributes Name Initial integer(kind=int32), private, parameter :: Calc_Heat = 1 Interfaces public interface Heat private function Heat_Constructor (Structure_Input) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Structure_Input Return Value type( Heat ) Derived Types type, public :: Heat Components Type Visibility Attributes Name Initial type( Geometry_2D ), private :: Geometry type( Boudary_Condition ), private :: BC type( HCF ), private :: HCFs Constructor private  function Heat_Constructor (Structure_Input) Functions private function Heat_Constructor (Structure_Input) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Structure_Input Return Value type( Heat ) private function Condition_Heat (num) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num Return Value logical private function Condition_In_BoundaryCondition (num, Value_Info) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: num integer(kind=int32), intent(in) :: Value_Info (:) Return Value logical Subroutines private subroutine Set_Geometory_Infomation (self, Structure_Input) Arguments Type Intent Optional Attributes Name type( Heat ), intent(inout) :: self type(Input), intent(in) :: Structure_Input private subroutine Set_Boundary_Condition_Infomations (self, Structure_Input) Arguments Type Intent Optional Attributes Name type( Heat ), intent(inout) :: self type(Input), intent(in) :: Structure_Input","tags":"","loc":"module/main_heat.html"},{"title":"Inout_Stdout – FTDSS","text":"Uses Types iso_fortran_env omp_lib module~~inout_stdout~~UsesGraph module~inout_stdout Inout_Stdout module~types Types module~inout_stdout->module~types omp_lib omp_lib module~inout_stdout->omp_lib iso_fortran_env iso_fortran_env module~inout_stdout->iso_fortran_env module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines init_omp_config Subroutines public subroutine init_omp_config (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/inout_stdout.html"},{"title":"Inout_Output – FTDSS","text":"Uses Types Inout_Input Inout_SetProjectPath Allocate iso_fortran_env error module~~inout_output~~UsesGraph module~inout_output Inout_Output module~types Types module~inout_output->module~types module~inout_setprojectpath Inout_SetProjectPath module~inout_output->module~inout_setprojectpath Inout_Input Inout_Input module~inout_output->Inout_Input module~allocate Allocate module~inout_output->module~allocate iso_fortran_env iso_fortran_env module~inout_output->iso_fortran_env module~error error module~inout_output->module~error module~types->iso_fortran_env module~inout_setprojectpath->iso_fortran_env module~inout_setprojectpath->module~error module~allocate->module~types module~allocate->iso_fortran_env module~allocate->module~error module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces Output Derived Types Output Functions Output_Constructor Subroutines Inout_Output_All Inout_Output_All_Dat Inout_Output_Observation Inout_Output_All_vtk Set_Output_Flag Interfaces public interface Output private function Output_Constructor (Inputs) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Inputs Return Value type( Output ) Derived Types type, public :: Output Components Type Visibility Attributes Name Initial integer(kind=int32), private, allocatable :: Output_Observation_Flag (:) character(len=256), private :: T_FileName character(len=256), private :: Fr_FileName character(len=256), private :: TC_FileName character(len=256), private :: C_FileName character(len=256), private :: P_FileName character(len=256), private :: Flux_FileName character(len=256), private :: K_FileName character(len=256), private :: dir_Path logical, private, allocatable :: is_Output (:) logical, private :: is_Output_Dat logical, private :: is_Output_VTK Constructor private  function Output_Constructor (Inputs) Type-Bound Procedures procedure, public :: Output_All => Inout_Output_All procedure, public :: Output_Observation => Inout_Output_Observation Functions private function Output_Constructor (Inputs) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Inputs Return Value type( Output ) Subroutines private subroutine Inout_Output_All (self, Solver, num) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: num private subroutine Inout_Output_All_Dat (self, Solver, num) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: num private subroutine Inout_Output_Observation (self, Solver, time) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver real(kind=real64), intent(in) :: time private subroutine Inout_Output_All_vtk (self, Solver, num) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: num private subroutine Set_Output_Flag (iValue, inFlag) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iValue logical, intent(inout) :: inFlag","tags":"","loc":"module/inout_output.html"},{"title":"Inout_SetProjectPath – FTDSS","text":"Uses error iso_fortran_env module~~inout_setprojectpath~~UsesGraph module~inout_setprojectpath Inout_SetProjectPath module~error error module~inout_setprojectpath->module~error iso_fortran_env iso_fortran_env module~inout_setprojectpath->iso_fortran_env module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~inout_setprojectpath~~UsedByGraph module~inout_setprojectpath Inout_SetProjectPath module~inout_output Inout_Output module~inout_output->module~inout_setprojectpath Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ProjectPath isSetProjectPath Functions Inout_SetProjectPath_GetProjectPath Subroutines Inout_SetProjectPath_SetProjectPath Variables Type Visibility Attributes Name Initial character(len=256), private :: ProjectPath logical, private :: isSetProjectPath = .false. Functions public function Inout_SetProjectPath_GetProjectPath () Arguments None Return Value character(len=256) Subroutines private subroutine Inout_SetProjectPath_SetProjectPath () Arguments None","tags":"","loc":"module/inout_setprojectpath.html"},{"title":"Calculate_Area – FTDSS","text":"Uses error iso_fortran_env Calculate_Points Types module~~calculate_area~~UsesGraph module~calculate_area Calculate_Area module~error error module~calculate_area->module~error module~calculate_points Calculate_Points module~calculate_area->module~calculate_points iso_fortran_env iso_fortran_env module~calculate_area->iso_fortran_env module~types Types module~calculate_area->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~calculate_points->module~error module~calculate_points->iso_fortran_env module~calculate_points->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces Calc_Area Subroutines Calc_Area_31 Interfaces public interface Calc_Area public subroutine Calc_Area_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry Subroutines public subroutine Calc_Area_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry","tags":"","loc":"module/calculate_area.html"},{"title":"Calculate_Points – FTDSS","text":"Uses error iso_fortran_env Types module~~calculate_points~~UsesGraph module~calculate_points Calculate_Points module~error error module~calculate_points->module~error iso_fortran_env iso_fortran_env module~calculate_points->iso_fortran_env module~types Types module~calculate_points->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~calculate_points~~UsedByGraph module~calculate_points Calculate_Points module~calculate_area Calculate_Area module~calculate_area->module~calculate_points module~calculate_shape Calculate_Shape module~calculate_shape->module~calculate_points module~calculate_observation Calculate_Observation module~calculate_observation->module~calculate_points Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces Set_Point Subroutines Set_Point_31 Interfaces public interface Set_Point private subroutine Set_Point_31 (Geometry, triangle_index, p1, p2, p3) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(in) :: Geometry integer(kind=int32), intent(in) :: triangle_index type( Vector2D ), intent(inout) :: p1 type( Vector2D ), intent(inout) :: p2 type( Vector2D ), intent(inout) :: p3 Subroutines private subroutine Set_Point_31 (Geometry, triangle_index, p1, p2, p3) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(in) :: Geometry integer(kind=int32), intent(in) :: triangle_index type( Vector2D ), intent(inout) :: p1 type( Vector2D ), intent(inout) :: p2 type( Vector2D ), intent(inout) :: p3","tags":"","loc":"module/calculate_points.html"},{"title":"Calculate_HCF – FTDSS","text":"Uses iso_fortran_env Types module~~calculate_hcf~~UsesGraph module~calculate_hcf Calculate_HCF iso_fortran_env iso_fortran_env module~calculate_hcf->iso_fortran_env module~types Types module~calculate_hcf->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~calculate_hcf~~UsedByGraph module~calculate_hcf Calculate_HCF module~main_heat Main_Heat module~main_heat->module~calculate_hcf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces HCF Abstract Interfaces Calculation_HCF Calculation_HCF_mu Derived Types HCF Functions HCF_Constructor Calculate_Ks Calculate_HCF_BC Calculate_HCF_VG Calculate_HCF_KO Calculate_HCF_MVG Calculate_HCF_Durner Calculate_HCF_DVGCH Calc_HCF_mu_Exponential Calc_HCF_mu_Exponential_Supercooled Interfaces public interface HCF public function HCF_Constructor (in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in_HCF_Parameters (:) integer(kind=int32), intent(in) :: HCF_Model_id integer(kind=int32), intent(in) :: Kflh_Model_id Return Value type( HCF ) Abstract Interfaces abstract interface public function Calculation_HCF(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) abstract interface public function Calculation_HCF_mu(T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64) Derived Types type, public, extends( HCF_Parameters ) :: HCF Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: Ks real(kind=real64), public :: kzero real(kind=real64), public :: l real(kind=real64), public :: Omega procedure( Calculation_HCF ), public, pointer, nopass :: Calculate_HCF => null() procedure( Calculation_HCF_mu ), public, pointer, nopass :: Calculate_HCF_mu => null() Constructor public  function HCF_Constructor (in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Type-Bound Procedures procedure, public :: Calculate_Kflh => Calculate_Ks Functions public function HCF_Constructor (in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in_HCF_Parameters (:) integer(kind=int32), intent(in) :: HCF_Model_id integer(kind=int32), intent(in) :: Kflh_Model_id Return Value type( HCF ) public function Calculate_Ks (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name class( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_BC (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_VG (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_KO (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_MVG (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_Durner (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_DVGCH (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calc_HCF_mu_Exponential (T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64) public function Calc_HCF_mu_Exponential_Supercooled (T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64)","tags":"","loc":"module/calculate_hcf.html"},{"title":"Calculate_Product – FTDSS","text":"Uses Types iso_fortran_env omp_lib module~~calculate_product~~UsesGraph module~calculate_product Calculate_Product module~types Types module~calculate_product->module~types omp_lib omp_lib module~calculate_product->omp_lib iso_fortran_env iso_fortran_env module~calculate_product->iso_fortran_env module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~calculate_product~~UsedByGraph module~calculate_product Calculate_Product module~matrix_assemble Matrix_Assemble module~matrix_assemble->module~calculate_product module~solver_solve Solver_Solve module~solver_solve->module~calculate_product module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~matrix_assemble module~condition_fixinitialcondition->module~solver_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines Matrix_Vector_Product_CRS Subroutines public subroutine Matrix_Vector_Product_CRS (A, x, y) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A real(kind=real64), intent(in) :: x (:) real(kind=real64), intent(inout) :: y (:)","tags":"","loc":"module/calculate_product.html"},{"title":"Calculate_WRF – FTDSS","text":"Uses iso_fortran_env Types module~~calculate_wrf~~UsesGraph module~calculate_wrf Calculate_WRF iso_fortran_env iso_fortran_env module~calculate_wrf->iso_fortran_env module~types Types module~calculate_wrf->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions Calculate_WRF_BC Calculate_WRF_Derivative_BC Calculate_WRF_VG Calculate_WRF_KO Calculate_WRF_MVG Calculate_WRF_Durner Calculate_WRF_DVGCH Functions public function Calculate_WRF_BC (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_BC ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_Derivative_BC (structure_WRF, h) result(Cw) Arguments Type Intent Optional Attributes Name type( Type_WRF_BC ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_VG (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_VG ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_KO (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_KO ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_MVG (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_MVG ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_Durner (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_Durner ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_DVGCH (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_DVGCH ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64)","tags":"","loc":"module/calculate_wrf.html"},{"title":"Calculate_Update – FTDSS","text":"Uses Types RootFinding_SecantMethod iso_fortran_env omp_lib RootFinding_BinaryFinding module~~calculate_update~~UsesGraph module~calculate_update Calculate_Update module~types Types module~calculate_update->module~types omp_lib omp_lib module~calculate_update->omp_lib module~rootfinding_binaryfinding RootFinding_BinaryFinding module~calculate_update->module~rootfinding_binaryfinding iso_fortran_env iso_fortran_env module~calculate_update->iso_fortran_env module~rootfinding_secantmethod RootFinding_SecantMethod module~calculate_update->module~rootfinding_secantmethod module~types->iso_fortran_env module~rootfinding_binaryfinding->module~types module~rootfinding_binaryfinding->iso_fortran_env module~calculate_latentheat Calculate_LatentHeat module~rootfinding_binaryfinding->module~calculate_latentheat ieee_arithmetic ieee_arithmetic module~rootfinding_binaryfinding->ieee_arithmetic module~rootfinding_secantmethod->module~types module~rootfinding_secantmethod->iso_fortran_env module~rootfinding_secantmethod->module~calculate_latentheat module~rootfinding_secantmethod->ieee_arithmetic module~calculate_latentheat->module~types module~calculate_latentheat->omp_lib module~calculate_latentheat->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~calculate_update~~UsedByGraph module~calculate_update Calculate_Update module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~calculate_update Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables threshold TtoK Linear pTransition NonLinear nTransition Subroutines Update_Parameters_Heat Update_Parameters_Water Update_theta Update_Variables_Arithmetic Update_Variables_Geometric Update_Variables_Log Update_Cpa_GCC Update_Cpa_Power Update_Phase Update_Phase_Revise Update_Cadiv Update_Si Update_Gradient Update_Flux Update_Heat_Flux Variables Type Visibility Attributes Name Initial real(kind=real64), private, parameter :: threshold = 1.0d-20 real(kind=real64), private, parameter :: TtoK = 273.15d0 integer(kind=int32), private, parameter :: Linear = 1 integer(kind=int32), private, parameter :: pTransition = 2 integer(kind=int32), private, parameter :: NonLinear = 3 integer(kind=int32), private, parameter :: nTransition = 4 Subroutines public subroutine Update_Parameters_Heat (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Update_Parameters_Water (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Update_theta (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Update_Variables_Arithmetic (Targets, Const, Si, Porosity, Flags) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: Targets (:) type( Phases ), intent(in) :: Const real(kind=real64), intent(in) :: Si (:) real(kind=real64), intent(in) :: Porosity type( Flag ), intent(in) :: Flags private subroutine Update_Variables_Geometric (Targets, Const, Si, Porosity, Flags) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: Targets (:) type( Phases ), intent(in) :: Const real(kind=real64), intent(in) :: Si (:) real(kind=real64), intent(in) :: Porosity type( Flag ), intent(in) :: Flags private subroutine Update_Variables_Log (Targets, Const, Si, Porosity, Flags) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: Targets (:) type( Phases ), intent(in) :: Const real(kind=real64), intent(in) :: Si (:) real(kind=real64), intent(in) :: Porosity type( Flag ), intent(in) :: Flags private subroutine Update_Cpa_GCC (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Update_Cpa_Power (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Update_Phase (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Update_Phase_Revise (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Update_Cadiv (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Update_Si (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Update_Gradient (Solver, ar, Grad) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver real(kind=real64), intent(in) :: ar (:) type( DP2d ), intent(inout) :: Grad private subroutine Update_Flux (Flux, C, Grad) Arguments Type Intent Optional Attributes Name type( DP2d ), intent(inout) :: Flux real(kind=real64), intent(in) :: C (:) type( DP2d ), intent(in) :: Grad private subroutine Update_Heat_Flux (TFlux, C, TGrad, Cw, Qw, T) Arguments Type Intent Optional Attributes Name type( DP2d ), intent(inout) :: TFlux real(kind=real64), intent(in) :: C (:) type( DP2d ), intent(in) :: TGrad real(kind=real64), intent(in) :: Cw type( DP2d ), intent(in) :: Qw real(kind=real64), intent(in) :: T (:)","tags":"","loc":"module/calculate_update.html"},{"title":"Calculate_Count – FTDSS","text":"Uses error iso_fortran_env Types module~~calculate_count~~UsesGraph module~calculate_count Calculate_Count module~error error module~calculate_count->module~error iso_fortran_env iso_fortran_env module~calculate_count->iso_fortran_env module~types Types module~calculate_count->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~calculate_count~~UsedByGraph module~calculate_count Calculate_Count proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->module~calculate_count Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces Count_if Functions Count_if_int32 Count_if_int32_Array Interfaces public interface Count_if public function Count_if_int32 (array, Condition) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value logical Return Value integer public function Count_if_int32_Array (array, Condition, condition_array) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x, condition_array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: condition_array (:) Return Value logical integer, intent(in) :: condition_array (:) Return Value integer Functions public function Count_if_int32 (array, Condition) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value logical Return Value integer public function Count_if_int32_Array (array, Condition, condition_array) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x, condition_array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: condition_array (:) Return Value logical integer, intent(in) :: condition_array (:) Return Value integer","tags":"","loc":"module/calculate_count.html"},{"title":"Calculate_TRM – FTDSS","text":"Uses Types iso_fortran_env omp_lib module~~calculate_trm~~UsesGraph module~calculate_trm Calculate_TRM module~types Types module~calculate_trm->module~types omp_lib omp_lib module~calculate_trm->omp_lib iso_fortran_env iso_fortran_env module~calculate_trm->iso_fortran_env module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines TRMethod Subroutines public subroutine TRMethod (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/calculate_trm.html"},{"title":"Calculate_Observation – FTDSS","text":"Uses Allocate iso_fortran_env Calculate_Points Types module~~calculate_observation~~UsesGraph module~calculate_observation Calculate_Observation module~allocate Allocate module~calculate_observation->module~allocate module~calculate_points Calculate_Points module~calculate_observation->module~calculate_points iso_fortran_env iso_fortran_env module~calculate_observation->iso_fortran_env module~types Types module~calculate_observation->module~types module~allocate->iso_fortran_env module~allocate->module~types module~error error module~allocate->module~error module~calculate_points->iso_fortran_env module~calculate_points->module~types module~calculate_points->module~error module~types->iso_fortran_env module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces Set_Obs_COO Functions is_in_triangle Subroutines Set_Obs_COO_31 Interfaces public interface Set_Obs_COO private subroutine Set_Obs_COO_31 (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Functions private function is_in_triangle (x, y, p1, p2, p3) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y type( Vector2D ), intent(in) :: p1 type( Vector2D ), intent(in) :: p2 type( Vector2D ), intent(in) :: p3 Return Value logical Subroutines private subroutine Set_Obs_COO_31 (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/calculate_observation.html"},{"title":"Calculate_LatentHeat – FTDSS","text":"Uses Types iso_fortran_env omp_lib module~~calculate_latentheat~~UsesGraph module~calculate_latentheat Calculate_LatentHeat module~types Types module~calculate_latentheat->module~types omp_lib omp_lib module~calculate_latentheat->omp_lib iso_fortran_env iso_fortran_env module~calculate_latentheat->iso_fortran_env module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~calculate_latentheat~~UsedByGraph module~calculate_latentheat Calculate_LatentHeat module~rootfinding_secantmethod RootFinding_SecantMethod module~rootfinding_secantmethod->module~calculate_latentheat module~rootfinding_binaryfinding RootFinding_BinaryFinding module~rootfinding_binaryfinding->module~calculate_latentheat module~solver_initialize Solver_Initialize module~solver_initialize->module~calculate_latentheat module~calculate_update Calculate_Update module~calculate_update->module~rootfinding_secantmethod module~calculate_update->module~rootfinding_binaryfinding module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~calculate_update Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables TtoK Functions Calc_LatentHeatTerm Calc_Ca_GCC Subroutines Find_Ca_max Variables Type Visibility Attributes Name Initial real(kind=real64), private, parameter :: TtoK = 273.15d0 Functions public function Calc_LatentHeatTerm (T, Tnew, Latent) result(res) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tnew type( LatentHeatTreatment ), intent(in) :: Latent Return Value real(kind=real64) private function Calc_Ca_GCC (Heat, T) result(Ca) Arguments Type Intent Optional Attributes Name type( HeatFields ), intent(in) :: Heat real(kind=real64), intent(in) :: T Return Value real(kind=real64) Subroutines public subroutine Find_Ca_max (Heat) Arguments Type Intent Optional Attributes Name type( HeatFields ), intent(inout) :: Heat","tags":"","loc":"module/calculate_latentheat.html"},{"title":"Calculate_GCC – FTDSS","text":"Uses iso_fortran_env module~~calculate_gcc~~UsesGraph module~calculate_gcc Calculate_GCC iso_fortran_env iso_fortran_env module~calculate_gcc->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables g TtoK Calculate_GCC_Segregation Calculate_GCC_Segregation_Derivative Interfaces Calculate_GCC_NonSegregation Calculate_GCC_NonSegregation_Derivative Abstract Interfaces Calculate_GCC_Segregation_interface Functions Calculate_GCC_NonSegregation_kPa Calculate_GCC_NonSegregation_m Calculate_GCC_NonSegregation_Derivative_kPa Calculate_GCC_NonSegregation_Derivative_m Calculate_GCC_Segregation_kPa Calculate_GCC_Segregation_m Calculate_GCC_Segregation_Derivative_kPa Calculate_GCC_Segregation_Derivative_m Subroutines Set_Calculate_GCC_Segregation Variables Type Visibility Attributes Name Initial real(kind=real64), private, parameter :: g = 9.80665d0 real(kind=real64), private, parameter :: TtoK = 273.15d0 procedure( Calculate_GCC_Segregation_interface ), public, pointer :: Calculate_GCC_Segregation => null() procedure( Calculate_GCC_Segregation_interface ), private, pointer :: Calculate_GCC_Segregation_Derivative => null() Interfaces public interface Calculate_GCC_NonSegregation private function Calculate_GCC_NonSegregation_kPa (T, Tf, Lf, rhoW) result(Suction_kPa) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW Return Value real(kind=real64) private function Calculate_GCC_NonSegregation_m (T, Tf, Lf) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf Return Value real(kind=real64) private interface Calculate_GCC_NonSegregation_Derivative private function Calculate_GCC_NonSegregation_Derivative_kPa (T, Tf, Lf, rhoW) result(Suction_kPa_Derivative) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW Return Value real(kind=real64) private function Calculate_GCC_NonSegregation_Derivative_m (T, Tf, Lf) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf Return Value real(kind=real64) Abstract Interfaces abstract interface private function Calculate_GCC_Segregation_interface(T, Pw, Tf, Lf, rhoW, rhoI) result(Suction) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Pw real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW real(kind=real64), intent(in) :: rhoI Return Value real(kind=real64) Functions private function Calculate_GCC_NonSegregation_kPa (T, Tf, Lf, rhoW) result(Suction_kPa) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW Return Value real(kind=real64) private function Calculate_GCC_NonSegregation_m (T, Tf, Lf) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf Return Value real(kind=real64) private function Calculate_GCC_NonSegregation_Derivative_kPa (T, Tf, Lf, rhoW) result(Suction_kPa_Derivative) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW Return Value real(kind=real64) private function Calculate_GCC_NonSegregation_Derivative_m (T, Tf, Lf) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf Return Value real(kind=real64) private function Calculate_GCC_Segregation_kPa (T, Pw_kPa, Tf, Lf, rhoW, rhoI) result(Suction_kPa) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Pw_kPa real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW real(kind=real64), intent(in) :: rhoI Return Value real(kind=real64) private function Calculate_GCC_Segregation_m (T, Pw_m, Tf, Lf, rhoW, rhoI) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Pw_m real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW real(kind=real64), intent(in) :: rhoI Return Value real(kind=real64) private function Calculate_GCC_Segregation_Derivative_kPa (T, Pw_kPa, Tf, Lf, rhoW, rhoI) result(Suction_kPa_Derivative) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Pw_kPa real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW real(kind=real64), intent(in) :: rhoI Return Value real(kind=real64) private function Calculate_GCC_Segregation_Derivative_m (T, Pw_m, Tf, Lf, rhoW, rhoI) result(Suction_m_Derivative) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Pw_m real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW real(kind=real64), intent(in) :: rhoI Return Value real(kind=real64) Subroutines public subroutine Set_Calculate_GCC_Segregation (Segregation_type) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: Segregation_type","tags":"","loc":"module/calculate_gcc.html"},{"title":"Calculate_Shape – FTDSS","text":"Uses error iso_fortran_env Calculate_Points Types module~~calculate_shape~~UsesGraph module~calculate_shape Calculate_Shape module~error error module~calculate_shape->module~error module~calculate_points Calculate_Points module~calculate_shape->module~calculate_points iso_fortran_env iso_fortran_env module~calculate_shape->iso_fortran_env module~types Types module~calculate_shape->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~calculate_points->module~error module~calculate_points->iso_fortran_env module~calculate_points->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces Calc_Shape Subroutines Calc_Shape_31 Interfaces public interface Calc_Shape public subroutine Calc_Shape_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry Subroutines public subroutine Calc_Shape_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry","tags":"","loc":"module/calculate_shape.html"},{"title":"Calculate_BLAS – FTDSS","text":"Uses Types iso_fortran_env omp_lib module~~calculate_blas~~UsesGraph module~calculate_blas Calculate_BLAS module~types Types module~calculate_blas->module~types omp_lib omp_lib module~calculate_blas->omp_lib iso_fortran_env iso_fortran_env module~calculate_blas->iso_fortran_env module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~calculate_blas~~UsedByGraph module~calculate_blas Calculate_BLAS module~solver_solve Solver_Solve module~solver_solve->module~calculate_blas module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~solver_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions norm_2 ddots Functions public function norm_2 (N, x) result(norm) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: x (:) Return Value real(kind=real64) public function ddots (N, x, y) result(dot) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: x (:) real(kind=real64), intent(in) :: y (:) Return Value real(kind=real64)","tags":"","loc":"module/calculate_blas.html"},{"title":"Types – FTDSS","text":"Uses iso_fortran_env module~~types~~UsesGraph module~types Types iso_fortran_env iso_fortran_env module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~types~~UsedByGraph module~types Types module~calculate_count Calculate_Count module~calculate_count->module~types module~allocate_structure Allocate_Structure module~allocate_structure->module~types module~allocate Allocate module~allocate_structure->module~allocate module~solver_precon_jacobi Solver_Precon_jacobi module~solver_precon_jacobi->module~types module~inout_stdout Inout_Stdout module~inout_stdout->module~types module~calculate_latentheat Calculate_LatentHeat module~calculate_latentheat->module~types module~calculate_product Calculate_Product module~calculate_product->module~types module~calculate_area Calculate_Area module~calculate_area->module~types module~calculate_points Calculate_Points module~calculate_area->module~calculate_points module~calculate_observation Calculate_Observation module~calculate_observation->module~types module~calculate_observation->module~allocate module~calculate_observation->module~calculate_points module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~types module~condition_fixinitialcondition->module~allocate_structure module~calculate_update Calculate_Update module~condition_fixinitialcondition->module~calculate_update module~condition_fixinitialcondition->module~allocate module~condition_fixboundarycondition Condition_FixBoundaryCondition module~condition_fixinitialcondition->module~condition_fixboundarycondition module~matrix_assemble Matrix_Assemble module~condition_fixinitialcondition->module~matrix_assemble module~solver_solve Solver_Solve module~condition_fixinitialcondition->module~solver_solve module~matrix_findind Matrix_FindInd module~matrix_findind->module~types module~calculate_update->module~types module~rootfinding_binaryfinding RootFinding_BinaryFinding module~calculate_update->module~rootfinding_binaryfinding module~rootfinding_secantmethod RootFinding_SecantMethod module~calculate_update->module~rootfinding_secantmethod module~calculate_blas Calculate_BLAS module~calculate_blas->module~types module~allocate->module~types module~inout_output Inout_Output module~inout_output->module~types module~inout_output->module~allocate module~rootfinding_binaryfinding->module~types module~rootfinding_binaryfinding->module~calculate_latentheat module~solver_initcopy Solver_InitCopy module~solver_initcopy->module~types module~matrix_convertcrs Matrix_ConvertCRS module~matrix_convertcrs->module~types module~matrix_convertcrs->module~allocate module~calculate_points->module~types module~condition_fixboundarycondition->module~types module~condition_fixboundarycondition->module~matrix_findind module~matrix_assemble->module~types module~matrix_assemble->module~allocate_structure module~matrix_assemble->module~calculate_product module~matrix_assemble->module~matrix_findind module~matrix_assemble->module~allocate module~calculate_hcf Calculate_HCF module~calculate_hcf->module~types module~rootfinding_secantmethod->module~types module~rootfinding_secantmethod->module~calculate_latentheat module~solver_solve->module~types module~solver_solve->module~allocate_structure module~solver_solve->module~solver_precon_jacobi module~solver_solve->module~calculate_product module~solver_solve->module~calculate_blas module~solver_solve->module~allocate module~calculate_trm Calculate_TRM module~calculate_trm->module~types module~solver_initialize Solver_Initialize module~solver_initialize->module~types module~solver_initialize->module~calculate_latentheat module~solver_initialize->module~allocate module~main_heat Main_Heat module~main_heat->module~types module~main_heat->module~allocate_structure module~main_heat->module~allocate module~main_heat->module~calculate_hcf module~calculate_wrf Calculate_WRF module~calculate_wrf->module~types module~calculate_shape Calculate_Shape module~calculate_shape->module~types module~calculate_shape->module~calculate_points proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->module~calculate_count Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables Temperature Pressure Stress Linear pTransition NonLinear nTransition GravityAcceleration undumped dumped Derived Types VC Vector2D Vector3D DP2d DP3d INT2d INT3d PH Phases Shape BoudaryConditionInfo BoudaryCondition Boudary_Condition_Dirichlet Boudary_Condition_Neumann Boudary_Condition InitialConditionInfo InitialCondition MPIInfo Basic_params Type_Solver Base_Solver Type_Solver_Iterative Base_Density Type_Density_3Phase Type_Density_2Phase Type_Density_1Phase Base_SpecificHeat Type_SpecificHeat_3Phase Type_SpecificHeat_2Phase Type_SpecificHeat_1Phase Base_ThermalConductivity Type_ThermalConductivity_3Phase Type_ThermalConductivity_3Phase_Dispersity_2D Type_ThermalConductivity_3Phase_Dispersity_3D Type_ThermalConductivity_2Phase Type_ThermalConductivity_1Phase Base_Ice Type_Ice_TRM Type_Ice_GCC Type_Ice_EXP Type_Thermal Type_Hydraulic Base_Impedance Type_Impedance Base_KTDynamics Type_KTDynamics Type_Region_Flags Type_Region DF Flag CRS Lis Observation2d HeatVariables HeatConstants PowerModel GCCModel WRF_Parameters Base_WRF Type_WRF_BC Type_WRF_VG Type_WRF_KO Type_WRF_MVG Type_WRF_Durner Type_WRF_DVGCH HCF_Parameters Base_HCF Type_HCF_BC Type_HCF_VG Type_HCF_KO Type_HCF_MVG Type_HCF_Durner Type_HCF_DVGCH LatentHeatTreatment HeatFields WaterVariables WaterConstants WaterFields Geometry2d Geometry_2D TimeInfo Iteration SolverInfo Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: Temperature = 1 integer(kind=int32), public, parameter :: Pressure = 2 integer(kind=int32), public, parameter :: Stress = 3 integer(kind=int32), public, parameter :: Linear = 1 integer(kind=int32), public, parameter :: pTransition = 2 integer(kind=int32), public, parameter :: NonLinear = 3 integer(kind=int32), public, parameter :: nTransition = 4 real(kind=real64), public, parameter :: GravityAcceleration = 9.80655d0 integer(kind=int32), public, parameter :: undumped = 0 integer(kind=int32), public, parameter :: dumped = 1 Derived Types type, public, sequence  :: VC Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y type, public, sequence  :: Vector2D Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y type, public, sequence  :: Vector3D Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y real(kind=real64), public :: z type, public, sequence  :: DP2d Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: x (:) real(kind=real64), public, allocatable :: y (:) type, public, sequence  :: DP3d Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: x (:) real(kind=real64), public, allocatable :: y (:) real(kind=real64), public, allocatable :: z (:) type, public, sequence  :: INT2d Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: x (:) integer(kind=int32), public, allocatable :: y (:) type, public, sequence  :: INT3d Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: x (:) integer(kind=int32), public, allocatable :: y (:) integer(kind=int32), public, allocatable :: z (:) type, public, sequence  :: PH Components Type Visibility Attributes Name Initial real(kind=real64), public :: soil real(kind=real64), public :: water real(kind=real64), public :: ice type, public, sequence  :: Phases Components Type Visibility Attributes Name Initial real(kind=real64), public :: soil real(kind=real64), public :: water real(kind=real64), public :: ice type, public, sequence  :: Shape Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: a (:,:) real(kind=real64), public, allocatable :: b (:,:) real(kind=real64), public, allocatable :: c (:,:) real(kind=real64), public, allocatable :: d (:,:) type, public :: BoudaryConditionInfo Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: Node (:) integer(kind=int32), public, allocatable :: TypeKey (:) integer(kind=int32), public, allocatable :: type (:) real(kind=real64), public, allocatable :: value (:) type( INT2d ), public :: Edges integer(kind=int32), public, allocatable :: EdgesDirection (:) real(kind=real64), public, allocatable :: EdgesDistance (:) type, public :: BoudaryCondition Components Type Visibility Attributes Name Initial type( BoudaryConditionInfo ), public :: Heat type( BoudaryConditionInfo ), public :: Water type( BoudaryConditionInfo ), public :: Stress integer(kind=int32), public :: numNode integer(kind=int32), public :: numType integer(kind=int32), public :: numEdges type, public :: Boudary_Condition_Dirichlet Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Node integer(kind=int32), public :: Num_Type integer(kind=int32), public, allocatable :: Node (:) integer(kind=int32), public, allocatable :: Node_Type (:) integer(kind=int32), public, allocatable :: Value_Info (:) real(kind=real64), public, allocatable :: value (:) type, public :: Boudary_Condition_Neumann Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Edge integer(kind=int32), public :: Num_Edge_Type integer(kind=int32), public :: Num_Type integer(kind=int32), public, allocatable :: Edge (:,:) integer(kind=int32), public, allocatable :: Edge_Type (:) integer(kind=int32), public, allocatable :: Value_Info (:) real(kind=real64), public, allocatable :: value (:) real(kind=real64), public, allocatable :: Heat_Transfer (:) type, public :: Boudary_Condition Components Type Visibility Attributes Name Initial type( Boudary_Condition_Dirichlet ), public :: Dirichlet type( Boudary_Condition_Neumann ), public :: Neumann type, public :: InitialConditionInfo Components Type Visibility Attributes Name Initial integer(kind=int32), public :: type real(kind=real64), public :: value logical, public :: isSet type, public :: InitialCondition Components Type Visibility Attributes Name Initial type( InitialConditionInfo ), public :: Heat type( InitialConditionInfo ), public :: Water type( InitialConditionInfo ), public :: Stress type, public :: MPIInfo Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size integer(kind=int32), public :: rank type, public :: Basic_params Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Element integer(kind=int32), public :: Node integer(kind=int32), public :: Shape integer(kind=int32), public :: Dim integer(kind=int32), public :: Region character, public, allocatable :: Calculation_timeUnit character, public, allocatable :: Input_timeUnit character, public, allocatable :: Output_timeUnit character, public, allocatable :: Interval_timeUnit integer(kind=int32), public :: Calculation_step integer(kind=int32), public :: CalculationPeriod integer(kind=int32), public :: Interval logical, public :: isDisplayPrompt character, public, allocatable :: FileOutput real(kind=real64), public :: TimeDiscretization type, public :: Type_Solver Components Type Visibility Attributes Name Initial class( Base_Solver ), public, allocatable :: Thermal class( Base_Solver ), public, allocatable :: Hydraulic type, public :: Base_Solver Components Type Visibility Attributes Name Initial integer(kind=int32), public :: useSolver type, public, extends( Base_Solver ) :: Type_Solver_Iterative Components Type Visibility Attributes Name Initial integer(kind=int32), public :: useSolver integer(kind=int32), public :: SolverType integer(kind=int32), public :: PreconditionerType integer(kind=int32), public :: MaxIter real(kind=real64), public :: Tol type, public :: Base_Density type, public, extends( Base_Density ) :: Type_Density_3Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type, public, extends( Base_Density ) :: Type_Density_2Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2 type, public, extends( Base_Density ) :: Type_Density_1Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 type, public :: Base_SpecificHeat type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_3Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_2Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2 type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_1Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 type, public :: Base_ThermalConductivity type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_3Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type, public, extends( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_2D Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type( Vector2D ), public :: dispersity type, public, extends( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_3D Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type( Vector3D ), public :: dispersity type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_2Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2 type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_1Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 type, public :: Base_Ice Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat type, public, extends( Base_Ice ) :: Type_Ice_TRM Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf type, public, extends( Base_Ice ) :: Type_Ice_GCC Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf integer(kind=int32), public :: ModelType class( Base_WRF ), public, allocatable :: WRF type, public, extends( Base_Ice ) :: Type_Ice_EXP Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf real(kind=real64), public :: a type, public :: Type_Thermal Components Type Visibility Attributes Name Initial class( Base_Density ), public, allocatable :: Density class( Base_SpecificHeat ), public, allocatable :: SpecificHeat class( Base_ThermalConductivity ), public, allocatable :: ThermalConductivity real(kind=real64), public :: Porosity class( Base_Ice ), public, allocatable :: Ice type, public :: Type_Hydraulic Components Type Visibility Attributes Name Initial integer(kind=int32), public :: useHCF class( Base_HCF ), public, allocatable :: HCF logical, public :: useImpedance class( Base_Impedance ), public, allocatable :: Impedance integer(kind=int32), public :: useKTDynamics class( Base_KTDynamics ), public, allocatable :: KTDynamics real(kind=real64), public :: Ks type, public :: Base_Impedance type, public, extends( Base_Impedance ) :: Type_Impedance Components Type Visibility Attributes Name Initial real(kind=real64), public :: Omega type, public :: Base_KTDynamics type, public, extends( Base_KTDynamics ) :: Type_KTDynamics Components Type Visibility Attributes Name Initial real(kind=real64), public :: kzero type, public :: Type_Region_Flags Components Type Visibility Attributes Name Initial logical, public :: isHeat logical, public :: isWater logical, public :: isStress logical, public :: is1Phase logical, public :: is2Phase logical, public :: is3Phase logical, public :: isCompression logical, public :: isFrostHeavePressure logical, public :: isDispersity logical, public :: isFrozen type, public :: Type_Region Components Type Visibility Attributes Name Initial integer(kind=int32), public :: CalculationType integer(kind=int32), public :: Modelnumber type( Type_Thermal ), public :: Thermal type( Type_Hydraulic ), public :: Hydraulic type( Type_Region_Flags ), public :: Flags type, public :: DF Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: new (:) real(kind=real64), public, allocatable :: old (:) real(kind=real64), public, allocatable :: pre (:) real(kind=real64), public, allocatable :: dif (:) real(kind=real64), public, allocatable :: div (:) real(kind=real64), public, allocatable :: tmp (:) type, public :: Flag Components Type Visibility Attributes Name Initial logical, public :: isTRM logical, public :: isGCC logical, public :: isPower logical, public :: isSwitchTRM logical, public :: isSwitchOnceTRM logical, public :: isStdOut logical, public :: isOutputAll logical, public :: isOutput logical, public :: isPrintLisMem logical, public, allocatable :: outOBS (:) type, public :: CRS Components Type Visibility Attributes Name Initial integer(kind=int32), public :: nnz integer(kind=int32), public, allocatable :: Ptr (:) integer(kind=int32), public, allocatable :: Ind (:) real(kind=real64), public, allocatable :: Val (:) type, public :: Lis Components Type Visibility Attributes Name Initial integer(kind=int32), public :: TSolver integer(kind=int32), public :: TOption integer(kind=int32), public :: PSolver integer(kind=int32), public :: POption integer(kind=int32), public :: Maxiter real(kind=real64), public :: Tol logical, public :: isOMP type, public :: Observation2d Components Type Visibility Attributes Name Initial integer(kind=int32), public :: nObs integer(kind=int32), public :: nObsType integer(kind=int32), public, allocatable :: obsPoint (:) type( DP2d ), public :: obsCOO integer(kind=int32), public, allocatable :: nAreaObs (:) real(kind=real64), public, allocatable :: vAreaObs (:,:) type, public :: HeatVariables Components Type Visibility Attributes Name Initial type( DF ), public :: Cs type( DF ), public :: Cp type( DF ), public :: lambda type( DF ), public :: rho type( DF ), public :: Ca type( DP2d ), public :: Tgrad type( DP2d ), public :: TFlux integer(kind=int32), public, allocatable :: Phase (:) type, public :: HeatConstants Components Type Visibility Attributes Name Initial type( Phases ), public :: Density type( Phases ), public :: ThermalConductivity type( Phases ), public :: SpecificHeat type( Phases ), public :: HeatCapacity type( Vector2D ), public :: dispersity real(kind=real64), public :: Porosity real(kind=real64), public :: LatentHeat type, public :: PowerModel Components Type Visibility Attributes Name Initial real(kind=real64), public :: phi real(kind=real64), public :: Tf real(kind=real64), public :: a real(kind=real64), public :: Ca_max type, public :: GCCModel Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha real(kind=real64), public :: n real(kind=real64), public :: m real(kind=real64), public :: Tf real(kind=real64), public :: Ca_max type, public :: WRF_Parameters Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 type, public :: Base_WRF Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR type, public, extends( Base_WRF ) :: Type_WRF_BC Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 type, public, extends( Base_WRF ) :: Type_WRF_VG Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 type, public, extends( Base_WRF ) :: Type_WRF_KO Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 type, public, extends( Base_WRF ) :: Type_WRF_MVG Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: hcrit type, public, extends( Base_WRF ) :: Type_WRF_Durner Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2 type, public, extends( Base_WRF ) :: Type_WRF_DVGCH Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2 type, public :: HCF_Parameters Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: Ks real(kind=real64), public :: kzero real(kind=real64), public :: l real(kind=real64), public :: Omega type, public :: Base_HCF Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR type, public, extends( Base_HCF ) :: Type_HCF_BC Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: l type, public, extends( Base_HCF ) :: Type_HCF_VG Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: l type, public, extends( Base_HCF ) :: Type_HCF_KO Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 type, public, extends( Base_HCF ) :: Type_HCF_MVG Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: hcrit real(kind=real64), public :: l type, public, extends( Base_HCF ) :: Type_HCF_Durner Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: l type, public, extends( Base_HCF ) :: Type_HCF_DVGCH Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: l type, public :: LatentHeatTreatment Components Type Visibility Attributes Name Initial integer(kind=int32), public :: useModel real(kind=real64), public :: Lf real(kind=real64), public :: rhoI real(kind=real64), public :: Cp_unf type( GCCModel ), public :: GCC type( PowerModel ), public :: Power type, public :: HeatFields Components Type Visibility Attributes Name Initial type( HeatVariables ), public :: Variables type( HeatConstants ), public :: Constants type( LatentHeatTreatment ), public :: Latent type( CRS ), public :: LHS_A real(kind=real64), public, allocatable :: RA (:,:) real(kind=real64), public, allocatable :: Rhs (:) type, public :: WaterVariables Components Type Visibility Attributes Name Initial type( DF ), public :: Klh type( DP2d ), public :: wFlux type( DP2d ), public :: hGrad type, public :: WaterConstants Components Type Visibility Attributes Name Initial type( Phases ), public :: HydraulicConductivity real(kind=real64), public :: zeta type, public :: WaterFields Components Type Visibility Attributes Name Initial type( WaterVariables ), public :: Variables type( WaterConstants ), public :: Constants type( CRS ), public :: LHS_A real(kind=real64), public, allocatable :: RA (:,:) real(kind=real64), public, allocatable :: Rhs (:) type, public :: Geometry2d Components Type Visibility Attributes Name Initial integer(kind=int32), public :: element integer(kind=int32), public :: node integer(kind=int32), public :: shape integer(kind=int32), public :: dim integer(kind=int32), public :: ShCoe integer(kind=int32), public, allocatable :: pElement (:,:) type( DP2d ), public :: vCood real(kind=real64), public, allocatable :: eArea (:) type( Shape ), public :: Basis type, public :: Geometry_2D Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Elements integer(kind=int32), public :: Num_Nodes integer(kind=int32), public :: Num_Shape integer(kind=int32), public :: Num_Dimention integer(kind=int32), public :: Num_Shape_Type integer(kind=int32), public :: Num_Region integer(kind=int32), public, allocatable :: Element (:,:) integer(kind=int32), public, allocatable :: Element_Region (:) integer(kind=int32), public, allocatable :: COO_Region (:) type( DP2d ), public :: Nodes_2D real(kind=real64), public, allocatable :: Area (:) type( Shape ), public :: Shape_Function type, public :: TimeInfo Components Type Visibility Attributes Name Initial character(len=3), public :: tUnit real(kind=real64), public :: cTime real(kind=real64), public :: cdt real(kind=real64), public :: cinterval real(kind=real64), public :: ts real(kind=real64), public :: te real(kind=real64), public :: max_dt real(kind=real64), public :: min_dt real(kind=real64), public :: tconv real(kind=real64), public, pointer :: tst real(kind=real64), public, pointer :: dt real(kind=real64), public, pointer :: odt type, public :: Iteration Components Type Visibility Attributes Name Initial integer(kind=int32), public :: itermax integer(kind=int32), public :: iNLmax integer(kind=int32), public :: iNI integer(kind=int32), public, pointer :: iter integer(kind=int32), public, pointer :: titer integer(kind=int32), public, pointer :: iNL integer(kind=int32), public :: digits_itermax type, public :: SolverInfo Components Type Visibility Attributes Name Initial type( Geometry2d ), public :: N logical, public :: isHeat logical, public :: isWater logical, public :: isStress integer(kind=int32), public :: nAnalysis integer(kind=int32), public :: nFrTreat integer(kind=int32), public :: nTimeDisc integer(kind=int32), public :: isStdOut integer(kind=int32), public :: outputFile type( TimeInfo ), public :: Time type( Iteration ), public :: Iter type( Observation2d ), public :: Obs type( HeatFields ), public :: Heat type( WaterFields ), public :: Water type( BoudaryCondition ), public :: BC type( InitialCondition ), public :: IC type( DF ), public :: mWater type( DF ), public :: mIce type( DF ), public :: T type( DF ), public :: P type( DF ), public :: Si type( DF ), public :: Sw type( Lis ), public :: Lis type( Flag ), public :: Flags character(len=64), public :: fmt_Stdout character(len=64), public :: fmt_Fileout type( MPIInfo ), public :: MPI","tags":"","loc":"module/types.html"},{"title":"Solver_Solve – FTDSS","text":"Uses Solver_Precon_jacobi Calculate_BLAS Types Allocate_Structure Allocate iso_fortran_env error omp_lib Calculate_Product module~~solver_solve~~UsesGraph module~solver_solve Solver_Solve module~solver_precon_jacobi Solver_Precon_jacobi module~solver_solve->module~solver_precon_jacobi module~allocate_structure Allocate_Structure module~solver_solve->module~allocate_structure module~calculate_blas Calculate_BLAS module~solver_solve->module~calculate_blas omp_lib omp_lib module~solver_solve->omp_lib module~types Types module~solver_solve->module~types module~allocate Allocate module~solver_solve->module~allocate iso_fortran_env iso_fortran_env module~solver_solve->iso_fortran_env module~error error module~solver_solve->module~error module~calculate_product Calculate_Product module~solver_solve->module~calculate_product module~solver_precon_jacobi->omp_lib module~solver_precon_jacobi->module~types module~solver_precon_jacobi->iso_fortran_env module~allocate_structure->module~types module~allocate_structure->module~allocate module~allocate_structure->iso_fortran_env module~allocate_structure->module~error module~calculate_blas->omp_lib module~calculate_blas->module~types module~calculate_blas->iso_fortran_env module~types->iso_fortran_env module~allocate->module~types module~allocate->iso_fortran_env module~allocate->module~error module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~calculate_product->omp_lib module~calculate_product->module~types module~calculate_product->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~solver_solve~~UsedByGraph module~solver_solve Solver_Solve module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~solver_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables CRS_A work Interfaces ILS DLS Derived Types ILS DLS Functions Solve_Initialize_BiCGStab Solve_Initialize_LU Subroutines Solver_BiCGStab Solver_Check_Error ILS_Destructor Solver_LU Variables Type Visibility Attributes Name Initial type( CRS ), private :: CRS_A real(kind=real64), private, allocatable, target :: work (:,:) Interfaces public interface ILS private function Solve_Initialize_BiCGStab (Solver, MCRS) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(in) :: MCRS Return Value type( ILS ) public interface DLS private function Solve_Initialize_LU (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ) :: Solver Return Value type( DLS ) Derived Types type, public :: ILS Components Type Visibility Attributes Name Initial type( CRS ), private :: CRS_A real(kind=real64), private, dimension(:), pointer :: M real(kind=real64), private, dimension(:), pointer :: p real(kind=real64), private, dimension(:), pointer :: phat real(kind=real64), private, dimension(:), pointer :: s real(kind=real64), private, dimension(:), pointer :: shat real(kind=real64), private, dimension(:), pointer :: r real(kind=real64), private, dimension(:), pointer :: r0 real(kind=real64), private, dimension(:), pointer :: t real(kind=real64), private, dimension(:), pointer :: v real(kind=real64), private, dimension(:), pointer :: x real(kind=real64), private, dimension(:), pointer :: b Constructor private  function Solve_Initialize_BiCGStab (Solver, MCRS) Finalizations Procedures final :: ILS_Destructor Type-Bound Procedures procedure, public :: BiCGStab => Solver_BiCGStab procedure, public :: Chkerr => Solver_Check_Error type, public :: DLS Components Type Visibility Attributes Name Initial integer(kind=int32), private :: N Constructor private  function Solve_Initialize_LU (Solver) Type-Bound Procedures procedure, public :: LU => Solver_LU Functions private function Solve_Initialize_BiCGStab (Solver, MCRS) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(in) :: MCRS Return Value type( ILS ) private function Solve_Initialize_LU (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ) :: Solver Return Value type( DLS ) Subroutines private subroutine Solver_BiCGStab (self, Solver, BiCG_A, BiCG_b, BiCG_x, status) Arguments Type Intent Optional Attributes Name class( ILS ) :: self type( SolverInfo ), intent(inout) :: Solver type( CRS ), intent(in) :: BiCG_A real(kind=real64), intent(in) :: BiCG_b (:) real(kind=real64), intent(inout) :: BiCG_x (:) integer(kind=int32), intent(inout) :: status private subroutine Solver_Check_Error (self, ierr, time) Arguments Type Intent Optional Attributes Name class( ILS ) :: self integer(kind=int32), intent(in) :: ierr real(kind=real64), intent(in) :: time private subroutine ILS_Destructor (self) Arguments Type Intent Optional Attributes Name type( ILS ) :: self private subroutine Solver_LU (self, LU_A, LU_b, LU_x) Arguments Type Intent Optional Attributes Name class( DLS ) :: self real(kind=real64), intent(inout) :: LU_A (:,:) real(kind=real64), intent(inout) :: LU_b (:) real(kind=real64), intent(inout) :: LU_x (:)","tags":"","loc":"module/solver_solve.html"},{"title":"error – FTDSS","text":"Uses ieee_arithmetic iso_fortran_env module~~error~~UsesGraph module~error error ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic iso_fortran_env iso_fortran_env module~error->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~error~~UsedByGraph module~error error module~calculate_count Calculate_Count module~calculate_count->module~error module~allocate_structure Allocate_Structure module~allocate_structure->module~error module~allocate Allocate module~allocate_structure->module~allocate module~inout_setprojectpath Inout_SetProjectPath module~inout_setprojectpath->module~error module~calculate_points Calculate_Points module~calculate_points->module~error module~allocate->module~error module~matrix_assemble Matrix_Assemble module~matrix_assemble->module~error module~matrix_assemble->module~allocate_structure module~matrix_assemble->module~allocate module~inout_output Inout_Output module~inout_output->module~error module~inout_output->module~inout_setprojectpath module~inout_output->module~allocate module~calculate_area Calculate_Area module~calculate_area->module~error module~calculate_area->module~calculate_points module~calculate_shape Calculate_Shape module~calculate_shape->module~error module~calculate_shape->module~calculate_points module~solver_solve Solver_Solve module~solver_solve->module~error module~solver_solve->module~allocate_structure module~solver_solve->module~allocate module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~error module~condition_fixinitialcondition->module~allocate_structure module~condition_fixinitialcondition->module~allocate module~condition_fixinitialcondition->module~matrix_assemble module~condition_fixinitialcondition->module~solver_solve module~solver_initialize Solver_Initialize module~solver_initialize->module~allocate module~matrix_convertcrs Matrix_ConvertCRS module~matrix_convertcrs->module~allocate proc~set_boundary_condition_infomations Set_Boundary_Condition_Infomations proc~set_boundary_condition_infomations->module~calculate_count module~main_heat Main_Heat module~main_heat->module~allocate_structure module~main_heat->module~allocate module~calculate_observation Calculate_Observation module~calculate_observation->module~calculate_points module~calculate_observation->module~allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces has_nan value_in_range Functions has_nan_real64_scalar has_nan_real64_rank1 has_nan_real64_rank2 value_in_range_int32 value_in_range_real64 Subroutines error_message Interfaces public interface has_nan private function has_nan_real64_scalar (scalar) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar Return Value logical private function has_nan_real64_rank1 (array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Return Value logical private function has_nan_real64_rank2 (array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:,:) Return Value logical public interface value_in_range private function value_in_range_int32 (value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max Return Value logical private function value_in_range_real64 (value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: value real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max Return Value logical Functions private function has_nan_real64_scalar (scalar) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar Return Value logical private function has_nan_real64_rank1 (array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Return Value logical private function has_nan_real64_rank2 (array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:,:) Return Value logical private function value_in_range_int32 (value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max Return Value logical private function value_in_range_real64 (value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: value real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max Return Value logical Subroutines public subroutine error_message (err_number, myrank, opt, opt_file_name, copt1, copt2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: err_number integer(kind=int32), intent(in), optional :: myrank real(kind=real64), intent(in), optional :: opt character, intent(in), optional :: opt_file_name character, intent(in), optional :: copt1 character, intent(in), optional :: copt2","tags":"","loc":"module/error.html"},{"title":"Solver_Precon_jacobi – FTDSS","text":"Uses Types iso_fortran_env omp_lib module~~solver_precon_jacobi~~UsesGraph module~solver_precon_jacobi Solver_Precon_jacobi module~types Types module~solver_precon_jacobi->module~types omp_lib omp_lib module~solver_precon_jacobi->omp_lib iso_fortran_env iso_fortran_env module~solver_precon_jacobi->iso_fortran_env module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~solver_precon_jacobi~~UsedByGraph module~solver_precon_jacobi Solver_Precon_jacobi module~solver_solve Solver_Solve module~solver_solve->module~solver_precon_jacobi module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~solver_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines Create_Precond_Jacobi Apply_Precond_Jacobi Subroutines public subroutine Create_Precond_Jacobi (N, A, M) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N type( CRS ), intent(in) :: A real(kind=real64), intent(inout) :: M (:) public subroutine Apply_Precond_Jacobi (N, M, r, z) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: M (:) real(kind=real64), intent(in) :: r (:) real(kind=real64), intent(inout) :: z (:)","tags":"","loc":"module/solver_precon_jacobi.html"},{"title":"Solver_InitCopy – FTDSS","text":"Uses iso_fortran_env Types module~~solver_initcopy~~UsesGraph module~solver_initcopy Solver_InitCopy iso_fortran_env iso_fortran_env module~solver_initcopy->iso_fortran_env module~types Types module~solver_initcopy->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines Init_Copy_Temperature Init_Copy_Pressure Subroutines public subroutine Init_Copy_Temperature (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Init_Copy_Pressure (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/solver_initcopy.html"},{"title":"Solver_Initialize – FTDSS","text":"Uses Calculate_LatentHeat Allocate iso_fortran_env Types module~~solver_initialize~~UsesGraph module~solver_initialize Solver_Initialize module~calculate_latentheat Calculate_LatentHeat module~solver_initialize->module~calculate_latentheat module~allocate Allocate module~solver_initialize->module~allocate iso_fortran_env iso_fortran_env module~solver_initialize->iso_fortran_env module~types Types module~solver_initialize->module~types module~calculate_latentheat->iso_fortran_env module~calculate_latentheat->module~types omp_lib omp_lib module~calculate_latentheat->omp_lib module~allocate->iso_fortran_env module~allocate->module~types module~error error module~allocate->module~error module~types->iso_fortran_env module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions Convert_TimeUnit Subroutines Initialize_Solver Functions private function Convert_TimeUnit (Time, num) result(conv_time) Arguments Type Intent Optional Attributes Name type( TimeInfo ), intent(in) :: Time integer(kind=int32), intent(in) :: num Return Value real(kind=real64) Subroutines public subroutine Initialize_Solver (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/solver_initialize.html"},{"title":"RootFinding_BinaryFinding – FTDSS","text":"Uses Calculate_LatentHeat ieee_arithmetic iso_fortran_env Types module~~rootfinding_binaryfinding~~UsesGraph module~rootfinding_binaryfinding RootFinding_BinaryFinding module~calculate_latentheat Calculate_LatentHeat module~rootfinding_binaryfinding->module~calculate_latentheat ieee_arithmetic ieee_arithmetic module~rootfinding_binaryfinding->ieee_arithmetic iso_fortran_env iso_fortran_env module~rootfinding_binaryfinding->iso_fortran_env module~types Types module~rootfinding_binaryfinding->module~types module~calculate_latentheat->iso_fortran_env module~calculate_latentheat->module~types omp_lib omp_lib module~calculate_latentheat->omp_lib module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~rootfinding_binaryfinding~~UsedByGraph module~rootfinding_binaryfinding RootFinding_BinaryFinding module~calculate_update Calculate_Update module~calculate_update->module~rootfinding_binaryfinding module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~calculate_update Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables eps max_iter Subroutines Binary_finding Variables Type Visibility Attributes Name Initial real(kind=real64), private, parameter :: eps = 1.0d-10 integer(kind=int32), private, parameter :: max_iter = 100 Subroutines public subroutine Binary_finding (Solver, ind) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: ind","tags":"","loc":"module/rootfinding_binaryfinding.html"},{"title":"RootFinding_SecantMethod – FTDSS","text":"Uses Calculate_LatentHeat ieee_arithmetic iso_fortran_env Types module~~rootfinding_secantmethod~~UsesGraph module~rootfinding_secantmethod RootFinding_SecantMethod module~calculate_latentheat Calculate_LatentHeat module~rootfinding_secantmethod->module~calculate_latentheat ieee_arithmetic ieee_arithmetic module~rootfinding_secantmethod->ieee_arithmetic iso_fortran_env iso_fortran_env module~rootfinding_secantmethod->iso_fortran_env module~types Types module~rootfinding_secantmethod->module~types module~calculate_latentheat->iso_fortran_env module~calculate_latentheat->module~types omp_lib omp_lib module~calculate_latentheat->omp_lib module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~rootfinding_secantmethod~~UsedByGraph module~rootfinding_secantmethod RootFinding_SecantMethod module~calculate_update Calculate_Update module~calculate_update->module~rootfinding_secantmethod module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~calculate_update Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables eps max_iter Subroutines Secant_method Variables Type Visibility Attributes Name Initial real(kind=real64), private, parameter :: eps = 1.0d-10 integer(kind=int32), private, parameter :: max_iter = 100 Subroutines public subroutine Secant_method (Solver, ind) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: ind","tags":"","loc":"module/rootfinding_secantmethod.html"},{"title":"Allocate_Structure – FTDSS","text":"Uses error iso_fortran_env Allocate Types module~~allocate_structure~~UsesGraph module~allocate_structure Allocate_Structure module~error error module~allocate_structure->module~error module~allocate Allocate module~allocate_structure->module~allocate iso_fortran_env iso_fortran_env module~allocate_structure->iso_fortran_env module~types Types module~allocate_structure->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~allocate->module~error module~allocate->iso_fortran_env module~allocate->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~allocate_structure~~UsedByGraph module~allocate_structure Allocate_Structure module~matrix_assemble Matrix_Assemble module~matrix_assemble->module~allocate_structure module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~allocate_structure module~condition_fixinitialcondition->module~matrix_assemble module~solver_solve Solver_Solve module~condition_fixinitialcondition->module~solver_solve module~main_heat Main_Heat module~main_heat->module~allocate_structure module~solver_solve->module~allocate_structure Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines Allocate_DF Allocate_DP2d Allocate_INT2d Allocate_BCinfo Allocate_Solver Allocate_Structure_Thermal_Type Allocate_Structure_Ice_Type Allocate_Structure_WRF_Type Allocate_Structure_Hydraulic_Type Allocate_Structure_HCF_Type Subroutines public subroutine Allocate_DF (ar_DF, n) Arguments Type Intent Optional Attributes Name type( DF ), intent(inout) :: ar_DF integer(kind=int32), intent(in) :: n public subroutine Allocate_DP2d (ar_DP2d, n) Arguments Type Intent Optional Attributes Name type( DP2d ), intent(inout) :: ar_DP2d integer(kind=int32), intent(in) :: n private subroutine Allocate_INT2d (ar_INT2d, n) Arguments Type Intent Optional Attributes Name type( INT2d ), intent(inout) :: ar_INT2d integer(kind=int32), intent(in) :: n public subroutine Allocate_BCinfo (BCinfo, nNode, nType, nEdge) Arguments Type Intent Optional Attributes Name type( BoudaryConditionInfo ), intent(inout) :: BCinfo integer(kind=int32), intent(in) :: nNode integer(kind=int32), intent(in) :: nType integer(kind=int32), intent(in), optional :: nEdge public subroutine Allocate_Solver (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Allocate_Structure_Thermal_Type (Structure_Thermal, Flags) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal type( Type_Region_Flags ), intent(in) :: Flags public subroutine Allocate_Structure_Ice_Type (Structure_Thermal, QiceModelType) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal integer(kind=int32), intent(in) :: QiceModelType public subroutine Allocate_Structure_WRF_Type (Structure_Thermal, WRFModelType) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal integer(kind=int32), intent(in) :: WRFModelType public subroutine Allocate_Structure_Hydraulic_Type (Structure_Hydraulic) Arguments Type Intent Optional Attributes Name type( Type_Hydraulic ), intent(inout) :: Structure_Hydraulic private subroutine Allocate_Structure_HCF_Type (Structure_Hydraulic) Arguments Type Intent Optional Attributes Name type( Type_Hydraulic ), intent(inout) :: Structure_Hydraulic","tags":"","loc":"module/allocate_structure.html"},{"title":"Allocate – FTDSS","text":"Uses error iso_fortran_env Types module~~allocate~~UsesGraph module~allocate Allocate module~error error module~allocate->module~error iso_fortran_env iso_fortran_env module~allocate->iso_fortran_env module~types Types module~allocate->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~allocate~~UsedByGraph module~allocate Allocate module~allocate_structure Allocate_Structure module~allocate_structure->module~allocate module~solver_initialize Solver_Initialize module~solver_initialize->module~allocate module~matrix_convertcrs Matrix_ConvertCRS module~matrix_convertcrs->module~allocate module~main_heat Main_Heat module~main_heat->module~allocate module~main_heat->module~allocate_structure module~inout_output Inout_Output module~inout_output->module~allocate module~matrix_assemble Matrix_Assemble module~matrix_assemble->module~allocate module~matrix_assemble->module~allocate_structure module~calculate_observation Calculate_Observation module~calculate_observation->module~allocate module~solver_solve Solver_Solve module~solver_solve->module~allocate module~solver_solve->module~allocate_structure module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~allocate module~condition_fixinitialcondition->module~allocate_structure module~condition_fixinitialcondition->module~matrix_assemble module~condition_fixinitialcondition->module~solver_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces Allocate_Vector Allocate_Matrix Allocate_Pointer Subroutines Check_Allocate_rank1_int32 Check_Allocate_rank1_real64 Check_Allocate_rank1_logical Check_Allocate_rank1_int32_specify Check_Allocate_rank1_real64_specify Check_Allocate_rank2_int32 Check_Allocate_rank2_real64 Check_Allocate_Pointer_int32 Check_Allocate_Pointer_real64 Duplicate_CRS Interfaces public interface Allocate_Vector private subroutine Check_Allocate_rank1_int32 (iar, ar_size) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_real64 (dar, ar_size) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_logical (lar, ar_size) Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: lar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_int32_specify (iar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last private subroutine Check_Allocate_rank1_real64_specify (dar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last public interface Allocate_Matrix private subroutine Check_Allocate_rank2_int32 (imt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: imt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2 private subroutine Check_Allocate_rank2_real64 (dmt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dmt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2 public interface Allocate_Pointer private subroutine Check_Allocate_Pointer_real64 (dptr) Arguments Type Intent Optional Attributes Name real(kind=real64), pointer :: dptr private subroutine Check_Allocate_Pointer_int32 (iptr) Arguments Type Intent Optional Attributes Name integer(kind=int32), pointer :: iptr Subroutines private subroutine Check_Allocate_rank1_int32 (iar, ar_size) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_real64 (dar, ar_size) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_logical (lar, ar_size) Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: lar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_int32_specify (iar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last private subroutine Check_Allocate_rank1_real64_specify (dar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last private subroutine Check_Allocate_rank2_int32 (imt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: imt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2 private subroutine Check_Allocate_rank2_real64 (dmt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dmt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2 private subroutine Check_Allocate_Pointer_int32 (iptr) Arguments Type Intent Optional Attributes Name integer(kind=int32), pointer :: iptr private subroutine Check_Allocate_Pointer_real64 (dptr) Arguments Type Intent Optional Attributes Name real(kind=real64), pointer :: dptr public subroutine Duplicate_CRS (A, B) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A type( CRS ), intent(inout) :: B","tags":"","loc":"module/allocate.html"},{"title":"Condition_FixInitialCondition – FTDSS","text":"Uses Types Condition_FixBoundaryCondition Allocate_Structure Matrix_Assemble Allocate iso_fortran_env Solver_Solve error Calculate_Update module~~condition_fixinitialcondition~~UsesGraph module~condition_fixinitialcondition Condition_FixInitialCondition module~types Types module~condition_fixinitialcondition->module~types module~allocate_structure Allocate_Structure module~condition_fixinitialcondition->module~allocate_structure module~condition_fixboundarycondition Condition_FixBoundaryCondition module~condition_fixinitialcondition->module~condition_fixboundarycondition module~calculate_update Calculate_Update module~condition_fixinitialcondition->module~calculate_update module~allocate Allocate module~condition_fixinitialcondition->module~allocate module~matrix_assemble Matrix_Assemble module~condition_fixinitialcondition->module~matrix_assemble iso_fortran_env iso_fortran_env module~condition_fixinitialcondition->iso_fortran_env module~solver_solve Solver_Solve module~condition_fixinitialcondition->module~solver_solve module~error error module~condition_fixinitialcondition->module~error module~types->iso_fortran_env module~allocate_structure->module~types module~allocate_structure->module~allocate module~allocate_structure->iso_fortran_env module~allocate_structure->module~error module~condition_fixboundarycondition->module~types module~condition_fixboundarycondition->iso_fortran_env module~matrix_findind Matrix_FindInd module~condition_fixboundarycondition->module~matrix_findind module~calculate_update->module~types module~calculate_update->iso_fortran_env omp_lib omp_lib module~calculate_update->omp_lib module~rootfinding_binaryfinding RootFinding_BinaryFinding module~calculate_update->module~rootfinding_binaryfinding module~rootfinding_secantmethod RootFinding_SecantMethod module~calculate_update->module~rootfinding_secantmethod module~allocate->module~types module~allocate->iso_fortran_env module~allocate->module~error module~matrix_assemble->module~types module~matrix_assemble->module~allocate_structure module~matrix_assemble->module~allocate module~matrix_assemble->iso_fortran_env module~matrix_assemble->module~error module~matrix_assemble->module~matrix_findind module~matrix_assemble->omp_lib module~calculate_product Calculate_Product module~matrix_assemble->module~calculate_product module~solver_solve->module~types module~solver_solve->module~allocate_structure module~solver_solve->module~allocate module~solver_solve->iso_fortran_env module~solver_solve->module~error module~solver_solve->omp_lib module~solver_precon_jacobi Solver_Precon_jacobi module~solver_solve->module~solver_precon_jacobi module~calculate_blas Calculate_BLAS module~solver_solve->module~calculate_blas module~solver_solve->module~calculate_product module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~matrix_findind->module~types module~matrix_findind->iso_fortran_env module~solver_precon_jacobi->module~types module~solver_precon_jacobi->iso_fortran_env module~solver_precon_jacobi->omp_lib module~calculate_blas->module~types module~calculate_blas->iso_fortran_env module~calculate_blas->omp_lib module~rootfinding_binaryfinding->module~types module~rootfinding_binaryfinding->iso_fortran_env module~rootfinding_binaryfinding->ieee_arithmetic module~calculate_latentheat Calculate_LatentHeat module~rootfinding_binaryfinding->module~calculate_latentheat module~calculate_product->module~types module~calculate_product->iso_fortran_env module~calculate_product->omp_lib module~rootfinding_secantmethod->module~types module~rootfinding_secantmethod->iso_fortran_env module~rootfinding_secantmethod->ieee_arithmetic module~rootfinding_secantmethod->module~calculate_latentheat module~calculate_latentheat->module~types module~calculate_latentheat->iso_fortran_env module~calculate_latentheat->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines Fix_InitialCondition Fix_InitialCondtion_Constant_Heat Fix_InitialCondtion_Constant_Water Fix_InitialCondition_Gradient_Heat Fix_InitialCondition_Gradient_Water Fix_InitialCondition_FreezingRate Subroutines public subroutine Fix_InitialCondition (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Fix_InitialCondtion_Constant_Heat (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Fix_InitialCondtion_Constant_Water (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Fix_InitialCondition_Gradient_Heat (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Fix_InitialCondition_Gradient_Water (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver private subroutine Fix_InitialCondition_FreezingRate (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/condition_fixinitialcondition.html"},{"title":"Condition_FixBoundaryCondition – FTDSS","text":"Uses Matrix_FindInd iso_fortran_env Types module~~condition_fixboundarycondition~~UsesGraph module~condition_fixboundarycondition Condition_FixBoundaryCondition module~matrix_findind Matrix_FindInd module~condition_fixboundarycondition->module~matrix_findind iso_fortran_env iso_fortran_env module~condition_fixboundarycondition->iso_fortran_env module~types Types module~condition_fixboundarycondition->module~types module~matrix_findind->iso_fortran_env module~matrix_findind->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~condition_fixboundarycondition~~UsedByGraph module~condition_fixboundarycondition Condition_FixBoundaryCondition module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~condition_fixboundarycondition Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines Fix_BoundaryConditions Fix_DirichletBoundaryCondition_Temperature Fix_DirichletBoundaryCondition_Temperature_F Fix_DirichletBoundaryCondition_Water Fix_DirichletBoundaryCondition_Water_F Subroutines public subroutine Fix_BoundaryConditions (Solver, inTarget) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: inTarget private subroutine Fix_DirichletBoundaryCondition_Temperature (Solver, iBC) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: iBC private subroutine Fix_DirichletBoundaryCondition_Temperature_F (Solver, iBC) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: iBC private subroutine Fix_DirichletBoundaryCondition_Water (Solver, iBC) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: iBC private subroutine Fix_DirichletBoundaryCondition_Water_F (Solver, iBC) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: iBC","tags":"","loc":"module/condition_fixboundarycondition.html"},{"title":"FindInd.f90 – FTDSS","text":"This file depends on sourcefile~~findind.f90~~EfferentGraph sourcefile~findind.f90 FindInd.f90 sourcefile~types.f90 Types.f90 sourcefile~findind.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~findind.f90~~AfferentGraph sourcefile~findind.f90 FindInd.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~assemble.f90->sourcefile~findind.f90 sourcefile~fixboundarycondition.f90 FixBoundaryCondition.f90 sourcefile~fixboundarycondition.f90->sourcefile~findind.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~fixboundarycondition.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Matrix_FindInd Source Code FindInd.f90 Source Code module Matrix_FindInd use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types , udmp => undumped , dmp => dumped implicit none private public :: Find_CRS_Index public :: Find_CRS_Indexes contains subroutine Find_CRS_Index ( A , serch_column , serch_index , index ) implicit none type ( CRS ), intent ( in ) :: A integer ( int32 ), intent ( in ) :: serch_column , serch_index integer ( int32 ), intent ( inout ) :: index integer ( int32 ) :: i , start_index , end_index index = 0 ! serch_columnのindex範囲を取得 start_index = A % Ptr ( serch_column - 1 ) end_index = A % Ptr ( serch_column ) - 1 ! 範囲内でserch_indexになる値のインデックスを見つける do i = start_index , end_index if ( A % Ind ( i ) == serch_index - 1 ) then index = i end if end do end subroutine Find_CRS_Index subroutine Find_CRS_Indexes ( lump , A , serch_index1 , serch_index2 , serch_index3 , indexes ) implicit none type ( CRS ), intent ( in ) :: A integer ( int32 ), intent ( in ) :: lump , serch_index1 , serch_index2 , serch_index3 integer ( int32 ), intent ( inout ) :: indexes (:) if ( lump == udmp ) then call Find_CRS_Index ( A , serch_index1 , serch_index1 , indexes ( 1 )) call Find_CRS_Index ( A , serch_index1 , serch_index2 , indexes ( 2 )) call Find_CRS_Index ( A , serch_index1 , serch_index3 , indexes ( 3 )) call Find_CRS_Index ( A , serch_index2 , serch_index1 , indexes ( 4 )) call Find_CRS_Index ( A , serch_index2 , serch_index2 , indexes ( 5 )) call Find_CRS_Index ( A , serch_index2 , serch_index3 , indexes ( 6 )) call Find_CRS_Index ( A , serch_index3 , serch_index1 , indexes ( 7 )) call Find_CRS_Index ( A , serch_index3 , serch_index2 , indexes ( 8 )) call Find_CRS_Index ( A , serch_index3 , serch_index3 , indexes ( 9 )) else if ( lump == dmp ) then call Find_CRS_Index ( A , serch_index1 , serch_index1 , indexes ( 1 )) call Find_CRS_Index ( A , serch_index2 , serch_index2 , indexes ( 2 )) call Find_CRS_Index ( A , serch_index3 , serch_index3 , indexes ( 3 )) end if end subroutine Find_CRS_Indexes end module Matrix_FindInd","tags":"","loc":"sourcefile/findind.f90.html"},{"title":"Assemble.f90 – FTDSS","text":"This file depends on sourcefile~~assemble.f90~~EfferentGraph sourcefile~assemble.f90 Assemble.f90 sourcefile~types.f90 Types.f90 sourcefile~assemble.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~findind.f90 FindInd.f90 sourcefile~assemble.f90->sourcefile~findind.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~assemble.f90->sourcefile~allocate.f90 sourcefile~error.f90 error.f90 sourcefile~assemble.f90->sourcefile~error.f90 sourcefile~product.f90 Product.f90 sourcefile~assemble.f90->sourcefile~product.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~findind.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~product.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~assemble.f90~~AfferentGraph sourcefile~assemble.f90 Assemble.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Matrix_Assemble Source Code Assemble.f90 Source Code module Matrix_Assemble use , intrinsic :: iso_fortran_env , only : int32 , real64 use omp_lib use :: Types , udmp => undumped , dmp => dumped use :: Allocate use :: Allocate_Structure use :: error use :: Matrix_FindInd use :: Calculate_Product , only : SpMV => Matrix_Vector_Product_CRS implicit none private real ( real64 ), parameter :: D3 = 0.33333333333333333333333333333d0 ! 1/3 real ( real64 ), parameter :: D4 = 0.25000000000000000000000000000d0 ! 1/4 real ( real64 ), parameter :: D12 = 0.08333333333333333333333333333d0 ! 1/12 real ( real64 ), parameter :: D24 = 0.04166666666666666666666666666d0 ! 1/24 type ( CRS ) :: tmpCRS1 , tmpCRS2 real ( real64 ), allocatable :: tmpA (:,:) public :: Init_Assemble public :: Assemble_GM_Heat public :: Assemble_GM_Water public :: Assemble_GM_Heat_IC public :: Assemble_GM_Water_IC contains subroutine Init_Assemble ( A ) implicit none type ( CRS ), intent ( in ) :: A call Duplicate_CRS ( A , tmpCRS1 ) tmpCRS1 % val (:) = 0.0d0 call Duplicate_CRS ( A , tmpCRS2 ) tmpCRS2 % val (:) = 0.0d0 end subroutine Init_Assemble subroutine Set_C ( C , case , p , C1 , C2 ) implicit none type ( DF ), intent ( in ) :: C integer ( int32 ), intent ( in ) :: case , p real ( real64 ), intent ( inout ) :: C1 , C2 if ( case == 1 ) then C1 = C % pre ( p ) C2 = C % old ( p ) else if ( case == 2 ) then C1 = C % div ( p ) C2 = C % old ( p ) else if ( case == 3 ) then C1 = C % div ( p ) C2 = C % div ( p ) else if ( case == 4 ) then C1 = C % div ( p ) C2 = C % old ( p ) end if end subroutine Set_C !* 時間項の要素行列を全体CRS行列に組み込むサブルーチン subroutine Calc_GM_Time_TRM ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , C1 , C2 , C3 , C tmpCRS1 % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = Solver % N % eArea ( iN ) * D12 / Solver % Time % dt C1 = Solver % Heat % Variables % Cp % pre ( p1 ) C2 = Solver % Heat % Variables % Cp % pre ( p2 ) C3 = Solver % Heat % Variables % Cp % pre ( p3 ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) tmpCRS1 % Val ( indexes ( 1 )) = tmpCRS1 % Val ( indexes ( 1 )) + CoeA * C1 * 2.d0 tmpCRS1 % Val ( indexes ( 2 )) = tmpCRS1 % Val ( indexes ( 2 )) + CoeA * C1 tmpCRS1 % Val ( indexes ( 3 )) = tmpCRS1 % Val ( indexes ( 3 )) + CoeA * C1 tmpCRS1 % Val ( indexes ( 4 )) = tmpCRS1 % Val ( indexes ( 4 )) + CoeA * C2 tmpCRS1 % Val ( indexes ( 5 )) = tmpCRS1 % Val ( indexes ( 5 )) + CoeA * C2 * 2.d0 tmpCRS1 % Val ( indexes ( 6 )) = tmpCRS1 % Val ( indexes ( 6 )) + CoeA * C2 tmpCRS1 % Val ( indexes ( 7 )) = tmpCRS1 % Val ( indexes ( 7 )) + CoeA * C3 tmpCRS1 % Val ( indexes ( 8 )) = tmpCRS1 % Val ( indexes ( 8 )) + CoeA * C3 tmpCRS1 % Val ( indexes ( 9 )) = tmpCRS1 % Val ( indexes ( 9 )) + CoeA * C3 * 2.d0 end do end subroutine Calc_GM_Time_TRM subroutine Calc_GM_Time_TRM_F ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , C1 , C2 , C3 , C if (. not . allocated ( tmpA )) call Allocate_Matrix ( tmpA , Solver % N % node , Solver % N % node ) tmpA (:,:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = Solver % N % eArea ( iN ) * D12 / Solver % Time % dt C1 = Solver % Heat % Variables % Cp % pre ( p1 ) C2 = Solver % Heat % Variables % Cp % pre ( p2 ) C3 = Solver % Heat % Variables % Cp % pre ( p3 ) tmpA ( p1 , p1 ) = tmpA ( p1 , p1 ) + CoeA * C1 * 2.d0 tmpA ( p1 , p2 ) = tmpA ( p1 , p2 ) + CoeA * C1 tmpA ( p1 , p3 ) = tmpA ( p1 , p3 ) + CoeA * C1 tmpA ( p2 , p1 ) = tmpA ( p2 , p1 ) + CoeA * C2 tmpA ( p2 , p2 ) = tmpA ( p2 , p2 ) + CoeA * C2 * 2.d0 tmpA ( p2 , p3 ) = tmpA ( p2 , p3 ) + CoeA * C2 tmpA ( p3 , p1 ) = tmpA ( p3 , p1 ) + CoeA * C3 tmpA ( p3 , p2 ) = tmpA ( p3 , p2 ) + CoeA * C3 tmpA ( p3 , p3 ) = tmpA ( p3 , p3 ) + CoeA * C3 * 2.d0 end do end subroutine Calc_GM_Time_TRM_F subroutine Calc_GM_Time_Divide ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ) real ( real64 ) :: CoeA , C11 , C12 , C13 , C21 , C22 , C23 tmpCRS1 % val (:) = 0.0d0 tmpCRS2 % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = Solver % N % eArea ( iN ) * D3 / Solver % Time % dt call Set_C ( Solver % Heat % Variables % Ca , Solver % Heat % Variables % Phase ( p1 ), p1 , C11 , C21 ) call Set_C ( Solver % Heat % Variables % Ca , Solver % Heat % Variables % Phase ( p2 ), p2 , C12 , C22 ) call Set_C ( Solver % Heat % Variables % Ca , Solver % Heat % Variables % Phase ( p3 ), p3 , C13 , C23 ) call Find_CRS_Indexes ( dmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) tmpCRS1 % Val ( indexes ( 1 )) = tmpCRS1 % Val ( indexes ( 1 )) + CoeA * C11 tmpCRS1 % Val ( indexes ( 2 )) = tmpCRS1 % Val ( indexes ( 2 )) + CoeA * C12 tmpCRS1 % Val ( indexes ( 3 )) = tmpCRS1 % Val ( indexes ( 3 )) + CoeA * C13 tmpCRS2 % Val ( indexes ( 1 )) = tmpCRS2 % Val ( indexes ( 1 )) + CoeA * C21 tmpCRS2 % Val ( indexes ( 2 )) = tmpCRS2 % Val ( indexes ( 2 )) + CoeA * C22 tmpCRS2 % Val ( indexes ( 3 )) = tmpCRS2 % Val ( indexes ( 3 )) + CoeA * C23 end do end subroutine Calc_GM_Time_Divide subroutine Calc_GM_Time_Richards ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ) real ( real64 ) :: CoeA , C1 , C2 , C3 tmpCRS1 % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = SOlver % Water % Constants % zeta * Solver % N % eArea ( iN ) * D3 / Solver % Time % dt call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) tmpCRS1 % Val ( indexes ( 1 )) = tmpCRS1 % Val ( indexes ( 1 )) + CoeA tmpCRS1 % Val ( indexes ( 2 )) = tmpCRS1 % Val ( indexes ( 2 )) + CoeA tmpCRS1 % Val ( indexes ( 3 )) = tmpCRS1 % Val ( indexes ( 3 )) + CoeA end do end subroutine Calc_GM_Time_Richards !* 拡散項の要素行列を全体CRS行列に組み込むサブルーチン subroutine Calc_GM_Diffusion_TRM ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , Lm1 , Lm2 , Lm3 Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm1 * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm1 * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm1 * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm2 * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm2 * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm2 * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm3 * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm3 * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm3 * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion_TRM subroutine Calc_GM_Diffusion ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , Lm1 , Lm2 , Lm3 , Lm Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) Lm = ( Lm1 + Lm2 + Lm3 ) * D3 be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion subroutine Calc_GM_Diffusion_Richards ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , K1 , K2 , K3 , K Solver % Water % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) K1 = Solver % Water % Variables % Klh % pre ( p1 ) K2 = Solver % Water % Variables % Klh % pre ( p2 ) K3 = Solver % Water % Variables % Klh % pre ( p3 ) K = ( K1 + K2 + K3 ) * D3 be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Water % LHS_A % Val ( indexes ( 1 )) = Solver % Water % LHS_A % Val ( indexes ( 1 )) + K * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 2 )) = Solver % Water % LHS_A % Val ( indexes ( 2 )) + K * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 3 )) = Solver % Water % LHS_A % Val ( indexes ( 3 )) + K * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 4 )) = Solver % Water % LHS_A % Val ( indexes ( 4 )) + K * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 5 )) = Solver % Water % LHS_A % Val ( indexes ( 5 )) + K * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 6 )) = Solver % Water % LHS_A % Val ( indexes ( 6 )) + K * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 7 )) = Solver % Water % LHS_A % Val ( indexes ( 7 )) + K * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 8 )) = Solver % Water % LHS_A % Val ( indexes ( 8 )) + K * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 9 )) = Solver % Water % LHS_A % Val ( indexes ( 9 )) + K * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion_Richards subroutine Calc_GM_Diffusion_Richards_F ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , K1 , K2 , K3 , K Solver % Water % RA (:,:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) K1 = Solver % Water % Variables % Klh % pre ( p1 ) K2 = Solver % Water % Variables % Klh % pre ( p2 ) K3 = Solver % Water % Variables % Klh % pre ( p3 ) K = ( K1 * K2 * K3 ) ** D3 be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) Solver % Water % RA ( p1 , p1 ) = Solver % Water % RA ( p1 , p1 ) + K * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Water % RA ( p1 , p2 ) = Solver % Water % RA ( p1 , p2 ) + K * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Water % RA ( p1 , p3 ) = Solver % Water % RA ( p1 , p3 ) + K * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Water % RA ( p2 , p1 ) = Solver % Water % RA ( p2 , p1 ) + K * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Water % RA ( p2 , p2 ) = Solver % Water % RA ( p2 , p2 ) + K * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Water % RA ( p2 , p3 ) = Solver % Water % RA ( p2 , p3 ) + K * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Water % RA ( p3 , p1 ) = Solver % Water % RA ( p3 , p1 ) + K * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Water % RA ( p3 , p2 ) = Solver % Water % RA ( p3 , p2 ) + K * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Water % RA ( p3 , p3 ) = Solver % Water % RA ( p3 , p3 ) + K * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion_Richards_F !* 拡散・移流項の要素行列を全体CRS行列に組み込むサブルーチン subroutine Calc_GM_Diffusion_Advection_TRM ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: be1 , be2 , be3 , ga1 , ga2 , ga3 real ( real64 ) :: CoeA , Lm1 , Lm2 , Lm3 real ( real64 ) :: CoeB , u1 , u2 , u3 , v1 , v2 , v3 , AD1 , AD2 , AD3 Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) CoeB = Solver % Heat % Constants % HeatCapacity % water / 6.0d0 u1 = Solver % Water % Variables % wFlux % x ( p1 ) u2 = Solver % Water % Variables % wFlux % x ( p2 ) u3 = Solver % Water % Variables % wFlux % x ( p3 ) v1 = Solver % Water % Variables % wFlux % y ( p1 ) v2 = Solver % Water % Variables % wFlux % y ( p2 ) v3 = Solver % Water % Variables % wFlux % y ( p3 ) AD1 = u1 * be1 + v1 * ga1 AD2 = u2 * be2 + v2 * ga2 AD3 = u3 * be3 + v3 * ga3 call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm1 * ( be1 * be1 + ga1 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm1 * ( be1 * be2 + ga1 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm1 * ( be1 * be3 + ga1 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm2 * ( be2 * be1 + ga2 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm2 * ( be2 * be2 + ga2 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm2 * ( be2 * be3 + ga2 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm3 * ( be3 * be1 + ga3 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm3 * ( be3 * be2 + ga3 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm3 * ( be3 * be3 + ga3 * ga3 ) * CoeA & + AD3 * CoeB end do end subroutine Calc_GM_Diffusion_Advection_TRM subroutine Calc_GM_Diffusion_Advection_TRM_F ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: be1 , be2 , be3 , ga1 , ga2 , ga3 real ( real64 ) :: CoeA , Lm1 , Lm2 , Lm3 real ( real64 ) :: CoeB , u1 , u2 , u3 , v1 , v2 , v3 , AD1 , AD2 , AD3 Solver % Heat % RA (:,:) = 0.0d0 ! print*,Solver%Heat%RA(1000,:) ! stop do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) CoeB = Solver % Heat % Constants % HeatCapacity % water / 6.0d0 u1 = Solver % Water % Variables % wFlux % x ( p1 ) u2 = Solver % Water % Variables % wFlux % x ( p2 ) u3 = Solver % Water % Variables % wFlux % x ( p3 ) v1 = Solver % Water % Variables % wFlux % y ( p1 ) v2 = Solver % Water % Variables % wFlux % y ( p2 ) v3 = Solver % Water % Variables % wFlux % y ( p3 ) AD1 = 0.0d0 ! u1 * be1 + v1 * ga1 AD2 = 0.0d0 ! u2 * be2 + v2 * ga2 AD3 = 0.0d0 ! u3 * be3 + v3 * ga3 ! AD1  = u1 * be1 + v1 * ga1 ! AD2  = u2 * be2 + v2 * ga2 ! AD3  = u3 * be3 + v3 * ga3 ! print*,p1,p2,p3 ! if (iN==100) stop ! call Find_CRS_Indexes(udmp, tmpCRS1, p1, p2, p3, indexes(:)) Solver % Heat % RA ( p1 , p1 ) = Solver % Heat % RA ( p1 , p1 ) + Lm1 * ( be1 * be1 + ga1 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % RA ( p1 , p2 ) = Solver % Heat % RA ( p1 , p2 ) + Lm2 * ( be1 * be2 + ga1 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % RA ( p1 , p3 ) = Solver % Heat % RA ( p1 , p3 ) + Lm3 * ( be1 * be3 + ga1 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % RA ( p2 , p1 ) = Solver % Heat % RA ( p2 , p1 ) + Lm1 * ( be2 * be1 + ga2 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % RA ( p2 , p2 ) = Solver % Heat % RA ( p2 , p2 ) + Lm2 * ( be2 * be2 + ga2 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % RA ( p2 , p3 ) = Solver % Heat % RA ( p2 , p3 ) + Lm3 * ( be2 * be3 + ga2 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % RA ( p3 , p1 ) = Solver % Heat % RA ( p3 , p1 ) + Lm1 * ( be3 * be1 + ga3 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % RA ( p3 , p2 ) = Solver % Heat % RA ( p3 , p2 ) + Lm2 * ( be3 * be2 + ga3 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % RA ( p3 , p3 ) = Solver % Heat % RA ( p3 , p1 ) + Lm3 * ( be3 * be3 + ga3 * ga3 ) * CoeA & + AD3 * CoeB end do end subroutine Calc_GM_Diffusion_Advection_TRM_F subroutine Calc_GM_Diffusion_Advection ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: be1 , be2 , be3 , ga1 , ga2 , ga3 real ( real64 ) :: CoeA , Lm1 , Lm2 , Lm3 , Lm real ( real64 ) :: CoeB , u1 , u2 , u3 , v1 , v2 , v3 Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) Lm = ( Lm1 * Lm2 * Lm3 ) ** D3 ! Lm   = (Lm1 + Lm2 + Lm3) * D3 CoeB = Solver % Heat % Constants % HeatCapacity % water * D24 u1 = Solver % Water % Variables % wFlux % x ( p1 ) u2 = Solver % Water % Variables % wFlux % x ( p2 ) u3 = Solver % Water % Variables % wFlux % x ( p3 ) v1 = Solver % Water % Variables % wFlux % y ( p1 ) v2 = Solver % Water % Variables % wFlux % y ( p2 ) v3 = Solver % Water % Variables % wFlux % y ( p3 ) ! write(*,'(6es14.5)') u1, u2, u3, v1, v2, v3 call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm * ( be1 * be1 + ga1 * ga1 ) * CoeA & + (( 2.d0 * u1 + u2 + u3 ) * be1 + ( 2.d0 * v1 + v2 + v3 ) * ga1 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm * ( be1 * be2 + ga1 * ga2 ) * CoeA & + (( 2.d0 * u1 + u2 + u3 ) * be2 + ( 2.d0 * v1 + v2 + v3 ) * ga2 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm * ( be1 * be3 + ga1 * ga3 ) * CoeA & + (( 2.d0 * u1 + u2 + u3 ) * be3 + ( 2.d0 * v1 + v2 + v3 ) * ga3 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm * ( be2 * be1 + ga2 * ga1 ) * CoeA & + (( u1 + 2.d0 * u2 + u3 ) * be1 + ( v1 + 2.d0 * v2 + v3 ) * ga1 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm * ( be2 * be2 + ga2 * ga2 ) * CoeA & + (( u1 + 2.d0 * u2 + u3 ) * be2 + ( v1 + 2.d0 * v2 + v3 ) * ga2 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm * ( be2 * be3 + ga2 * ga3 ) * CoeA & + (( u1 + 2.d0 * u2 + u3 ) * be3 + ( v1 + 2.d0 * v2 + v3 ) * ga3 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm * ( be3 * be1 + ga3 * ga1 ) * CoeA & + (( u1 + u2 + 2.d0 * u3 ) * be1 + ( v1 + v2 + 2.d0 * v3 ) * ga1 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm * ( be3 * be2 + ga3 * ga2 ) * CoeA & + (( u1 + u2 + 2.d0 * u3 ) * be2 + ( v1 + v2 + 2.d0 * v3 ) * ga2 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm * ( be3 * be3 + ga3 * ga3 ) * CoeA & + (( u1 + u2 + 2.d0 * u3 ) * be3 + ( v1 + v2 + 2.d0 * v3 ) * ga3 ) * CoeB end do ! stop end subroutine Calc_GM_Diffusion_Advection subroutine Assemble_GM_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver if (. not . Solver % isWater ) then if ( Solver % Flags % isTRM ) then call Calc_GM_Time_TRM ( Solver ) call Calc_GM_Diffusion_TRM ( Solver ) call SpMV ( tmpCRS1 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isGCC . or . Solver % Flags % isPower ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) end if else if ( Solver % Flags % isTRM ) then call Calc_GM_Time_TRM ( Solver ) ! call Calc_GM_Time_TRM_F(Solver) call Calc_GM_Diffusion_Advection_TRM ( Solver ) ! call Calc_GM_Diffusion_TRM(Solver) call SpMV ( tmpCRS1 , Solver % T % old (:), Solver % Heat % Rhs (:)) ! print*,Solver%Heat%Rhs(:) ! stop ! Solver%Heat%RA(:,:) = Solver%Heat%RA(:,:) + tmpA(:,:) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isGCC . or . Solver % Flags % isPower ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion_Advection ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) end if end if end subroutine Assemble_GM_Heat subroutine Assemble_GM_Heat_IC ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver ! if (.not. Solver%isWater) then if ( Solver % Flags % isTRM ) then call Calc_GM_Time_TRM ( Solver ) call Calc_GM_Diffusion_TRM ( Solver ) call SpMV ( tmpCRS1 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isGCC ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isPower ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) end if ! end if end subroutine Assemble_GM_Heat_IC subroutine Assemble_GM_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Calc_GM_Time_Richards ( Solver ) ! call Calc_GM_Diffusion_Richards(Solver) call Calc_GM_Diffusion_Richards_F ( Solver ) call SpMV ( tmpCRS1 , Solver % mIce % dif (:), Solver % Water % Rhs (:)) ! print *, Solver%Water%Rhs(:) Solver % Water % Rhs (:) = - 1.0d0 * Solver % Water % Rhs (:) end subroutine Assemble_GM_Water subroutine Assemble_GM_Water_IC ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Calc_GM_Diffusion_Richards_F ( Solver ) Solver % Water % Rhs (:) = 0.0d0 end subroutine Assemble_GM_Water_IC end module Matrix_Assemble","tags":"","loc":"sourcefile/assemble.f90.html"},{"title":"ConvertCRS.f90 – FTDSS","text":"This file depends on sourcefile~~convertcrs.f90~~EfferentGraph sourcefile~convertcrs.f90 ConvertCRS.f90 sourcefile~types.f90 Types.f90 sourcefile~convertcrs.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~convertcrs.f90->sourcefile~allocate.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~allocate.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Matrix_ConvertCRS Source Code ConvertCRS.f90 Source Code module Matrix_ConvertCRS use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: Allocate implicit none private public Convert_CRS contains subroutine Convert_CRS ( Solver , A ) implicit none type ( SolverInfo ), intent ( in ) :: Solver type ( CRS ), intent ( inout ) :: A ! integer(int32)                  :: i, j, k, l, row_nnz integer ( int32 ) :: iN , iE , iT , irT , iNC , iNNZ , row_nnz integer ( int32 ) :: nElment , nTop , nNode integer ( int32 ), allocatable :: vertex (:), row (:), tmpInd (:) nElment = Solver % N % element nTop = Solver % N % ShCoe nNode = Solver % N % node ! 0オリジンでベクトルを作成 call Allocate_Vector ( A % Ptr , 0 , nNode ) call Allocate_Vector ( row , 0 , nNode - 1 ) call Allocate_Vector ( tmpInd , 0 , 8 * nNode ) call Allocate_Vector ( vertex , nTop ) A % Ptr ( 0 ) = 0 A % nnz = 0 do iN = 1 , nNode row (:) = 0 row_nnz = 0 do iE = 1 , nElment ! iE番目の要素の頂点を取得 get_element_node : & & do iT = 1 , nTop vertex ( iT ) = Solver % N % pElement ( iT , iE ) end do get_element_node ! j番目の要素の頂点のうちいずれかの頂点がiNと一致する場合，ベクトルにインクリメント increament_vector : & & do iT = 1 , nTop if ( vertex ( iT ) == iN ) then do irT = 1 , nTop row ( vertex ( irT ) - 1 ) = row ( vertex ( irT ) - 1 ) + 1 end do exit increament_vector end if end do increament_vector end do ! ベクトルの非ゼロ要素の数をカウントし，CRSの仮ポインタに格納 do iNC = 0 , nNode - 1 if ( row ( iNC ) > 0 ) then tmpInd ( row_nnz + A % nnz ) = iNC row_nnz = row_nnz + 1 end if end do A % nnz = A % nnz + row_nnz A % Ptr ( iN ) = A % nnz end do ! CRS Matrixのメモリ確保 (0オリジン) call Allocate_Vector ( A % Ind , 0 , A % nnz - 1 ) call Allocate_Vector ( A % val , 0 , A % nnz - 1 ) ! CRSの初期化及び値の格納 do iNNZ = 0 , A % nnz - 1 A % val ( iNNZ ) = 0.0d0 A % Ind ( iNNZ ) = tmpInd ( iNNZ ) end do deallocate ( vertex ) deallocate ( row ) deallocate ( tmpInd ) end subroutine Convert_CRS end module Matrix_ConvertCRS","tags":"","loc":"sourcefile/convertcrs.f90.html"},{"title":"Heat.f90 – FTDSS","text":"This file depends on sourcefile~~heat.f90~~EfferentGraph sourcefile~heat.f90 Heat.f90 sourcefile~types.f90 Types.f90 sourcefile~heat.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~heat.f90->sourcefile~allocate_structure.f90 sourcefile~count.f90 Count.f90 sourcefile~heat.f90->sourcefile~count.f90 sourcefile~hcf.f90 HCF.f90 sourcefile~heat.f90->sourcefile~hcf.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~heat.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~error.f90 error.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~count.f90->sourcefile~types.f90 sourcefile~count.f90->sourcefile~error.f90 sourcefile~hcf.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Main_Heat Source Code Heat.f90 Source Code module Main_Heat use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: Inout_Input use :: allocate use :: Allocate_Structure , only : Allocate_DP2d use :: Calculate_HCF implicit none private integer ( int32 ), parameter :: Calc_Heat = 1 public :: Heat type Heat type ( Geometry_2D ) :: Geometry type ( Boudary_Condition ) :: BC type ( HCF ) :: HCFs ! integer(int32)              :: Num_Elements, Num_Nodes, Num_Shape, Num_Dimention, Num_Shape_Type, Num_Region ! integer(int32), allocatable :: Element(:,:) ! integer(int32), allocatable :: Element_Region(:), COO_Region(:) ! type(DP2d)                  :: Nodes_2D ! real(real64),   allocatable :: Area(:) ! type(Shape)                 :: Shape_Function contains end type Heat interface Heat module procedure Heat_Constructor end interface contains type ( Heat ) function Heat_Constructor ( Structure_Input ) type ( Input ), intent ( in ) :: Structure_Input call Set_Geometory_Infomation ( Heat_Constructor , Structure_Input ) call Set_Boundary_Condition_Infomations ( Heat_Constructor , Structure_Input ) block real ( real64 ) :: array_HCF ( 9 ) array_HCF = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] print * , array_HCF Heat_Constructor % HCFs = HCF ( array_HCF , 5 , 2 ) end block end function Heat_Constructor subroutine Set_Geometory_Infomation ( self , Structure_Input ) type ( Heat ), intent ( inout ) :: self type ( Input ), intent ( in ) :: Structure_Input self % Geometry % Num_Elements = Structure_Input % Input_Get_Elements () self % Geometry % Num_Nodes = Structure_Input % Input_Get_Nodes () self % Geometry % Num_Shape = Structure_Input % Input_Get_Shape () self % Geometry % Num_Dimention = Structure_Input % Input_Get_Dimemsion () self % Geometry % Num_Region = Structure_Input % Input_Get_Region () self % Geometry % Num_Shape_Type = self % Geometry % Num_Shape * self % Geometry % Num_Dimention self % Geometry % Element = Structure_Input % Input_Get_Top () self % Geometry % Element_Region = Structure_Input % Input_Get_Top_Region () self % Geometry % Nodes_2D = Structure_Input % Input_Get_Coordinates () self % Geometry % COO_Region = Structure_Input % Input_Get_Coordinates_Region () end subroutine Set_Geometory_Infomation subroutine Set_Boundary_Condition_Infomations ( self , Structure_Input ) use :: Calculate_Count , only : Count_if implicit none type ( Heat ), intent ( inout ) :: self type ( Input ), intent ( in ) :: Structure_Input integer ( int32 ) :: Count_Heat integer ( int32 ) :: iBC , Counter integer ( int32 ), allocatable :: Work_Node (:), Work_Edge (:, :), Work_Type (:), Work_Value_Info (:, :) real ( real64 ), allocatable :: Work_Value (:) Work_Node = Structure_Input % Input_Get_BC_Node () Work_Type = Structure_Input % Input_Get_BC_Node_Type () Work_Value_Info = Structure_Input % Input_Get_BC_Node_Value_Info () Work_Value = Structure_Input % Input_Get_BC_Node_Value ( Calc_Heat ) self % BC % Dirichlet % Num_Type = Count_if ( Work_Value_Info (:, 2 ), Condition_Heat ) call Allocate_Vector ( self % BC % Dirichlet % Value_Info , self % BC % Dirichlet % Num_Type ) call Allocate_Vector ( self % BC % Dirichlet % value , self % BC % Dirichlet % Num_Type ) Counter = 0 do iBC = 1 , size ( Work_Value_Info (:, 2 )) if ( Condition_Heat ( Work_Value_Info ( iBC , 2 ))) then Counter = Counter + 1 self % BC % Dirichlet % Value_Info ( Counter ) = Work_Value_Info ( iBC , 1 ) self % BC % Dirichlet % value ( Counter ) = Work_Value ( iBC ) end if end do self % BC % Dirichlet % Num_Node = Count_if ( Work_Type (:), Condition_In_BoundaryCondition , self % BC % Dirichlet % Value_Info (:)) call Allocate_Vector ( self % BC % Dirichlet % Node , self % BC % Dirichlet % Num_Node ) call Allocate_Vector ( self % BC % Dirichlet % Node_Type , self % BC % Dirichlet % Num_Node ) Counter = 0 do iBC = 1 , size ( Work_Type ) if ( Condition_In_BoundaryCondition ( Work_Type ( iBC ), self % BC % Dirichlet % Value_Info (:))) then Counter = Counter + 1 self % BC % Dirichlet % Node ( Counter ) = Work_Node ( iBC ) self % BC % Dirichlet % Node_Type ( Counter ) = Work_Type ( iBC ) end if end do if ( allocated ( Work_Node )) deallocate ( Work_Node ) if ( allocated ( Work_Type )) deallocate ( Work_Type ) if ( allocated ( Work_Value_Info )) deallocate ( Work_Value_Info ) if ( allocated ( Work_Value )) deallocate ( Work_Value ) self % BC % Neumann % Edge = Structure_Input % Input_Get_BC_Edge () self % BC % Neumann % Edge_Type = Structure_Input % Input_Get_BC_Edge_Type () end subroutine Set_Boundary_Condition_Infomations logical function Condition_Heat ( num ) implicit none integer ( int32 ), intent ( in ) :: num if ( mod ( num , 8 ) >= 4 ) then Condition_Heat = . true . else Condition_Heat = . false . end if end function Condition_Heat logical function Condition_In_BoundaryCondition ( num , Value_Info ) implicit none integer ( int32 ), intent ( in ) :: num integer ( int32 ), intent ( in ) :: Value_Info (:) ! 配列を引数として受け取る integer :: i logical :: found found = . false . do i = 1 , size ( Value_Info ) if ( num == Value_Info ( i )) then found = . true . exit end if end do Condition_In_BoundaryCondition = found end function Condition_In_BoundaryCondition end module Main_Heat","tags":"","loc":"sourcefile/heat.f90.html"},{"title":"Stdout.f90 – FTDSS","text":"This file depends on sourcefile~~stdout.f90~~EfferentGraph sourcefile~stdout.f90 Stdout.f90 sourcefile~types.f90 Types.f90 sourcefile~stdout.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Inout_Stdout Source Code Stdout.f90 Source Code module Inout_Stdout use omp_lib use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none private public :: init_omp_config contains subroutine init_omp_config ( Solver ) type ( SolverInfo ), intent ( inout ) :: Solver ! OpenMPの設定 ! call omp_set_dynamic(TRUE) call omp_set_max_active_levels ( 1 ) if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '' if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) 'OpenMP Properties' if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '-------------------------------------' if ( Solver % Flags % isStdOut ) write ( * , '(a,i0)' ) 'Max number of threads           = ' , omp_get_max_threads () if ( Solver % Flags % isStdOut ) write ( * , '(a,i0)' ) 'Number of processors availables = ' , omp_get_num_procs () if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '-------------------------------------' if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '' end subroutine init_omp_config end module Inout_Stdout","tags":"","loc":"sourcefile/stdout.f90.html"},{"title":"Output.f90 – FTDSS","text":"This file depends on sourcefile~~output.f90~~EfferentGraph sourcefile~output.f90 Output.f90 sourcefile~setprojectpath.f90 SetProjectPath.f90 sourcefile~output.f90->sourcefile~setprojectpath.f90 sourcefile~types.f90 Types.f90 sourcefile~output.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~output.f90->sourcefile~allocate.f90 sourcefile~error.f90 error.f90 sourcefile~output.f90->sourcefile~error.f90 sourcefile~setprojectpath.f90->sourcefile~error.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Inout_Output Source Code Output.f90 Source Code module Inout_Output use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Inout_SetProjectPath , only : GetProjectPath => Inout_SetProjectPath_GetProjectPath use :: error use :: allocate use :: Inout_Input use :: types implicit none private type :: Output private integer ( int32 ), allocatable :: Output_Observation_Flag (:) character ( 256 ) :: T_FileName , Fr_FileName , TC_FileName , C_FileName , P_FileName , Flux_FileName , K_FileName character ( 256 ) :: dir_Path logical , allocatable :: is_Output (:) logical :: is_Output_Dat , is_Output_VTK contains ! procedure :: Output_All         => Inout_Output_All_vtk procedure :: Output_All => Inout_Output_All procedure :: Output_Observation => Inout_Output_Observation end type Output interface Output module procedure Output_Constructor end interface public :: Output contains type ( Output ) function Output_Constructor ( Inputs ) implicit none type ( Input ), intent ( in ) :: Inputs integer ( int32 ) :: Flag_Size integer ( int32 ), allocatable :: Output_Observation_Flag (:) ! character(256) :: dir_Path integer :: i integer ( int32 ) :: Output_File_Type ! Path settings Output_Constructor % dir_Path = GetProjectPath () Output_File_Type = Inputs % Input_Get_Output_File () if ( Output_File_Type == 1 ) then Output_Constructor % is_Output_Dat = . true . Output_Constructor % is_Output_VTK = . false . else if ( Output_File_Type == 2 ) then Output_Constructor % is_Output_Dat = . false . Output_Constructor % is_Output_VTK = . true . end if Output_Constructor % T_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_T.dat\" Output_Constructor % Fr_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_Fr.dat\" Output_Constructor % TC_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_TC.dat\" Output_Constructor % C_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_C.dat\" Output_Constructor % P_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_P.dat\" Output_Constructor % Flux_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_Flux.dat\" Output_Constructor % K_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_K.dat\" Output_Observation_Flag = Inputs % Input_Get_Observation_Flag () Flag_Size = size ( Output_Observation_Flag ) call Allocate_Vector ( Output_Constructor % is_Output , Flag_Size ) do i = 1 , Flag_Size call Set_Output_Flag ( Output_Observation_Flag ( i ), Output_Constructor % is_Output ( i )) end do if ( allocated ( Output_Observation_Flag )) deallocate ( Output_Observation_Flag ) end function Output_Constructor subroutine Inout_Output_All ( self , Solver , num ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: num if ( self % is_Output_Dat ) call Inout_Output_All_Dat ( self , Solver , num ) if ( self % is_Output_VTK ) call Inout_Output_All_vtk ( self , Solver , num ) end subroutine Inout_Output_All subroutine Inout_Output_All_Dat ( self , Solver , num ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: num character ( 256 ) :: oName , fmt integer ( int32 ) :: ios , unit_num , iN write ( oName , Solver % fmt_Fileout ) trim ( self % dir_Path ), \"Output/DATFILE/Output_\" , num , \".dat\" open ( newunit = unit_num , file = oName , status = 'replace' , action = 'write' , iostat = ios ) if ( ios /= 0 ) call error_message ( 931 ) select case ( Solver % nAnalysis ) case ( 1 ) ! do iN = 1, Solver%N%node !     write(unit_num, '(es15.7,a,es15.7)') Solver%T%pre(iN), ', ', Solver%T%Si(iN) ! end do case ( 2 ) case ( 3 ) case ( 4 ) fmt = '(2es13.5,2es13.5)' do iN = 1 , Solver % N % node write ( unit_num , fmt ) Solver % N % vCood % x ( iN ), Solver % N % vCood % y ( iN ), Solver % T % pre ( iN ), Solver % Si % pre ( iN ) end do case ( 5 ) case ( 6 ) fmt = '(2es13.5,5es13.5)' do iN = 1 , Solver % N % node write ( unit_num , fmt ) Solver % N % vCood % x ( iN ), Solver % N % vCood % y ( iN ), Solver % T % pre ( iN ), Solver % P % pre ( iN ), Solver % Si % pre ( iN ), Solver % Water % Variables % wFlux % x ( iN ), + Solver % Water % Variables % wFlux % y ( iN ) end do case ( 7 ) end select close ( unit_num ) end subroutine Inout_Output_All_Dat subroutine Inout_Output_Observation ( self , Solver , time ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ), intent ( in ) :: time integer ( int32 ) :: unit_num , ios , iObs , nObs , iS , dim real ( real64 ) :: obsValue ( Solver % Obs % nObs ), obsValue2d ( 2 * Solver % Obs % nObs ) real ( real64 ) :: tmpValue character ( 64 ) :: ofmt nObs = Solver % Obs % nObs if ( Solver % Flags % outOBS ( 1 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % T_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % T_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % T % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % T % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 2 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % Fr_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % Fr_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Si % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Si % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 3 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , 2 * nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % TC_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % TC_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Heat % Variables % Tgrad % x ( Solver % Obs % obsPoint ( iObs )), Solver % Heat % Variables % Tgrad % y ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + ( Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Heat % Variables % Tgrad % x ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs )))) ** 2 ! tmpValue = tmpValue + sqrt((Solver%Obs%vAreaObs(iS, iObs) * Solver%Heat%Variables%Tgrad%x(Solver%N%pElement(iS, Solver%Obs%nAreaObs(iObs))))**2+(Solver%Obs%vAreaObs(iS, iObs) * Solver%Heat%Variables%Tgrad%y(Solver%N%pElement(iS, Solver%Obs%nAreaObs(iObs))))**2) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 4 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % C_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % C_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Flags % isTRM ) then if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Heat % Variables % Cp % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Heat % Variables % Cp % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if else if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Heat % Variables % Ca % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Heat % Variables % Ca % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 5 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % P_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % P_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % P % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % P % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 6 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , 2 * nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % Flux_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % Flux_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Water % Variables % wFlux % x ( Solver % Obs % obsPoint ( iObs )), Solver % Water % Variables % wFlux % y ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs do dim = 1 , 2 if ( dim == 1 ) then tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Water % Variables % wFlux % x ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do else do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Water % Variables % wFlux % y ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do end if obsValue ( 2 * ( iObs - 1 ) + dim ) = tmpValue end do end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , 2 * nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 7 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % K_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % K_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Water % Variables % Klh % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Water % Variables % Klh % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if end subroutine Inout_Output_Observation ! subroutine Output_time(ar_secsum, ttime, dxmin, dt, tmax, nSType, nLFType) !     implicit none !     real(real64), intent(in) :: ar_secsum(:), ttime, dxmin, dt, tmax !     integer(int32), intent(in) :: nSType, nLFType !     integer(int32) :: ios, tdata(8) !     character(len=100) :: oPath, oName !     character(len=12) :: real_clock(3) !     character(len=5) :: SType, LFType !     call date_and_time(real_clock(1), real_clock(2), real_clock(3), tdata) !     if (nSType == 1) then !     SType = \"LU\" !     else if (nSType == 2) then !     SType = \"GE\" !     else if (nSType == 3) then !     SType = \"CG\" !     else !     SType= \"ELSE\" !     end if !     if (nLFType == 1) then !     LFType = \"TRM\" !     else if (nLFType == 2) then !     LFType = \"ASBM\" !     else !     LFType = \"ELSE\" !     end if !     call get_path(oPath) !     ! write(oName, '(a,f6.4,a,f4.1,a,f3.1,5a)') trim(oPath) // 'Output/TIME/' // 'Time_', dxmin, 'm_', dt, 's_', tmax/86400, 'day_',& !     ! & trim(SType),'_', trim(LFType), '.dat' !     ! print*, trim(oName) !     oName = trim(oPath) // 'Output/TIME/time.dat' !     open(100, file = oName, status='replace', action=\"write\", iostat=ios) !     if (ios /= 0) call error_message(931) !     write(100,'(a,i4.4,a,i2.2,a,i2.2,a,i2.2,a,i2.2,a,i2.2)') 'Date : ', tdata(1), '/', tdata(2), '/', tdata(3), '   Time : ',& !     & tdata(5), ':', tdata(6), ':', tdata(7) !     write(100,'(a)') '--------------------------------------------------' !     write(100,'(a,f6.4,a)') 'Minimum Distance  : ', dxmin, 'm' !     write(100,'(a,f6.2,a)') 'Initial time step : ', dt, 's' !     write(100,'(a,i0,a)')   'Termination time  : ', nint(tmax), 's' !     write(100,'(a)') '--------------------------------------------------' !     write(100,'(a,f13.5,a)') 'Total time      :', ttime, 's' !     write(100,'(a,f13.5,a)') 'Assemble Section:', ar_secsum(1), 's' !     write(100,'(a,f13.5,a)') 'Matrix Calculate:', ar_secsum(2), 's' !     write(100,'(a,f13.5,a)') 'Solve linear Eq.:', ar_secsum(3), 's' !     write(100,'(a,f13.5,a)') 'Latent Heat Clac:', ar_secsum(4), 's' !     write(100,'(a)', advance='no') '--------------------------------------------------' !     close(100) !     return ! end subroutine Output_time subroutine Inout_Output_All_vtk ( self , Solver , num ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: num character ( 256 ) :: oName , fmt integer ( int32 ) :: ios , unit_num , iN real ( real64 ) :: wFlux_all ( 3 , Solver % N % node ) write ( oName , Solver % fmt_Fileout ) trim ( self % dir_Path ), \"Output/DATFILE/Output_\" , num , \".vtk\" open ( newunit = unit_num , file = oName , status = 'replace' , action = 'write' , iostat = ios ) if ( ios /= 0 ) call error_message ( 931 ) write ( unit_num , '(a)' ) \"# vtk DataFile Version 2.0\" write ( unit_num , '(a)' ) \"Analysis ASCII VTK file\" write ( unit_num , '(a)' ) \"ASCII\" write ( unit_num , '(a)' ) \"DATASET UNSTRUCTURED_GRID\" write ( unit_num , '(a,i0,a)' ) \"POINTS \" , Solver % N % node , \" double\" do iN = 1 , Solver % N % node write ( unit_num , '(3f18.13)' ) Solver % N % vCood % x ( iN ), Solver % N % vCood % y ( iN ), 0 end do write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a,i0,a,i0,a)' ) \"CELLS \" , Solver % N % element , \" \" , Solver % N % element * 4 do iN = 1 , Solver % N % element write ( unit_num , '(i0,a,i0,a,i0,a,i0)' ) Solver % N % ShCoe , \" \" , Solver % N % pElement ( 1 , iN ) - 1 , \" \" , Solver % N % pElement ( 2 , iN ) - 1 , \" \" , Solver % N % pElement ( 3 , iN ) - 1 end do write ( unit_num , '(a,i0,a)' ) \"CELL_TYPES \" , Solver % N % element do iN = 1 , Solver % N % element write ( unit_num , '(i0)' ) 5 end do select case ( Solver % nAnalysis ) case ( 1 ) ! do iN = 1, Solver%N%node !     write(unit_num, '(es15.7,a,es15.7)') Solver%T%pre(iN), ', ', Solver%T%Si(iN) ! end do case ( 2 ) case ( 3 ) case ( 4 ) write ( unit_num , '(a, i0)' ) \"POINT_DATA \" , Solver % N % node write ( unit_num , '(a)' ) \"SCALARS Temperature double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % T % pre (:) write ( unit_num , '(a)' ) \"SCALARS Pressure double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % P % pre (:) write ( unit_num , '(a)' ) \"SCALARS Si double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % Si % pre (:) case ( 6 ) wFlux_all ( 1 , :) = Solver % Water % Variables % wFlux % x (:) wFlux_all ( 2 , :) = Solver % Water % Variables % wFlux % y (:) wFlux_all ( 3 , :) = 0.0d0 write ( unit_num , '(a, i0)' ) \"POINT_DATA \" , Solver % N % node write ( unit_num , '(a)' ) \"SCALARS Temperature double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % T % pre (:) write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a)' ) \"SCALARS Pressure double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % P % pre (:) write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a)' ) \"SCALARS Si double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % Si % pre (:) write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a)' ) \"VECTORS WaterFlux double\" write ( unit_num , '(3es13.5)' ) wFlux_all case ( 7 ) end select close ( unit_num ) end subroutine Inout_Output_All_vtk ! subroutine Measure_Time(nsec, ar_sec, ar_secsum) !     implicit none !     integer(int32), intent(in) :: nsec !     real(real64), intent(inout) :: ar_sec(:), ar_secsum(:) !     ar_sec(nsec+1) = omp_get_wtime() !     ar_secsum(nsec) = ar_secsum(nsec) + ar_sec(nsec+1) - ar_sec(nsec) !     return ! end subroutine Measure_Time subroutine Set_Output_Flag ( iValue , inFlag ) implicit none integer ( int32 ), intent ( in ) :: iValue logical , intent ( inout ) :: inFlag if ( iValue == 1 ) then inFlag = . true . else inFlag = . false . end if end subroutine Set_Output_Flag end module Inout_Output","tags":"","loc":"sourcefile/output.f90.html"},{"title":"SetProjectPath.f90 – FTDSS","text":"This file depends on sourcefile~~setprojectpath.f90~~EfferentGraph sourcefile~setprojectpath.f90 SetProjectPath.f90 sourcefile~error.f90 error.f90 sourcefile~setprojectpath.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~setprojectpath.f90~~AfferentGraph sourcefile~setprojectpath.f90 SetProjectPath.f90 sourcefile~output.f90 Output.f90 sourcefile~output.f90->sourcefile~setprojectpath.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Inout_SetProjectPath Source Code SetProjectPath.f90 Source Code module Inout_SetProjectPath use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: error implicit none private character ( 256 ) :: ProjectPath logical :: isSetProjectPath = . false . public :: Inout_SetProjectPath_GetProjectPath contains subroutine Inout_SetProjectPath_SetProjectPath implicit none character ( 64 ), parameter :: dName = \"ProjectPath.dir\" integer ( int32 ) :: access , status , len_path , unit_num integer :: i status = access ( dName , \"r\" ) if ( status /= 0 ) call error_message ( 901 , opt_file_name = dName ) open ( newunit = unit_num , file = dName , iostat = status , status = \"old\" ) if ( status /= 0 ) call error_message ( 902 , opt_file_name = dName ) read ( unit_num , '(a)' ) ProjectPath close ( unit_num ) len_path = len_trim ( ProjectPath ) ProjectPath = trim ( adjustl ( ProjectPath )) ! For windows, replace \"\\\\\" with \"/\" i = index ( ProjectPath , \"\\\\\" ) do while ( i > 0 ) ProjectPath ( i : i + 1 ) = \"/\" if ( i + 2 <= len_path ) then ProjectPath ( i + 1 :) = ProjectPath ( i + 2 :) // \" \" end if len_path = len_path - 1 i = index ( ProjectPath , \"\\\\\" ) end do ! For UNIX, replace \"\\\" with \"/\" i = index ( ProjectPath , \"\\\") do while (i > 0) ProjectPath(i:i) = \" / \" len_path = len_trim(ProjectPath) i = index(ProjectPath, \" \\ \") end do ! Add \" / \" to end to path if (len_path > 0 .and. ProjectPath(len_path:len_path) /= \" / \") then ProjectPath = trim(adjustl(ProjectPath))//\" / \" end if isSetProjectPath = . true . end subroutine Inout_SetProjectPath_SetProjectPath character ( 256 ) function Inout_SetProjectPath_GetProjectPath () implicit none if (. not . isSetProjectPath ) call Inout_SetProjectPath_SetProjectPath Inout_SetProjectPath_GetProjectPath = ProjectPath end function Inout_SetProjectPath_GetProjectPath end module Inout_SetProjectPath","tags":"","loc":"sourcefile/setprojectpath.f90.html"},{"title":"Area.f90 – FTDSS","text":"This file depends on sourcefile~~area.f90~~EfferentGraph sourcefile~area.f90 Area.f90 sourcefile~types.f90 Types.f90 sourcefile~area.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~area.f90->sourcefile~error.f90 sourcefile~points.f90 Points.f90 sourcefile~area.f90->sourcefile~points.f90 sourcefile~points.f90->sourcefile~types.f90 sourcefile~points.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_Area Source Code Area.f90 Source Code module Calculate_Area use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: error use :: Calculate_Points , only : Set_Point implicit none interface Calc_Area procedure :: Calc_Area_31 end interface contains subroutine Calc_Area_31 ( Geometry ) implicit none type ( Geometry2d ), intent ( inout ) :: Geometry type ( Vector2d ) :: p1 , p2 , p3 integer ( int32 ) :: elem do elem = 1 , Geometry % element call set_point ( Geometry , elem , p1 , p2 , p3 ) if ( elem < 1 . or . elem > Geometry % element ) then call error_message ( 932 ) else Geometry % eArea ( elem ) = abs (( p2 % x - p1 % x ) * ( p3 % y - p1 % y ) - ( p2 % y - p1 % y ) * ( p3 % x - p1 % x )) / 2.d0 end if end do end subroutine Calc_Area_31 end module Calculate_Area","tags":"","loc":"sourcefile/area.f90.html"},{"title":"Points.f90 – FTDSS","text":"This file depends on sourcefile~~points.f90~~EfferentGraph sourcefile~points.f90 Points.f90 sourcefile~types.f90 Types.f90 sourcefile~points.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~points.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~points.f90~~AfferentGraph sourcefile~points.f90 Points.f90 sourcefile~area.f90 Area.f90 sourcefile~area.f90->sourcefile~points.f90 sourcefile~shape.f90 Shape.f90 sourcefile~shape.f90->sourcefile~points.f90 sourcefile~observation.f90 Observation.f90 sourcefile~observation.f90->sourcefile~points.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_Points Source Code Points.f90 Source Code module Calculate_Points use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: error implicit none private interface Set_Point procedure :: Set_Point_31 end interface public :: Set_Point contains subroutine Set_Point_31 ( Geometry , triangle_index , p1 , p2 , p3 ) implicit none type ( Geometry2d ), intent ( in ) :: Geometry integer ( int32 ), intent ( in ) :: triangle_index type ( Vector2d ), intent ( inout ) :: p1 , p2 , p3 p1 % x = Geometry % vCood % x ( Geometry % pElement ( 1 , triangle_index )) p2 % x = Geometry % vCood % x ( Geometry % pElement ( 2 , triangle_index )) p3 % x = Geometry % vCood % x ( Geometry % pElement ( 3 , triangle_index )) p1 % y = Geometry % vCood % y ( Geometry % pElement ( 1 , triangle_index )) p2 % y = Geometry % vCood % y ( Geometry % pElement ( 2 , triangle_index )) p3 % y = Geometry % vCood % y ( Geometry % pElement ( 3 , triangle_index )) if ( p1 % x == p2 % x . and . p1 % y == p2 % y . or . & & p1 % x == p3 % x . and . p1 % y == p3 % y . or . & & p2 % x == p3 % x . and . p2 % y == p3 % y ) then call error_message ( 928 ) end if end subroutine Set_Point_31 end module Calculate_Points","tags":"","loc":"sourcefile/points.f90.html"},{"title":"HCF.f90 – FTDSS","text":"This file depends on sourcefile~~hcf.f90~~EfferentGraph sourcefile~hcf.f90 HCF.f90 sourcefile~types.f90 Types.f90 sourcefile~hcf.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~hcf.f90~~AfferentGraph sourcefile~hcf.f90 HCF.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~hcf.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_HCF Source Code HCF.f90 Source Code module Calculate_HCF use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none type , extends ( HCF_Parameters ) :: HCF private procedure ( Calculation_HCF ), pointer , nopass :: Calculate_HCF => null () procedure ( Calculation_HCF_mu ), pointer , nopass :: Calculate_HCF_mu => null () contains procedure :: Calculate_Kflh => Calculate_Ks end type HCF interface HCF module procedure HCF_Constructor end interface abstract interface function Calculation_HCF ( Instance_HCF , h ) result ( kr ) use , intrinsic :: iso_fortran_env , only : real64 import :: HCF implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr end function Calculation_HCF end interface abstract interface function Calculation_HCF_mu ( T ) result ( mu ) use , intrinsic :: iso_fortran_env , only : real64 import :: HCF implicit none real ( real64 ), intent ( in ) :: T real ( real64 ) :: mu end function Calculation_HCF_mu end interface contains type ( HCF ) function HCF_Constructor ( in_HCF_Parameters , HCF_Model_id , Kflh_Model_id ) implicit none real ( real64 ), intent ( in ) :: in_HCF_Parameters (:) integer ( int32 ), intent ( in ) :: HCF_Model_id , Kflh_Model_id real ( real64 ), parameter :: Tcrit = 1 5.0d0 select case ( HCF_Model_id ) case ( 1 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % Ks = in_HCF_Parameters ( 5 ) HCF_Constructor % l = in_HCF_Parameters ( 6 ) HCF_Constructor % Calculate_HCF => Calculate_HCF_BC case ( 2 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % Ks = in_HCF_Parameters ( 5 ) HCF_Constructor % l = in_HCF_Parameters ( 6 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % Calculate_HCF => Calculate_HCF_VG case ( 3 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % Ks = in_HCF_Parameters ( 5 ) HCF_Constructor % l = in_HCF_Parameters ( 6 ) HCF_Constructor % Calculate_HCF => Calculate_HCF_KO case ( 4 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % hcrit = in_HCF_Parameters ( 5 ) HCF_Constructor % Ks = in_HCF_Parameters ( 6 ) HCF_Constructor % l = in_HCF_Parameters ( 7 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % Calculate_HCF => Calculate_HCF_MVG case ( 5 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % alpha2 = in_HCF_Parameters ( 5 ) HCF_Constructor % n2 = in_HCF_Parameters ( 6 ) HCF_Constructor % w1 = in_HCF_Parameters ( 7 ) HCF_Constructor % Ks = in_HCF_Parameters ( 8 ) HCF_Constructor % l = in_HCF_Parameters ( 9 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % m2 = 1.0d0 - 1.0d0 / HCF_Constructor % n2 HCF_Constructor % w2 = 1.0d0 - HCF_Constructor % w1 HCF_Constructor % Calculate_HCF => Calculate_HCF_Durner case ( 6 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % n2 = in_HCF_Parameters ( 5 ) HCF_Constructor % w1 = in_HCF_Parameters ( 6 ) HCF_Constructor % Ks = in_HCF_Parameters ( 7 ) HCF_Constructor % l = in_HCF_Parameters ( 8 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % m2 = 1.0d0 - 1.0d0 / HCF_Constructor % n2 HCF_Constructor % w2 = 1.0d0 - HCF_Constructor % w1 HCF_Constructor % Calculate_HCF => Calculate_HCF_DVGCH end select select case ( Kflh_Model_id ) case ( 3 , 5 ) HCF_Constructor % Calculate_HCF_mu => Calc_HCF_mu_Exponential HCF_Constructor % kzero = HCF_Constructor % Ks / HCF_Constructor % Calculate_HCF_mu ( Tcrit ) case ( 6 , 7 ) HCF_Constructor % Calculate_HCF_mu => Calc_HCF_mu_Exponential_Supercooled HCF_Constructor % kzero = HCF_Constructor % Ks / HCF_Constructor % Calculate_HCF_mu ( Tcrit ) end select end function HCF_Constructor function Calculate_Ks ( Instance_HCF , h ) result ( kr ) implicit none class ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr ! select case (Instance_HCF%Ks) ! case (1) !     kr = Calculate_HCF_BC(Instance_HCF, h) ! case (2) !     kr = Calculate_HCF_VG(Instance_HCF, h) ! case (3) !     kr = Calculate_HCF_KO(Instance_HCF, h) ! case (4) !     kr = Calculate_HCF_MVG(Instance_HCF, h) ! case (5) !     kr = Calculate_HCF_Durner(Instance_HCF, h) ! case (6) !     kr = Calculate_HCF_DVGCH(Instance_HCF, h) ! end select kr = 1.0d0 end function Calculate_Ks function Calculate_HCF_BC ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw if ( h < - 1.0d0 / Instance_HCF % alpha1 ) then Sw = abs ( Instance_HCF % alpha1 * h ) ** ( - Instance_HCF % n1 ) else Sw = 1.0d0 end if kr = Sw ** ( 2.0d0 / ( Instance_HCF % n1 + Instance_HCF % l + 2.0d0 )) end function Calculate_HCF_BC function Calculate_HCF_VG ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw if ( h < 0 ) then Sw = ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) else Sw = 1.0d0 end if kr = Sw ** Instance_HCF % l * ( 1.0d0 - ( 1.0d0 - Sw ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) ** 2.0d0 end function Calculate_HCF_VG function Calculate_HCF_KO ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw if ( h < 0 ) then Sw = 0.5d0 * erfc ( log ( h / Instance_HCF % alpha1 ) / ( Instance_HCF % n1 * sqrt ( 2.0d0 ))) kr = Sw ** 0.5d0 * ( 0.5d0 * erfc ( log ( h / Instance_HCF % alpha1 ) / ( Instance_HCF % n1 * sqrt ( 2.0d0 )) + Instance_HCF % n1 / sqrt ( 2.0d0 ))) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_KO function Calculate_HCF_MVG ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw , thetaM thetaM = Instance_HCF % thetaR + ( Instance_HCF % thetaS - Instance_HCF % thetaR ) * ( 1.0d0 + abs ( Instance_HCF % alpha1 * Instance_HCF % hcrit ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) if ( h < Instance_HCF % hcrit ) then Sw = ( Instance_HCF % thetaS - Instance_HCF % thetaR ) / ( thetaM - Instance_HCF % thetaR ) * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) kr = Sw ** Instance_HCF % l * (( 1.0d0 - ( 1.0d0 - Sw ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) / ( 1.0d0 - ( 1.0d0 - 1.0d0 ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 )) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_MVG function Calculate_HCF_Durner ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw1 , Sw2 if ( h < 0 ) then Sw1 = Instance_HCF % w1 * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) Sw2 = Instance_HCF % w2 * ( 1.0d0 + abs ( Instance_HCF % alpha2 * h ) ** Instance_HCF % n2 ) ** ( - Instance_HCF % m2 ) kr = ( Instance_HCF % w1 * Sw1 + Instance_HCF % w2 * Sw2 ) ** Instance_HCF % l & * ( Instance_HCF % w1 * Instance_HCF % alpha1 * ( 1.0d0 - ( 1.0d0 - Sw1 ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) & + Instance_HCF % w2 * Instance_HCF % alpha2 * ( 1.0d0 - ( 1.0d0 - Sw2 ** ( 1.0d0 / Instance_HCF % m2 )) ** Instance_HCF % m2 )) ** 2.0d0 & / ( Instance_HCF % w1 * Instance_HCF % alpha1 + Instance_HCF % w2 * Instance_HCF % alpha2 ) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_Durner function Calculate_HCF_DVGCH ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw1 , Sw2 if ( h < 0 ) then Sw1 = Instance_HCF % w1 * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) Sw2 = Instance_HCF % w2 * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n2 ) ** ( - Instance_HCF % m2 ) kr = ( Instance_HCF % w1 * Sw1 + Instance_HCF % w2 * Sw2 ) ** Instance_HCF % l & * ( Instance_HCF % w1 * Instance_HCF % alpha1 * ( 1.0d0 - ( 1.0d0 - Sw1 ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) & + Instance_HCF % w2 * Instance_HCF % alpha1 * ( 1.0d0 - ( 1.0d0 - Sw2 ** ( 1.0d0 / Instance_HCF % m2 )) ** Instance_HCF % m2 )) ** 2.0d0 & / ( Instance_HCF % w1 * Instance_HCF % alpha1 + Instance_HCF % w2 * Instance_HCF % alpha2 ) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_DVGCH function Calc_HCF_mu_Exponential ( T ) result ( mu ) implicit none real ( real64 ), intent ( in ) :: T real ( real64 ) :: mu mu = 2.1d-6 * exp ( 180 8.5d0 / ( T + 27 3.15d0 )) end function Calc_HCF_mu_Exponential function Calc_HCF_mu_Exponential_Supercooled ( T ) result ( mu ) implicit none real ( real64 ), intent ( in ) :: T real ( real64 ) :: mu mu = 1.3788d-4 * (( 27 3.15d0 + T ) / 22 5.66d0 - 1.0d0 ) ** ( - 1.6438 ) end function Calc_HCF_mu_Exponential_Supercooled end module Calculate_HCF","tags":"","loc":"sourcefile/hcf.f90.html"},{"title":"Product.f90 – FTDSS","text":"This file depends on sourcefile~~product.f90~~EfferentGraph sourcefile~product.f90 Product.f90 sourcefile~types.f90 Types.f90 sourcefile~product.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~product.f90~~AfferentGraph sourcefile~product.f90 Product.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~assemble.f90->sourcefile~product.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~product.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_Product Source Code Product.f90 Source Code module Calculate_Product use omp_lib use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none private public :: Matrix_Vector_Product_CRS contains !* 行列ベクトル積を計算するサブルーチン subroutine Matrix_Vector_Product_CRS ( A , x , y ) implicit none type ( CRS ), intent ( in ) :: A real ( real64 ), intent ( in ) :: x (:) real ( real64 ), intent ( inout ) :: y (:) real ( real64 ) :: vtemp integer ( int32 ) :: i , j , is , ie integer ( int32 ) :: matrix_size matrix_size = size ( A % ptr ) - 1 y (:) = 0.0d0 !$omp parallel do private(vtemp, i, j, is, ie) do i = 1 , matrix_size vtemp = 0.0d0 is = A % ptr ( i - 1 ) ie = A % ptr ( i ) - 1 do j = is , ie vtemp = vtemp + A % val ( j ) * x ( A % ind ( j ) + 1 ) end do y ( i ) = vtemp end do !$omp end parallel do end subroutine Matrix_Vector_Product_CRS end module Calculate_Product","tags":"","loc":"sourcefile/product.f90.html"},{"title":"WRF.f90 – FTDSS","text":"This file depends on sourcefile~~wrf.f90~~EfferentGraph sourcefile~wrf.f90 WRF.f90 sourcefile~types.f90 Types.f90 sourcefile~wrf.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_WRF Source Code WRF.f90 Source Code module Calculate_WRF use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none contains function Calculate_WRF_BC ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_BC ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < - 1.0d0 / structure_WRF % alpha1 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * ( structure_WRF % alpha1 / h ) ** structure_WRF % n1 else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_BC function Calculate_WRF_Derivative_BC ( structure_WRF , h ) result ( Cw ) type ( Type_WRF_BC ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: Cw if ( h < - 1.0d0 / structure_WRF % alpha1 ) then Cw = ( structure_WRF % thetaS - structure_WRF % thetaR ) * structure_WRF % n1 * ( structure_WRF % alpha1 / h ) ** ( structure_WRF % n1 + 1.0d0 ) / structure_WRF % alpha1 else Cw = 0.0d0 end if end function Calculate_WRF_Derivative_BC function Calculate_WRF_VG ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_VG ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * ( 1.0d0 + ( - structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_VG function Calculate_WRF_KO ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_KO ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * 0.5d0 * erfc ( log ( h / structure_WRF % alpha1 ) / ( structure_WRF % n1 * sqrt ( 2.0d0 ))) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_KO function Calculate_WRF_MVG ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_MVG ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < structure_WRF % hcrit ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_MVG function Calculate_WRF_Durner ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_Durner ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * & ( structure_WRF % w1 * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) & + structure_WRF % w2 * ( 1.0d0 + abs ( structure_WRF % alpha2 * h ) ** structure_WRF % n2 ) ** ( - structure_WRF % m2 )) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_Durner function Calculate_WRF_DVGCH ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_DVGCH ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * & ( structure_WRF % w1 * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) & + structure_WRF % w2 * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n2 ) ** ( - structure_WRF % m2 )) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_DVGCH end module Calculate_WRF","tags":"","loc":"sourcefile/wrf.f90.html"},{"title":"Update.f90 – FTDSS","text":"This file depends on sourcefile~~update.f90~~EfferentGraph sourcefile~update.f90 Update.f90 sourcefile~types.f90 Types.f90 sourcefile~update.f90->sourcefile~types.f90 sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~update.f90->sourcefile~binaryfinding.f90 sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~update.f90->sourcefile~secantmethod.f90 sourcefile~binaryfinding.f90->sourcefile~types.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~binaryfinding.f90->sourcefile~latentheat.f90 sourcefile~secantmethod.f90->sourcefile~types.f90 sourcefile~secantmethod.f90->sourcefile~latentheat.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~update.f90~~AfferentGraph sourcefile~update.f90 Update.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_Update Source Code Update.f90 Source Code module Calculate_Update use , intrinsic :: iso_fortran_env , only : int32 , real64 use omp_lib use :: Types , g => GravityAcceleration use :: RootFinding_SecantMethod , only : Secant_method use :: RootFinding_BinaryFinding , only : Binary_finding implicit none private real ( real64 ), parameter :: threshold = 1.0d-20 real ( real64 ), parameter :: TtoK = 27 3.15d0 integer ( int32 ), parameter :: Linear = 1 , pTransition = 2 , NonLinear = 3 , nTransition = 4 public :: Update_Parameters_Heat public :: Update_Parameters_Water public :: Update_theta public :: Update_Si public :: Update_Phase_Revise public :: Update_Gradient contains subroutine Update_Parameters_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Update_theta ( Solver ) call Update_Variables_Geometric ( Solver % Heat % Variables % lambda % pre (:), Solver % Heat % Constants % ThermalConductivity , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) call Update_Variables_Arithmetic ( Solver % Heat % Variables % rho % pre (:), Solver % Heat % Constants % Density , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) call Update_Variables_Arithmetic ( Solver % Heat % Variables % Cp % pre (:), Solver % Heat % Constants % HeatCapacity , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) call Update_Variables_Arithmetic ( Solver % Heat % Variables % Cs % pre (:), Solver % Heat % Constants % SpecificHeat , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) if ( Solver % Flags % isGCC ) then call Update_Cpa_GCC ( Solver ) else if ( Solver % Flags % isPower ) then call Update_Cpa_Power ( Solver ) end if if ( Solver % Flags % isGCC . or . Solver % Flags % isPower ) then call Update_Phase ( Solver ) call Update_Cadiv ( Solver ) end if if ( Solver % isWater ) then call Update_Gradient ( Solver , Solver % P % pre (:), Solver % Water % Variables % hGrad ) call Update_Flux ( Solver % Water % Variables % wFlux , Solver % Water % Variables % Klh % pre (:), Solver % Water % Variables % hGrad ) call Update_Gradient ( Solver , Solver % T % pre (:), Solver % Heat % Variables % TGrad ) ! print*,Solver%Heat%Constants%HeatCapacity%water ! print*,Solver%Water%Variables%wFlux%x(1:30)*Solver%T%pre(1:30)*Solver%Heat%Constants%HeatCapacity%water ! stop call Update_Heat_Flux ( Solver % Heat % Variables % TFlux , Solver % Heat % Variables % lambda % pre (:), Solver % Heat % Variables % TGrad , Solver % Heat % Constants % HeatCapacity % water , Solver % Water % Variables % wFlux , Solver % T % pre ) end if end subroutine Update_Parameters_Heat subroutine Update_Parameters_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Update_Variables_Log ( Solver % Water % Variables % Klh % pre (:), Solver % Water % Constants % HydraulicConductivity , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) end subroutine Update_Parameters_Water subroutine Update_theta ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN real ( real64 ) :: Porosity Porosity = Solver % Heat % Constants % Porosity do iN = 1 , Solver % N % node Solver % mwater % pre ( iN ) = Porosity * ( 1 - Solver % Si % pre ( iN )) ! Water content is limited to the range of threshold to Porosity if ( Solver % mwater % pre ( iN ) < Porosity * threshold ) then Solver % mwater % pre ( iN ) = Porosity * threshold else if ( Solver % mwater % pre ( iN ) > Porosity ) then Solver % mwater % pre ( iN ) = Porosity end if ! Ice content is limited to the range of threshold to Porosity Solver % mIce % pre ( iN ) = Porosity * Solver % Si % pre ( iN ) Solver % mIce % dif ( iN ) = Solver % mIce % pre ( iN ) - Solver % mIce % old ( iN ) if ( Solver % mIce % dif ( iN ) > Porosity ) then Solver % mIce % dif ( iN ) = Porosity else if ( Solver % mIce % dif ( iN ) < - Porosity ) then Solver % mIce % dif ( iN ) = - Porosity end if end do end subroutine Update_theta subroutine Update_Variables_Arithmetic ( Targets , Const , Si , Porosity , Flags ) implicit none real ( real64 ), intent ( inout ) :: Targets (:) type ( Phases ), intent ( in ) :: Const real ( real64 ), intent ( in ) :: Si (:) real ( real64 ), intent ( in ) :: Porosity type ( Flag ), intent ( in ) :: Flags real ( real64 ) :: unfrozen , frozen integer ( int32 ) :: iN , nTarget nTarget = size ( Targets ) unfrozen = Const % soil * ( 1.0d0 - Porosity ) + Const % water * Porosity frozen = Const % soil * ( 1.0d0 - Porosity ) + Const % ice * Porosity if ( Flags % isTRM . and . Flags % isSwitchTRM ) then do iN = 1 , nTarget if ( Si ( iN ) == 1.0d0 ) Targets ( iN ) = frozen end do else do iN = 1 , nTarget Targets ( iN ) = Si ( iN ) * frozen + ( 1.0d0 - Si ( iN )) * unfrozen end do end if end subroutine Update_Variables_Arithmetic subroutine Update_Variables_Geometric ( Targets , Const , Si , Porosity , Flags ) implicit none real ( real64 ), intent ( inout ) :: Targets (:) type ( Phases ), intent ( in ) :: Const real ( real64 ), intent ( in ) :: Si (:) real ( real64 ), intent ( in ) :: Porosity type ( Flag ), intent ( in ) :: Flags real ( real64 ) :: unfrozen , frozen , rtWI integer ( int32 ) :: iN , nTarget nTarget = size ( Targets ) unfrozen = Const % soil ** ( 1.0d0 - Porosity ) * Const % water ** Porosity frozen = Const % soil ** ( 1.0d0 - Porosity ) * Const % ice ** Porosity rtWI = Const % ice / Const % water if ( Flags % isTRM . and . Flags % isSwitchTRM ) then do iN = 1 , nTarget if ( Si ( iN ) == 1.0d0 ) Targets ( iN ) = frozen end do else do iN = 1 , nTarget Targets ( iN ) = unfrozen * rtWI ** ( Porosity * Si ( iN )) end do end if end subroutine Update_Variables_Geometric subroutine Update_Variables_Log ( Targets , Const , Si , Porosity , Flags ) implicit none real ( real64 ), intent ( inout ) :: Targets (:) type ( Phases ), intent ( in ) :: Const real ( real64 ), intent ( in ) :: Si (:) real ( real64 ), intent ( in ) :: Porosity type ( Flag ), intent ( in ) :: Flags real ( real64 ) :: k integer ( int32 ) :: iN , nTarget nTarget = size ( Targets ) k = log10 ( Const % ice / Const % soil ) ! if (Flags%isTRM .and. Flags%isSwitchTRM) then !     do iN = 1, nTarget ! \t\tif (Si(iN) == 1.0d0) Targets(iN) = Const%soil !     end do ! else do iN = 1 , nTarget Targets ( iN ) = Const % soil * 10 ** ( k * Si ( iN )) end do ! end if end subroutine Update_Variables_Log subroutine Update_Cpa_GCC ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ) :: Qs , Qr , alpha , n , m , Tf , Lf , Dice , Cp real ( real64 ) :: A , B , C , T integer ( int32 ) :: iN Qs = Solver % Heat % Latent % GCC % thetaS Qr = Solver % Heat % Latent % GCC % thetaR alpha = Solver % Heat % Latent % GCC % alpha n = Solver % Heat % Latent % GCC % n m = Solver % Heat % Latent % GCC % m Tf = Solver % Heat % Latent % GCC % Tf Lf = Solver % Heat % Latent % Lf Dice = Solver % Heat % Latent % rhoI A = Qs - Qr B = alpha * Lf / g do iN = 1 , Solver % N % node T = Solver % T % pre ( iN ) Cp = Solver % Heat % Variables % Cp % pre ( iN ) if ( T < Tf ) then C = ( T + TtoK ) / ( Tf + TtoK ) Solver % Heat % Variables % Ca % pre ( iN ) = Cp - Lf * Dice * ( A * B ** 2 * n * m * log ( C ) * abs ( B * log ( C )) ** ( n - 2.d0 )) & / (( T + TtoK ) * ( 1.d0 + abs ( B * log ( C )) ** n ) ** ( m + 1.d0 )) else Solver % Heat % Variables % Ca % pre ( iN ) = Cp end if end do end subroutine Update_Cpa_GCC subroutine Update_Cpa_Power ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ) :: Lf , Dice , phi , Tf , a , Cp , T integer ( int32 ) :: iN Lf = Solver % Heat % Latent % Lf Dice = Solver % Heat % Latent % rhoI phi = Solver % Heat % Latent % Power % phi Tf = Solver % Heat % Latent % Power % Tf a = Solver % Heat % Latent % Power % a do iN = 1 , Solver % N % node T = Solver % T % pre ( iN ) Cp = Solver % Heat % Variables % Cp % pre ( iN ) if ( T < Tf ) then Solver % Heat % Variables % Ca % pre ( iN ) = Cp - Lf * Dice * phi * a * ( 1.0d0 - T + Tf ) ** ( a - 1.0d0 ) else Solver % Heat % Variables % Ca % pre ( iN ) = Cp end if end do end subroutine Update_Cpa_Power subroutine Update_Phase ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN real ( real64 ) :: Tp , To do iN = 1 , Solver % N % node Tp = Solver % T % pre ( iN ) To = Solver % T % old ( iN ) if ( Tp >= 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = Linear else if ( Tp < 0.0d0 . and . To < 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = NonLinear else if ( Tp < 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = pTransition else Solver % Heat % Variables % Phase ( iN ) = nTransition end if end do end subroutine Update_Phase subroutine Update_Phase_Revise ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN real ( real64 ) :: Tp , To do iN = 1 , Solver % N % node Tp = Solver % T % pre ( iN ) To = Solver % T % old ( iN ) if ( Tp >= 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = Linear else if ( Tp < 0.0d0 . and . To < 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = NonLinear else if ( Tp < 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = pTransition ! call Secant_method(Solver, iN) call Binary_finding ( Solver , iN ) else Solver % Heat % Variables % Phase ( iN ) = nTransition end if end do end subroutine Update_Phase_Revise subroutine Update_Cadiv ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN do iN = 1 , Solver % N % node if ( Solver % Heat % Variables % Phase ( iN ) == Linear ) then Solver % Heat % Variables % Ca % div ( iN ) = Solver % Heat % Variables % Ca % pre ( iN ) else if ( Solver % Heat % Variables % Phase ( iN ) == pTransition ) then if ( Solver % Flags % isGCC ) then Solver % Heat % Variables % Ca % div ( iN ) = ( Solver % Heat % Variables % Ca % pre ( iN ) * Solver % Heat % Latent % GCC % Ca_max ) ** 0.5d0 else if ( Solver % Flags % isPower ) then Solver % Heat % Variables % Ca % div ( iN ) = ( Solver % Heat % Variables % Ca % pre ( iN ) * Solver % Heat % Latent % Power % Ca_max ) ** 0.5d0 end if else if ( Solver % Heat % Variables % Phase ( iN ) == NonLinear ) then Solver % Heat % Variables % Ca % div ( iN ) = ( Solver % Heat % Variables % Ca % pre ( iN ) * Solver % Heat % Variables % Ca % old ( iN )) ** 0.5d0 end if end do end subroutine Update_Cadiv subroutine Update_Si ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ) :: A , B , C real ( real64 ) :: Qs , Qr , alpha , n , m , Lf , Dice , Tf integer ( int32 ) :: iN if ( Solver % Flags % isGCC ) then Qs = Solver % Heat % Latent % GCC % thetaS Qr = Solver % Heat % Latent % GCC % thetaR alpha = Solver % Heat % Latent % GCC % alpha n = Solver % Heat % Latent % GCC % n m = Solver % Heat % Latent % GCC % m Lf = Solver % Heat % Latent % Lf Dice = Solver % Heat % Latent % rhoI Tf = Solver % Heat % Latent % GCC % Tf A = Qs - Qr B = alpha * Lf / g do iN = 1 , Solver % N % node C = ( Solver % T % pre ( iN ) + TtoK ) / ( Tf + TtoK ) if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = ( A * ( 1.0d0 - ( 1.0d0 + abs ( B * log ( C )) ** n ) ** ( - m ))) / Qs else Solver % Si % pre ( iN ) = 0.0d0 end if end do else if ( Solver % Flags % isPower ) then Tf = Solver % Heat % Latent % Power % Tf alpha = Solver % Heat % Latent % Power % a do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = 1.0d0 - ( 1.0d0 - Solver % T % pre ( iN ) + Tf ) ** alpha else Solver % Si % pre ( iN ) = 0.0d0 end if end do end if end subroutine Update_Si subroutine Update_Gradient ( Solver , ar , Grad ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ), intent ( in ) :: ar (:) type ( DP2d ), intent ( inout ) :: Grad integer ( int32 ) :: counter ( SOlver % N % node ) integer ( int32 ) :: iN , p1 , p2 , p3 real ( real64 ) :: gx , gy counter (:) = 0 Grad % x (:) = 0.0d0 Grad % y (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) gx = ( Solver % N % Basis % b ( 1 , iN ) * ar ( p1 ) + Solver % N % Basis % b ( 2 , iN ) * ar ( p2 ) + Solver % N % Basis % b ( 3 , iN ) * ar ( p3 )) / ( 2.0d0 * Solver % N % eArea ( iN )) gy = ( Solver % N % Basis % c ( 1 , iN ) * ar ( p1 ) + Solver % N % Basis % c ( 2 , iN ) * ar ( p2 ) + Solver % N % Basis % c ( 3 , iN ) * ar ( p3 )) / ( 2.0d0 * Solver % N % eArea ( iN )) Grad % x ( p1 ) = Grad % x ( p1 ) + gx Grad % y ( p1 ) = Grad % y ( p1 ) + gy Grad % x ( p2 ) = Grad % x ( p2 ) + gx Grad % y ( p2 ) = Grad % y ( p2 ) + gy Grad % x ( p3 ) = Grad % x ( p3 ) + gx Grad % y ( p3 ) = Grad % y ( p3 ) + gy counter ( p1 ) = counter ( p1 ) + 1 counter ( p2 ) = counter ( p2 ) + 1 counter ( p3 ) = counter ( p3 ) + 1 end do Grad % x (:) = Grad % x (:) / counter (:) Grad % y (:) = Grad % y (:) / counter (:) end subroutine Update_Gradient subroutine Update_Flux ( Flux , C , Grad ) implicit none type ( DP2d ), intent ( inout ) :: Flux type ( DP2d ), intent ( in ) :: Grad real ( real64 ), intent ( in ) :: C (:) Flux % x (:) = - C (:) * Grad % x (:) Flux % y (:) = - C (:) * Grad % y (:) end subroutine Update_Flux subroutine Update_Heat_Flux ( TFlux , C , TGrad , Cw , Qw , T ) implicit none type ( DP2d ), intent ( inout ) :: TFlux type ( DP2d ), intent ( in ) :: TGrad real ( real64 ), intent ( in ) :: C (:) real ( real64 ), intent ( in ) :: Cw type ( DP2d ), intent ( in ) :: Qw real ( real64 ), intent ( in ) :: T (:) TFlux % x (:) = - C (:) * TGrad % x (:) TFlux % y (:) = - C (:) * TGrad % y (:) ! print*, TFlux%x(:) ! stop end subroutine Update_Heat_Flux end module Calculate_Update","tags":"","loc":"sourcefile/update.f90.html"},{"title":"Count.f90 – FTDSS","text":"This file depends on sourcefile~~count.f90~~EfferentGraph sourcefile~count.f90 Count.f90 sourcefile~types.f90 Types.f90 sourcefile~count.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~count.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~count.f90~~AfferentGraph sourcefile~count.f90 Count.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~count.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_Count Source Code Count.f90 Source Code module Calculate_Count use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: error implicit none interface Count_if procedure :: Count_if_int32 procedure :: Count_if_int32_Array end interface contains function Count_if_int32 ( array , Condition ) result ( count ) implicit none interface logical function Condition ( x ) integer , intent ( in ) :: x end function Condition end interface integer , intent ( in ) :: array (:) ! 入力配列 integer :: count ! 条件を満たす要素の個数 integer :: i count = 0 do i = 1 , size ( array ) if ( Condition ( array ( i ))) count = count + 1 end do end function Count_if_int32 function Count_if_int32_Array ( array , condition , condition_array ) result ( count ) implicit none interface logical function Condition ( x , condition_array ) integer , intent ( in ) :: x integer , intent ( in ) :: condition_array (:) end function Condition end interface integer , intent ( in ) :: array (:) ! 入力配列 integer , intent ( in ) :: condition_array (:) ! 条件配列 integer :: count ! 条件を満たす要素の個数 integer :: i count = 0 do i = 1 , size ( array ) if ( Condition ( array ( i ), condition_array )) count = count + 1 end do end function Count_if_int32_Array end module Calculate_Count","tags":"","loc":"sourcefile/count.f90.html"},{"title":"TRM.f90 – FTDSS","text":"This file depends on sourcefile~~trm.f90~~EfferentGraph sourcefile~trm.f90 TRM.f90 sourcefile~types.f90 Types.f90 sourcefile~trm.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_TRM Source Code TRM.f90 Source Code module Calculate_TRM use , intrinsic :: iso_fortran_env , only : int32 , real64 use omp_lib use types implicit none private public :: TRMethod contains subroutine TRMethod ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ), parameter :: vTf = 0.0d0 real ( real64 ) :: Fr_tmp real ( real64 ) :: C , TRM_BTM , tmpSi integer ( int32 ) :: iN , vector_size if ( Solver % Flags % isSwitchOnceTRM ) then TRM_BTM = 1.0d0 / Solver % Heat % Constants % Density % water * Solver % Heat % Constants % Porosity * Solver % Heat % Constants % LatentHeat ! $omp parallel do private(iN, C, tmpSi) do iN = 1 , Solver % N % node C = Solver % Heat % Variables % rho % pre ( iN ) * Solver % Heat % Variables % Cs % pre ( iN ) * TRM_BTM tmpSi = Solver % Si % old ( iN ) + C * ( vTf - Solver % T % new ( iN )) if ( tmpSi <= 0.0d0 . and . Solver % Si % old ( iN ) == 0.0d0 ) then Solver % Si % new ( iN ) = 0.0d0 else if ( tmpSi >= 1.0d0 . and . Solver % Si % old ( iN ) == 1.0d0 ) then Solver % Si % new ( iN ) = 1.0d0 else if ( 0.0d0 < tmpSi . and . tmpSi < 1.0d0 . and . Solver % Si % old ( iN ) <= 1.0d0 ) then Solver % T % new ( iN ) = vTf Solver % Si % new ( iN ) = tmpSi else if ( 0.0d0 < Solver % Si % old ( iN ) . and . Solver % Si % old ( iN ) < 1.0d0 . and . tmpSi >= 1.0d0 ) then Solver % T % new ( iN ) = vTf + ( 1.0d0 - tmpSi ) / C Solver % Si % new ( iN ) = 1.0d0 end if end do ! $omp end parallel do else ! $omp parallel do private(iN, C, tmpSi, TRM_BTM) ! print*,Solver%Heat%Variables%Cs%pre(:) ! stop do iN = 1 , Solver % N % node TRM_BTM = Solver % Heat % Constants % Density % water * Solver % Heat % Constants % LatentHeat C = Solver % Heat % Variables % rho % pre ( iN ) * Solver % Heat % Variables % Cs % pre ( iN ) / ( Solver % mWater % pre ( iN ) * TRM_BTM ) tmpSi = Solver % Si % old ( iN ) + C * ( vTf - Solver % T % new ( iN )) if ( tmpSi <= 0.0d0 . and . Solver % Si % old ( iN ) == 0.0d0 ) then Solver % Si % new ( iN ) = 0.0d0 else if ( tmpSi >= 1.0d0 . and . Solver % Si % old ( iN ) == 1.0d0 ) then Solver % Si % new ( iN ) = 1.0d0 else if ( 0.0d0 < tmpSi . and . tmpSi < 1.0d0 . and . Solver % Si % old ( iN ) <= 1.0d0 ) then Solver % T % new ( iN ) = vTf Solver % Si % new ( iN ) = tmpSi else if ( 0.0d0 < Solver % Si % old ( iN ) . and . Solver % Si % old ( iN ) < 1.0d0 . and . tmpSi >= 1.0d0 ) then Solver % T % new ( iN ) = vTf + ( 1.0d0 - tmpSi ) / C Solver % Si % new ( iN ) = 1.0d0 end if end do ! $omp end parallel do end if ! stop ! do iN = 250,260 ! \tprint*,Solver%Si%new(iN), Solver%T%new(iN) ! end do end subroutine TRMethod end module Calculate_TRM","tags":"","loc":"sourcefile/trm.f90.html"},{"title":"Observation.f90 – FTDSS","text":"This file depends on sourcefile~~observation.f90~~EfferentGraph sourcefile~observation.f90 Observation.f90 sourcefile~types.f90 Types.f90 sourcefile~observation.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~observation.f90->sourcefile~allocate.f90 sourcefile~points.f90 Points.f90 sourcefile~observation.f90->sourcefile~points.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~points.f90->sourcefile~types.f90 sourcefile~points.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_Observation Source Code Observation.f90 Source Code module Calculate_Observation use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: Allocate use :: Calculate_Points , only : Set_Point implicit none private interface Set_Obs_COO procedure :: Set_Obs_COO_31 end interface public :: Set_Obs_COO contains subroutine Set_Obs_COO_31 ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver type ( Vector2d ) :: p1 , p2 , p3 integer ( int32 ) :: iE , iObs , iS real ( real64 ) :: x , y , s call Allocate_Vector ( Solver % Obs % nAreaObs , Solver % Obs % nObs ) call Allocate_Matrix ( Solver % Obs % vAreaObs , Solver % N % ShCoe , Solver % Obs % nObs ) do iObs = 1 , Solver % Obs % nObs x = Solver % Obs % obsCOO % x ( iObs ) y = Solver % Obs % obsCOO % y ( iObs ) do iE = 1 , Solver % N % Element call Set_Point ( Solver % N , iE , p1 , p2 , p3 ) if ( is_in_triangle ( x , y , p1 , p2 , p3 )) then s = Solver % N % eArea ( iE ) do iS = 1 , Solver % N % ShCoe Solver % Obs % vAreaObs ( iS , iObs ) = ( Solver % N % Basis % a ( iS , iE ) + Solver % N % Basis % b ( iS , iE ) * x & & + Solver % N % Basis % c ( iS , iE ) * y ) / ( 2.0d0 * s ) end do Solver % Obs % nAreaObs ( iObs ) = iE exit end if end do end do end subroutine Set_Obs_COO_31 logical function is_in_triangle ( x , y , p1 , p2 , p3 ) implicit none type ( Vector2d ), intent ( in ) :: p1 , p2 , p3 real ( real64 ), intent ( in ) :: x , y is_in_triangle = . false . if ( 0.0d0 <= ( p2 % y - p3 % y ) * ( x - p3 % x ) + ( p3 % x - p2 % x ) * ( y - p3 % y ) . and . & & 0.0d0 <= ( p3 % y - p1 % y ) * ( x - p1 % x ) + ( p1 % x - p3 % x ) * ( y - p1 % y ) . and . & & 0.0d0 <= ( p1 % y - p2 % y ) * ( x - p2 % x ) + ( p2 % x - p1 % x ) * ( y - p2 % y )) then is_in_triangle = . true . end if end function is_in_triangle end module Calculate_Observation","tags":"","loc":"sourcefile/observation.f90.html"},{"title":"LatentHeat.f90 – FTDSS","text":"This file depends on sourcefile~~latentheat.f90~~EfferentGraph sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~types.f90 Types.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~latentheat.f90~~AfferentGraph sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~secantmethod.f90->sourcefile~latentheat.f90 sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~binaryfinding.f90->sourcefile~latentheat.f90 sourcefile~initialize.f90 Initialize.f90 sourcefile~initialize.f90->sourcefile~latentheat.f90 sourcefile~update.f90 Update.f90 sourcefile~update.f90->sourcefile~secantmethod.f90 sourcefile~update.f90->sourcefile~binaryfinding.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_LatentHeat Source Code LatentHeat.f90 Source Code module Calculate_LatentHeat use , intrinsic :: iso_fortran_env , only : int32 , real64 use omp_lib use :: Types , g => GravityAcceleration implicit none private real ( real64 ), parameter :: TtoK = 27 3.15d0 public :: Calc_LatentHeatTerm public :: LatentHeatTreatment public :: Find_Ca_max contains function Calc_LatentHeatTerm ( T , Tnew , Latent ) result ( res ) implicit none real ( real64 ) :: res real ( real64 ), intent ( in ) :: T , Tnew type ( LatentHeatTreatment ), intent ( in ) :: Latent ! 20: GCC, 30: Power if ( Latent % useModel == 20 ) then res = Latent % Cp_unf * ( T - Tnew ) - Latent % Lf * Latent % rhoI * ( Latent % GCC % thetaS - Latent % GCC % thetaR ) & * ( 1.0d0 - ( 1.0d0 + abs ( Latent % GCC % alpha * Latent % Lf * log (( TtoK + T ) / TtoK ) / g ) ** Latent % GCC % n ) ** ( - Latent % GCC % m )) else if ( Latent % useModel == 30 ) then res = Latent % Cp_unf * ( T - Tnew ) / ( Latent % Lf * Latent % rhoI * Latent % Power % phi ) & + ( 1.0d0 - T + Latent % Power % Tf ) ** Latent % Power % a - 1.0d0 end if end function Calc_LatentHeatTerm function Calc_Ca_GCC ( Heat , T ) result ( Ca ) implicit none type ( HeatFields ), intent ( in ) :: Heat real ( real64 ), intent ( in ) :: T real ( real64 ) :: Ca real ( real64 ) :: Cp , Si , A , B , C real ( real64 ) :: Qs , Qr , alpha , n , m , Lf , Dice , Tf Qs = Heat % Latent % GCC % thetaS Qr = Heat % Latent % GCC % thetaR alpha = Heat % Latent % GCC % alpha n = Heat % Latent % GCC % n m = Heat % Latent % GCC % m Lf = Heat % Latent % Lf Dice = Heat % Latent % rhoI Tf = Heat % Latent % GCC % Tf A = Qs - Qr B = alpha * Lf / g C = ( T + TtoK ) / ( Tf + TtoK ) if ( T < Tf ) then Si = ( A * ( 1.0d0 - ( 1.0d0 + abs ( B * log ( C )) ** n ) ** ( - m ))) / Qs else Si = 0.0d0 end if Cp = Heat % Constants % HeatCapacity % soil * ( 1.0d0 - Heat % Constants % Porosity ) & + Heat % Constants % HeatCapacity % water * Heat % Constants % Porosity * ( 1.0d0 - Si ) & + Heat % Constants % HeatCapacity % ice * Heat % Constants % Porosity * Si if ( T < Tf ) then Ca = Cp - Lf * Dice * ( A * B ** 2 * n * m * log ( C ) * abs ( B * log ( C )) ** ( n - 2.d0 )) & / (( T + TtoK ) * ( 1.d0 + abs ( B * log ( C )) ** n ) ** ( m + 1.d0 )) else Ca = Cp end if end function Calc_Ca_GCC subroutine Find_Ca_max ( Heat ) implicit none type ( HeatFields ), intent ( inout ) :: Heat real ( real64 ) :: x0 , x1 , x2 , x3 , f1 , f2 , tau real ( real64 ), parameter :: epsilon = 1.0d-15 if ( Heat % Latent % useModel == 20 ) then tau = ( sqrt ( 5.d0 ) - 1.d0 ) / 2.d0 ! 黄金比 x0 = 0.0d0 x3 = - 1.0d0 x1 = x0 + ( 1.d0 - tau ) * ( x3 - x0 ) x2 = x0 + tau * ( x3 - x0 ) f1 = Calc_Ca_GCC ( Heat , x1 ) f2 = Calc_Ca_GCC ( Heat , x2 ) do while ( abs ( x3 - x0 ) > epsilon ) if ( f2 > f1 ) then x0 = x1 x1 = x2 x2 = x0 + tau * ( x3 - x0 ) f1 = f2 f2 = Calc_Ca_GCC ( Heat , x2 ) else x3 = x2 x2 = x1 x1 = x0 + ( 1.d0 - tau ) * ( x3 - x0 ) f2 = f1 f1 = Calc_Ca_GCC ( Heat , x1 ) end if end do Heat % Latent % GCC % Ca_max = Calc_Ca_GCC ( Heat , ( x1 + x2 ) / 2.d0 ) else if ( Heat % Latent % useModel == 30 ) then Heat % Latent % Power % Ca_max = Heat % Latent % Cp_unf - Heat % Latent % Lf * Heat % Latent % rhoI * Heat % Latent % Power % phi * Heat % Latent % Power % a end if end subroutine Find_Ca_max end module Calculate_LatentHeat","tags":"","loc":"sourcefile/latentheat.f90.html"},{"title":"GCC.f90 – FTDSS","text":"Contents Modules Calculate_GCC Source Code GCC.f90 Source Code module Calculate_GCC use , intrinsic :: iso_fortran_env , only : int32 , real64 implicit none private real ( real64 ), parameter :: g = 9.80665d0 real ( real64 ), parameter :: TtoK = 27 3.15d0 public :: Calculate_GCC_NonSegregation public :: Calculate_GCC_Segregation public :: Set_Calculate_GCC_Segregation interface Calculate_GCC_NonSegregation module procedure Calculate_GCC_NonSegregation_kPa module procedure Calculate_GCC_NonSegregation_m end interface Calculate_GCC_NonSegregation interface Calculate_GCC_NonSegregation_Derivative module procedure Calculate_GCC_NonSegregation_Derivative_kPa module procedure Calculate_GCC_NonSegregation_Derivative_m end interface Calculate_GCC_NonSegregation_Derivative abstract interface function Calculate_GCC_Segregation_interface ( T , Pw , Tf , Lf , rhoW , rhoI ) result ( Suction ) use , intrinsic :: iso_fortran_env , only : real64 implicit none real ( real64 ), intent ( in ) :: T , Pw , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction end function Calculate_GCC_Segregation_interface end interface procedure ( Calculate_GCC_Segregation_interface ), pointer :: Calculate_GCC_Segregation => null () procedure ( Calculate_GCC_Segregation_interface ), pointer :: Calculate_GCC_Segregation_Derivative => null () contains function Calculate_GCC_NonSegregation_kPa ( T , Tf , Lf , rhoW ) result ( Suction_kPa ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf , rhoW real ( real64 ) :: Suction_kPa if ( T <= Tf ) then Suction_kPa = - Lf * rhoW * log (( T + TtoK ) / ( Tf + TtoK )) else Suction_kPa = 0.0d0 end if end function Calculate_GCC_NonSegregation_kPa function Calculate_GCC_NonSegregation_m ( T , Tf , Lf ) result ( Suction_m ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf real ( real64 ) :: Suction_m if ( T <= Tf ) then Suction_m = - Lf * log (( T + TtoK ) / ( Tf + TtoK )) / g else Suction_m = 0.0d0 end if end function Calculate_GCC_NonSegregation_m function Calculate_GCC_NonSegregation_Derivative_kPa ( T , Tf , Lf , rhoW ) result ( Suction_kPa_Derivative ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf , rhoW real ( real64 ) :: Suction_kPa_Derivative if ( T <= Tf ) then Suction_kPa_Derivative = - Lf * rhoW / ( T + TtoK ) else Suction_kPa_Derivative = 0.0d0 end if end function Calculate_GCC_NonSegregation_Derivative_kPa function Calculate_GCC_NonSegregation_Derivative_m ( T , Tf , Lf ) result ( Suction_m ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf real ( real64 ) :: Suction_m if ( T <= Tf ) then Suction_m = - Lf / (( T + TtoK ) * g ) else Suction_m = 0.0d0 end if end function Calculate_GCC_NonSegregation_Derivative_m subroutine Set_Calculate_GCC_Segregation ( Segregation_type ) implicit none integer ( int32 ), intent ( in ) :: Segregation_type if ( associated ( Calculate_GCC_Segregation )) nullify ( Calculate_GCC_Segregation ) if ( associated ( Calculate_GCC_Segregation_Derivative )) nullify ( Calculate_GCC_Segregation_Derivative ) select case ( Segregation_type ) case ( 1 ) Calculate_GCC_Segregation => Calculate_GCC_Segregation_kPa Calculate_GCC_Segregation_Derivative => Calculate_GCC_Segregation_Derivative_kPa case ( 2 ) Calculate_GCC_Segregation => Calculate_GCC_Segregation_m Calculate_GCC_Segregation_Derivative => Calculate_GCC_Segregation_Derivative_m end select end subroutine Set_Calculate_GCC_Segregation function Calculate_GCC_Segregation_kPa ( T , Pw_kPa , Tf , Lf , rhoW , rhoI ) result ( Suction_kPa ) implicit none real ( real64 ), intent ( in ) :: T , Pw_kPa , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_kPa if ( T <= Tf ) then Suction_kPa = ( rhoI / rhoW - 1.0d0 ) * Pw_kPa - Lf * rhoI * log (( T + TtoK ) / ( Tf + TtoK )) else Suction_kPa = 0.0d0 end if end function Calculate_GCC_Segregation_kPa function Calculate_GCC_Segregation_m ( T , Pw_m , Tf , Lf , rhoW , rhoI ) result ( Suction_m ) implicit none real ( real64 ), intent ( in ) :: T , Pw_m , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_m if ( T <= Tf ) then Suction_m = (( rhoI / rhoW - 1.0d0 ) * Pw_m - Lf * rhoI * log (( T + TtoK ) / ( Tf + TtoK ))) / ( rhoW * g ) else Suction_m = 0.0d0 end if end function Calculate_GCC_Segregation_m function Calculate_GCC_Segregation_Derivative_kPa ( T , Pw_kPa , Tf , Lf , rhoW , rhoI ) result ( Suction_kPa_Derivative ) implicit none real ( real64 ), intent ( in ) :: T , Pw_kPa , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_kPa_Derivative if ( T <= Tf ) then Suction_kPa_Derivative = - Lf * rhoW / ( T + TtoK ) else Suction_kPa_Derivative = 0.0d0 end if end function Calculate_GCC_Segregation_Derivative_kPa function Calculate_GCC_Segregation_Derivative_m ( T , Pw_m , Tf , Lf , rhoW , rhoI ) result ( Suction_m_Derivative ) implicit none real ( real64 ), intent ( in ) :: T , Pw_m , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_m_Derivative if ( T <= Tf ) then Suction_m_Derivative = - Lf / (( T + TtoK ) * g ) else Suction_m_Derivative = 0.0d0 end if end function Calculate_GCC_Segregation_Derivative_m end module Calculate_GCC","tags":"","loc":"sourcefile/gcc.f90.html"},{"title":"Shape.f90 – FTDSS","text":"This file depends on sourcefile~~shape.f90~~EfferentGraph sourcefile~shape.f90 Shape.f90 sourcefile~types.f90 Types.f90 sourcefile~shape.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~shape.f90->sourcefile~error.f90 sourcefile~points.f90 Points.f90 sourcefile~shape.f90->sourcefile~points.f90 sourcefile~points.f90->sourcefile~types.f90 sourcefile~points.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_Shape Source Code Shape.f90 Source Code module Calculate_Shape use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: error use :: Calculate_Points , only : Set_Point implicit none interface Calc_Shape procedure :: Calc_Shape_31 end interface contains subroutine Calc_Shape_31 ( Geometry ) implicit none type ( Geometry2d ), intent ( inout ) :: Geometry type ( Vector2d ) :: p1 , p2 , p3 integer ( int32 ) :: iE do iE = 1 , Geometry % Element call set_point ( Geometry , iE , p1 , p2 , p3 ) if ( iE < 1 . or . iE > Geometry % Element ) then call error_message ( 932 ) else Geometry % Basis % a ( 1 , iE ) = p2 % x * p3 % y - p3 % x * p2 % y Geometry % Basis % a ( 2 , iE ) = p3 % x * p1 % y - p1 % x * p3 % y Geometry % Basis % a ( 3 , iE ) = p1 % x * p2 % y - p2 % x * p1 % y Geometry % Basis % b ( 1 , iE ) = p2 % y - p3 % y Geometry % Basis % b ( 2 , iE ) = p3 % y - p1 % y Geometry % Basis % b ( 3 , iE ) = p1 % y - p2 % y Geometry % Basis % c ( 1 , iE ) = p3 % x - p2 % x Geometry % Basis % c ( 2 , iE ) = p1 % x - p3 % x Geometry % Basis % c ( 3 , iE ) = p2 % x - p1 % x end if end do end subroutine Calc_Shape_31 end module Calculate_Shape","tags":"","loc":"sourcefile/shape.f90.html"},{"title":"BLAS.f90 – FTDSS","text":"This file depends on sourcefile~~blas.f90~~EfferentGraph sourcefile~blas.f90 BLAS.f90 sourcefile~types.f90 Types.f90 sourcefile~blas.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~blas.f90~~AfferentGraph sourcefile~blas.f90 BLAS.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~blas.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Calculate_BLAS Source Code BLAS.f90 Source Code module Calculate_BLAS use omp_lib use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none private public :: norm_2 public :: ddots contains function norm_2 ( N , x ) result ( norm ) implicit none integer ( int32 ), intent ( in ) :: N real ( real64 ), intent ( in ) :: x (:) real ( real64 ) :: norm integer ( int32 ) :: iN , ithread , nthreads real ( real64 ), allocatable :: partial_sums (:) ! nthreads = omp_get_max_threads() ! allocate(partial_sums(nthreads)) ! partial_sums = 0.0d0 norm = 0.0d0 ! $omp parallel private(iN, ithread) ! ithread = omp_get_thread_num() + 1 ! $omp do do iN = 1 , N norm = norm + x ( iN ) ** 2 end do ! $omp end do ! $omp end parallel ! メモリ解放 deallocate ( partial_sums ) end function norm_2 function ddots ( N , x , y ) result ( dot ) implicit none integer ( int32 ), intent ( in ) :: N real ( real64 ), intent ( in ) :: x (:), y (:) real ( real64 ) :: dot integer ( int32 ) :: iN , ithread , nthreads real ( real64 ), allocatable :: partial_sums (:) ! nthreads = omp_get_max_threads() ! allocate(partial_sums(nthreads)) ! partial_sums = 0.0d0 dot = 0.0d0 ! $omp parallel private(iN, ithread) ! ithread = omp_get_thread_num() + 1 ! $omp do do iN = 1 , N dot = dot + x ( iN ) * y ( iN ) end do ! $omp end do ! $omp end parallel ! dot = sum(partial_sums) end function ddots end module Calculate_BLAS","tags":"","loc":"sourcefile/blas.f90.html"},{"title":"Types.f90 – FTDSS","text":"Files dependent on this one sourcefile~~types.f90~~AfferentGraph sourcefile~types.f90 Types.f90 sourcefile~convertcrs.f90 ConvertCRS.f90 sourcefile~convertcrs.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~convertcrs.f90->sourcefile~allocate.f90 sourcefile~trm.f90 TRM.f90 sourcefile~trm.f90->sourcefile~types.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~latentheat.f90->sourcefile~types.f90 sourcefile~fixboundarycondition.f90 FixBoundaryCondition.f90 sourcefile~fixboundarycondition.f90->sourcefile~types.f90 sourcefile~findind.f90 FindInd.f90 sourcefile~fixboundarycondition.f90->sourcefile~findind.f90 sourcefile~output.f90 Output.f90 sourcefile~output.f90->sourcefile~types.f90 sourcefile~output.f90->sourcefile~allocate.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~hcf.f90 HCF.f90 sourcefile~hcf.f90->sourcefile~types.f90 sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~secantmethod.f90->sourcefile~types.f90 sourcefile~secantmethod.f90->sourcefile~latentheat.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~types.f90 sourcefile~fixinitialcondition.f90->sourcefile~fixboundarycondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate_structure.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~solve.f90 Solve.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 sourcefile~update.f90 Update.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~shape.f90 Shape.f90 sourcefile~shape.f90->sourcefile~types.f90 sourcefile~points.f90 Points.f90 sourcefile~shape.f90->sourcefile~points.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~types.f90 sourcefile~heat.f90->sourcefile~allocate.f90 sourcefile~heat.f90->sourcefile~hcf.f90 sourcefile~heat.f90->sourcefile~allocate_structure.f90 sourcefile~count.f90 Count.f90 sourcefile~heat.f90->sourcefile~count.f90 sourcefile~initialize.f90 Initialize.f90 sourcefile~initialize.f90->sourcefile~types.f90 sourcefile~initialize.f90->sourcefile~latentheat.f90 sourcefile~initialize.f90->sourcefile~allocate.f90 sourcefile~count.f90->sourcefile~types.f90 sourcefile~stdout.f90 Stdout.f90 sourcefile~stdout.f90->sourcefile~types.f90 sourcefile~blas.f90 BLAS.f90 sourcefile~blas.f90->sourcefile~types.f90 sourcefile~precon_jacobi.f90 Precon_jacobi.f90 sourcefile~precon_jacobi.f90->sourcefile~types.f90 sourcefile~product.f90 Product.f90 sourcefile~product.f90->sourcefile~types.f90 sourcefile~assemble.f90->sourcefile~types.f90 sourcefile~assemble.f90->sourcefile~allocate.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~assemble.f90->sourcefile~product.f90 sourcefile~assemble.f90->sourcefile~findind.f90 sourcefile~points.f90->sourcefile~types.f90 sourcefile~solve.f90->sourcefile~types.f90 sourcefile~solve.f90->sourcefile~allocate.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~solve.f90->sourcefile~blas.f90 sourcefile~solve.f90->sourcefile~precon_jacobi.f90 sourcefile~solve.f90->sourcefile~product.f90 sourcefile~update.f90->sourcefile~types.f90 sourcefile~update.f90->sourcefile~secantmethod.f90 sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~update.f90->sourcefile~binaryfinding.f90 sourcefile~observation.f90 Observation.f90 sourcefile~observation.f90->sourcefile~types.f90 sourcefile~observation.f90->sourcefile~allocate.f90 sourcefile~observation.f90->sourcefile~points.f90 sourcefile~initcopy.f90 InitCopy.f90 sourcefile~initcopy.f90->sourcefile~types.f90 sourcefile~binaryfinding.f90->sourcefile~types.f90 sourcefile~binaryfinding.f90->sourcefile~latentheat.f90 sourcefile~findind.f90->sourcefile~types.f90 sourcefile~area.f90 Area.f90 sourcefile~area.f90->sourcefile~types.f90 sourcefile~area.f90->sourcefile~points.f90 sourcefile~wrf.f90 WRF.f90 sourcefile~wrf.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Types Source Code Types.f90 Source Code module Types use , intrinsic :: iso_fortran_env , only : int32 , real64 implicit none public #ifdef _MPI include 'mpif.h' #endif integer ( int32 ), parameter :: Temperature = 1 , Pressure = 2 , Stress = 3 integer ( int32 ), parameter :: Linear = 1 , pTransition = 2 , NonLinear = 3 , nTransition = 4 real ( real64 ), parameter :: GravityAcceleration = 9.80655d0 integer ( int32 ), parameter :: undumped = 0 , dumped = 1 type :: VC sequence real ( real64 ) :: x , y end type VC type :: Vector2D sequence real ( real64 ) :: x , y end type Vector2D type :: Vector3D sequence real ( real64 ) :: x , y , z end type Vector3D type :: DP2d sequence real ( real64 ), allocatable :: x (:), y (:) end type DP2d type :: DP3d sequence real ( real64 ), allocatable :: x (:), y (:), z (:) end type DP3d type :: INT2d sequence integer ( int32 ), allocatable :: x (:), y (:) end type INT2d type :: INT3d sequence integer ( int32 ), allocatable :: x (:), y (:), z (:) end type INT3d type :: PH sequence real ( real64 ) :: soil , water , ice end type PH type :: Phases sequence real ( real64 ) :: soil , water , ice end type Phases type :: Shape sequence real ( real64 ), allocatable :: a (:, :), b (:, :), c (:, :), d (:, :) end type Shape type :: BoudaryConditionInfo integer ( int32 ), allocatable :: Node (:) ! <= BC.in integer ( int32 ), allocatable :: TypeKey (:) ! <= BC.in integer ( int32 ), allocatable :: type (:) ! <= BCtype.in real ( real64 ), allocatable :: value (:) ! <= BCtype.in type ( INT2d ) :: Edges integer ( int32 ), allocatable :: EdgesDirection (:) real ( real64 ), allocatable :: EdgesDistance (:) end type BoudaryConditionInfo type :: BoudaryCondition type ( BoudaryConditionInfo ) :: Heat , Water , Stress integer ( int32 ) :: numNode , numType , numEdges end type BoudaryCondition type :: Boudary_Condition_Dirichlet integer ( int32 ) :: Num_Node , Num_Type integer ( int32 ), allocatable :: Node (:), Node_Type (:), Value_Info (:) real ( real64 ), allocatable :: value (:) end type Boudary_Condition_Dirichlet type :: Boudary_Condition_Neumann integer ( int32 ) :: Num_Edge , Num_Edge_Type , Num_Type integer ( int32 ), allocatable :: Edge (:, :), Edge_Type (:), Value_Info (:) real ( real64 ), allocatable :: value (:), Heat_Transfer (:) end type Boudary_Condition_Neumann type :: Boudary_Condition type ( Boudary_Condition_Dirichlet ) :: Dirichlet type ( Boudary_Condition_Neumann ) :: Neumann end type Boudary_Condition type :: InitialConditionInfo integer ( int32 ) :: type real ( real64 ) :: value logical :: isSet end type InitialConditionInfo type :: InitialCondition type ( InitialConditionInfo ) :: Heat , Water , Stress end type InitialCondition #ifdef _MPI type :: MPIInfo integer ( int32 ) :: size , rank end type MPIInfo #endif type :: Basic_params integer ( int32 ) :: Element integer ( int32 ) :: Node integer ( int32 ) :: Shape integer ( int32 ) :: Dim integer ( int32 ) :: Region character (:), allocatable :: Calculation_timeUnit character (:), allocatable :: Input_timeUnit character (:), allocatable :: Output_timeUnit character (:), allocatable :: Interval_timeUnit integer ( int32 ) :: Calculation_step integer ( int32 ) :: CalculationPeriod integer ( int32 ) :: Interval logical :: isDisplayPrompt character (:), allocatable :: FileOutput real ( real64 ) :: TimeDiscretization end type Basic_params type :: Type_Solver class ( Base_Solver ), allocatable :: Thermal ! Solver for heat transfer class ( Base_Solver ), allocatable :: Hydraulic ! Solver for water flow end type Type_Solver type :: Base_Solver integer ( int32 ) :: useSolver ! Solver fpr execute solution 1: Direct, 2: 22Iterative end type Base_Solver type , extends ( Base_Solver ) :: Type_Solver_Iterative integer ( int32 ) :: SolverType ! Solver type integer ( int32 ) :: PreconditionerType ! Preconditioner type integer ( int32 ) :: MaxIter ! Maximum number of iterations real ( real64 ) :: Tol ! Convergence criterion end type Type_Solver_Iterative type :: Base_Density end type Base_Density type , extends ( Base_Density ) :: Type_Density_3Phase real ( real64 ) :: Soil , Water , Ice end type Type_Density_3Phase type , extends ( Base_Density ) :: Type_Density_2Phase real ( real64 ) :: Phase1 , Phase2 end type Type_Density_2Phase type , extends ( Base_Density ) :: Type_Density_1Phase real ( real64 ) :: Phase1 end type Type_Density_1Phase type :: Base_SpecificHeat end type Base_SpecificHeat type , extends ( Base_SpecificHeat ) :: Type_SpecificHeat_3Phase real ( real64 ) :: Soil ! Soil specific heat real ( real64 ) :: Water ! Water specific heat real ( real64 ) :: Ice ! Ice specific heat end type Type_SpecificHeat_3Phase type , extends ( Base_SpecificHeat ) :: Type_SpecificHeat_2Phase real ( real64 ) :: Phase1 , Phase2 end type Type_SpecificHeat_2Phase type , extends ( Base_SpecificHeat ) :: Type_SpecificHeat_1Phase real ( real64 ) :: Phase1 end type Type_SpecificHeat_1Phase type :: Base_ThermalConductivity end type Base_ThermalConductivity type , extends ( Base_ThermalConductivity ) :: Type_ThermalConductivity_3Phase real ( real64 ) :: Soil , Water , Ice end type Type_ThermalConductivity_3Phase type , extends ( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_2D type ( Vector2D ) :: dispersity end type Type_ThermalConductivity_3Phase_Dispersity_2D type , extends ( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_3D type ( Vector3D ) :: dispersity end type Type_ThermalConductivity_3Phase_Dispersity_3D type , extends ( Base_ThermalConductivity ) :: Type_ThermalConductivity_2Phase real ( real64 ) :: Phase1 , Phase2 end type Type_ThermalConductivity_2Phase type , extends ( Base_ThermalConductivity ) :: Type_ThermalConductivity_1Phase real ( real64 ) :: Phase1 end type Type_ThermalConductivity_1Phase type :: Base_Ice real ( real64 ) :: LatentHeat end type Base_Ice type , extends ( Base_Ice ) :: Type_Ice_TRM real ( real64 ) :: Tf end type Type_Ice_TRM type , extends ( Base_Ice ) :: Type_Ice_GCC real ( real64 ) :: Tf integer ( int32 ) :: ModelType class ( Base_WRF ), allocatable :: WRF end type Type_Ice_GCC type , extends ( Base_Ice ) :: Type_Ice_EXP real ( real64 ) :: Tf , a end type Type_Ice_EXP type :: Type_Thermal class ( Base_Density ), allocatable :: Density class ( Base_SpecificHeat ), allocatable :: SpecificHeat class ( Base_ThermalConductivity ), allocatable :: ThermalConductivity real ( real64 ) :: Porosity class ( Base_Ice ), allocatable :: Ice end type Type_Thermal type :: Type_Hydraulic integer ( int32 ) :: useHCF class ( Base_HCF ), allocatable :: HCF logical :: useImpedance class ( Base_Impedance ), allocatable :: Impedance integer ( int32 ) :: useKTDynamics class ( Base_KTDynamics ), allocatable :: KTDynamics real ( real64 ) :: Ks end type Type_Hydraulic type Base_Impedance end type Base_Impedance type , extends ( Base_Impedance ) :: Type_Impedance real ( real64 ) :: Omega end type Type_Impedance type :: Base_KTDynamics end type Base_KTDynamics type , extends ( Base_KTDynamics ) :: Type_KTDynamics real ( real64 ) :: kzero end type Type_KTDynamics type :: Type_Region_Flags logical :: isHeat , isWater , isStress logical :: is1Phase , is2Phase , is3Phase logical :: isCompression , isFrostHeavePressure , isDispersity logical :: isFrozen end type Type_Region_Flags type :: Type_Region integer ( int32 ) :: CalculationType integer ( int32 ) :: Modelnumber type ( Type_Thermal ) :: Thermal type ( Type_Hydraulic ) :: Hydraulic type ( Type_Region_Flags ) :: Flags end type Type_Region type :: DF real ( real64 ), allocatable :: new (:), old (:), pre (:), dif (:), div (:), tmp (:) end type DF type :: Flag logical :: isTRM , isGCC , isPower , isSwitchTRM , isSwitchOnceTRM logical :: isStdOut , isOutputAll , isOutput , isPrintLisMem logical , allocatable :: outOBS (:) end type Flag type :: CRS integer ( int32 ) :: nnz integer ( int32 ), allocatable :: Ptr (:), Ind (:) real ( real64 ), allocatable :: Val (:) end type CRS type :: Lis integer ( int32 ) :: TSolver , TOption , PSolver , POption , Maxiter real ( real64 ) :: Tol logical :: isOMP end type Lis type :: Observation2d integer ( int32 ) :: nObs , nObsType ! 1: Nodes integer ( int32 ), allocatable :: obsPoint (:) ! 2: Coordinate type ( DP2d ) :: obsCOO integer ( int32 ), allocatable :: nAreaObs (:) real ( real64 ), allocatable :: vAreaObs (:, :) end type Observation2d type :: HeatVariables type ( DF ) :: Cs , Cp , lambda , rho , Ca type ( DP2d ) :: Tgrad , TFlux integer ( int32 ), allocatable :: Phase (:) end type HeatVariables type HeatConstants type ( Phases ) :: Density , ThermalConductivity , SpecificHeat , HeatCapacity type ( Vector2d ) :: dispersity real ( real64 ) :: Porosity , LatentHeat end type HeatConstants type PowerModel real ( real64 ) :: phi , Tf , a real ( real64 ) :: Ca_max end type PowerModel type :: GCCModel real ( real64 ) :: thetaS , thetaR , alpha , n , m real ( real64 ) :: Tf real ( real64 ) :: Ca_max end type GCCModel type :: WRF_Parameters ! w1, w2は先に計算しておく real ( real64 ) :: thetaS , thetaR , alpha1 , alpha2 , n1 , n2 , m1 , m2 , hcrit , w1 , w2 end type WRF_Parameters type :: Base_WRF real ( real64 ) :: thetaS , thetaR end type Base_WRF type , extends ( Base_WRF ) :: Type_WRF_BC real ( real64 ) :: alpha1 , n1 end type Type_WRF_BC type , extends ( Base_WRF ) :: Type_WRF_VG real ( real64 ) :: alpha1 , n1 , m1 end type Type_WRF_VG type , extends ( Base_WRF ) :: Type_WRF_KO real ( real64 ) :: alpha1 , n1 end type Type_WRF_KO type , extends ( Base_WRF ) :: Type_WRF_MVG real ( real64 ) :: alpha1 , n1 , m1 , hcrit end type Type_WRF_MVG type , extends ( Base_WRF ) :: Type_WRF_Durner real ( real64 ) :: alpha1 , n1 , m1 , alpha2 , n2 , m2 , w1 , w2 end type Type_WRF_Durner type , extends ( Base_WRF ) :: Type_WRF_DVGCH real ( real64 ) :: alpha1 , n1 , m1 , n2 , m2 , w1 , w2 end type Type_WRF_DVGCH type :: HCF_Parameters real ( real64 ) :: thetaS , thetaR , alpha1 , alpha2 , n1 , n2 , m1 , m2 , hcrit , w1 , w2 real ( real64 ) :: Ks , kzero , l , Omega end type HCF_Parameters type :: Base_HCF real ( real64 ) :: thetaS , thetaR end type Base_HCF type , extends ( Base_HCF ) :: Type_HCF_BC real ( real64 ) :: alpha1 , n1 , l end type Type_HCF_BC type , extends ( Base_HCF ) :: Type_HCF_VG real ( real64 ) :: alpha1 , n1 , m1 , l end type Type_HCF_VG type , extends ( Base_HCF ) :: Type_HCF_KO real ( real64 ) :: alpha1 , n1 end type Type_HCF_KO type , extends ( Base_HCF ) :: Type_HCF_MVG real ( real64 ) :: alpha1 , n1 , m1 , hcrit , l end type Type_HCF_MVG type , extends ( Base_HCF ) :: Type_HCF_Durner real ( real64 ) :: alpha1 , n1 , m1 , alpha2 , n2 , m2 , w1 , w2 , l end type Type_HCF_Durner type , extends ( Base_HCF ) :: Type_HCF_DVGCH real ( real64 ) :: alpha1 , n1 , m1 , n2 , m2 , w1 , w2 , l end type Type_HCF_DVGCH type :: LatentHeatTreatment integer ( int32 ) :: useModel ! 20: GCC, 30: Power real ( real64 ) :: Lf , rhoI real ( real64 ) :: Cp_unf type ( GCCModel ) :: GCC type ( PowerModel ) :: Power end type LatentHeatTreatment type :: HeatFields type ( HeatVariables ) :: Variables type ( HeatConstants ) :: Constants type ( LatentHeatTreatment ) :: Latent type ( CRS ) :: LHS_A real ( real64 ), allocatable :: RA (:, :) real ( real64 ), allocatable :: Rhs (:) end type HeatFields type WaterVariables type ( DF ) :: Klh type ( DP2d ) :: wFlux , hGrad end type WaterVariables type WaterConstants type ( Phases ) :: HydraulicConductivity real ( real64 ) :: zeta end type WaterConstants type :: WaterFields type ( WaterVariables ) :: Variables type ( WaterConstants ) :: Constants type ( CRS ) :: LHS_A real ( real64 ), allocatable :: RA (:, :) real ( real64 ), allocatable :: Rhs (:) end type WaterFields type :: Geometry2d integer ( int32 ) :: element , node , shape , dim , ShCoe integer ( int32 ), allocatable :: pElement (:, :) type ( DP2d ) :: vCood real ( real64 ), allocatable :: eArea (:) type ( Shape ) :: Basis end type Geometry2d type :: Geometry_2D integer ( int32 ) :: Num_Elements , Num_Nodes , Num_Shape , Num_Dimention , Num_Shape_Type , Num_Region integer ( int32 ), allocatable :: Element (:, :) integer ( int32 ), allocatable :: Element_Region (:), COO_Region (:) type ( DP2d ) :: Nodes_2D real ( real64 ), allocatable :: Area (:) type ( Shape ) :: Shape_Function end type Geometry_2D type :: TimeInfo character ( 3 ) :: tUnit ! tUnit <- nmk 1: Second, 2: Minute, 3: Hour, 4: Day, 5: Month, 6: Year ! n : Calculation time unit, m: dt unit, k: output interval time unit real ( real64 ) :: cTime , cdt , cinterval real ( real64 ) :: ts , te , max_dt , min_dt , tconv real ( real64 ), pointer :: tst , dt , odt end type TimeInfo type :: Iteration integer ( int32 ) :: itermax , iNLmax , iNI integer ( int32 ), pointer :: iter , titer , iNL integer ( int32 ) :: digits_itermax end type Iteration type :: SolverInfo type ( Geometry2d ) :: N logical :: isHeat , isWater , isStress integer ( int32 ) :: nAnalysis , nFrTreat , nTimeDisc , isStdOut , outputFile type ( TimeInfo ) :: Time type ( Iteration ) :: Iter type ( Observation2d ) :: Obs type ( HeatFields ) :: Heat type ( WaterFields ) :: Water type ( BoudaryCondition ) :: BC type ( InitialCondition ) :: IC type ( DF ) :: mWater , mIce type ( DF ) :: T , P type ( DF ) :: Si , Sw type ( Lis ) :: Lis type ( Flag ) :: Flags character ( 64 ) :: fmt_Stdout , fmt_Fileout #ifdef _MPI type ( MPIInfo ) :: MPI #endif end type SolverInfo end module Types","tags":"","loc":"sourcefile/types.f90.html"},{"title":"Solve.f90 – FTDSS","text":"This file depends on sourcefile~~solve.f90~~EfferentGraph sourcefile~solve.f90 Solve.f90 sourcefile~types.f90 Types.f90 sourcefile~solve.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~precon_jacobi.f90 Precon_jacobi.f90 sourcefile~solve.f90->sourcefile~precon_jacobi.f90 sourcefile~blas.f90 BLAS.f90 sourcefile~solve.f90->sourcefile~blas.f90 sourcefile~product.f90 Product.f90 sourcefile~solve.f90->sourcefile~product.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~solve.f90->sourcefile~allocate.f90 sourcefile~error.f90 error.f90 sourcefile~solve.f90->sourcefile~error.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~precon_jacobi.f90->sourcefile~types.f90 sourcefile~blas.f90->sourcefile~types.f90 sourcefile~product.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~solve.f90~~AfferentGraph sourcefile~solve.f90 Solve.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Solver_Solve Source Code Solve.f90 Source Code module Solver_Solve use omp_lib use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: Allocate use :: Allocate_Structure use :: Solver_Precon_jacobi use :: Calculate_Product , only : SpMV => Matrix_Vector_Product_CRS use :: error use :: Calculate_BLAS , only : norm => norm_2 , dot => ddots implicit none private type ( CRS ) :: CRS_A real ( real64 ), allocatable , target :: work (:,:) ! Iterative Linear Solver type :: ILS private type ( CRS ) :: CRS_A real ( real64 ), dimension (:), pointer :: M , p , phat , s , shat , r , r0 , t , v , x , b contains procedure :: BiCGStab => Solver_BiCGStab procedure :: Chkerr => Solver_Check_Error final :: ILS_Destructor end type ILS interface ILS module procedure Solve_Initialize_BiCGStab end interface ! Direct Linear Solver type :: DLS private integer ( int32 ) :: N contains procedure :: LU => Solver_LU end type interface DLS module procedure Solve_Initialize_LU end interface public :: ILS public :: DLS contains type ( ILS ) function Solve_Initialize_BiCGStab ( Solver , MCRS ) implicit none type ( SolverInfo ), intent ( in ) :: Solver type ( CRS ), intent ( in ) :: MCRS call Allocate_Matrix ( work , Solver % N % node , 11 ) Solve_Initialize_BiCGStab % M => work (:, 1 ) Solve_Initialize_BiCGStab % p => work (:, 2 ) Solve_Initialize_BiCGStab % phat => work (:, 3 ) Solve_Initialize_BiCGStab % s => work (:, 4 ) Solve_Initialize_BiCGStab % shat => work (:, 5 ) Solve_Initialize_BiCGStab % r => work (:, 6 ) Solve_Initialize_BiCGStab % r0 => work (:, 7 ) Solve_Initialize_BiCGStab % t => work (:, 8 ) Solve_Initialize_BiCGStab % v => work (:, 9 ) Solve_Initialize_BiCGStab % x => work (:, 10 ) Solve_Initialize_BiCGStab % b => work (:, 11 ) call Duplicate_CRS ( MCRS , Solve_Initialize_BiCGStab % CRS_A ) end function Solve_Initialize_BiCGStab subroutine Solver_BiCGStab ( self , Solver , BiCG_A , BiCG_b , BiCG_x , status ) implicit none class ( ILS ) :: self type ( SolverInfo ), intent ( inout ) :: Solver type ( CRS ), intent ( in ) :: BiCG_A real ( real64 ), intent ( in ) :: BiCG_b (:) real ( real64 ), intent ( inout ) :: BiCG_x (:) integer ( int32 ), intent ( inout ) :: status real ( real64 ) :: rho , rho_old , alpha , beta , omega real ( real64 ) :: tol , resid real ( real64 ) :: ddot , dnrm2 integer ( int32 ) :: maxiter , iter , N , iN ! 1:Initialize N = Solver % N % node tol = 1.0d-12 maxiter = N * 100 maxiter = 50000 self % CRS_A % Val (:) = BiCG_A % Val (:) self % b (:) = BiCG_b (:) rho = 1.0d0 rho_old = 1.0d0 alpha = 1.0d0 beta = 1.0d0 omega = 1.0d0 do iN = 1 , N self % p ( iN ) = 0.0d0 self % s ( iN ) = 0.0d0 self % phat ( iN ) = 0.0d0 self % shat ( iN ) = 0.0d0 end do ! 2: Set an initial value x0 self % x (:) = 0.0d0 ! 3: r0 = b-Ax0 call SpMV ( self % CRS_A , self % x , self % r ) do iN = 1 , N self % r ( iN ) = self % b ( iN ) - self % r ( iN ) end do ! 4: Create preconditioned matrix call Create_Precond_Jacobi ( N , self % CRS_A , self % M ) ! 5: &#94;r0 = r0, (r*0, r0)!=0 self % r0 (:) = self % r (:) do iter = 1 , maxiter , 1 ! 7: (&#94;r0, rk) rho = dot ( N , self % r , self % r0 ) ! rho = ddot(N, self%r, 1, self%r0, 1) ! 8: rho check if ( rho == 0.0d0 ) then status = 0 BiCG_x (:) = self % x (:) return end if if ( iter == 1 ) then ! 10: p0 = r0 self % p (:) = self % r (:) else ! 12: beta = (rho / rho_old) * (alpha_k / omega_k) beta = ( rho / rho_old ) * ( alpha / omega ) ! 13: p_k = r_k + beta_k(p_(k-1) - omega_k * Av) do iN = 1 , N self % p ( iN ) = self % r ( iN ) + beta * ( self % p ( iN ) - omega * self % v ( iN )) end do end if ! 15: phat = M&#94;-1 * p call Apply_Precond_Jacobi ( N , self % M , self % p , self % phat ) ! 16: v = A * phat call SpMV ( self % CRS_A , self % phat , self % v ) ! 17: alpha_k = rho / (&#94;r0, v) alpha = rho / dot ( N , self % r0 , self % v ) ! alpha = rho / ddot(N, self%r0, 1, self%v, 1) ! 18: s = r_k - alpha_k * v do iN = 1 , N self % s ( iN ) = self % r ( iN ) - alpha * self % v ( iN ) end do ! 19: shat = M&#94;-1 * s call Apply_Precond_Jacobi ( N , self % M , self % s , self % shat ) ! 20: t = A * shat call SpMV ( self % CRS_A , self % shat , self % t ) ! 21: omega_k = (t,s)/(t,t) omega = dot ( N , self % t , self % s ) / dot ( N , self % t , self % t ) ! omega = ddot(N, self%t, 1, self%s, 1) / ddot(N, self%t, 1, self%t, 1) ! 22: omega breakdown check if ( omega == 0.0d0 ) then status = - 1 return end if do iN = 1 , N ! 23: x(i) = x(i-1) + alpha * M&#94;-1 p(i-1) + omega * M&#94;-1 s(i) self % x ( iN ) = self % x ( iN ) + alpha * self % phat ( iN ) + omega * self % shat ( iN ) end do do iN = 1 , N ! 24: r(i) = s(i-1) - omega * AM&#94;-1 s(i-1) self % r ( iN ) = self % s ( iN ) - omega * self % t ( iN ) end do ! 25: ||r_k+1||_2 ! resid = dnrm2(N, self%r(:), 1) resid = norm ( N , self % r (:)) if ( resid < tol ) then status = 0 BiCG_x (:) = self % x (:) return end if rho_old = rho end do status = - 2 end subroutine Solver_BiCGStab subroutine Solver_Check_Error ( self , ierr , time ) implicit none class ( ILS ) :: self integer ( int32 ), intent ( in ) :: ierr real ( real64 ), intent ( in ) :: time if ( ierr /= 0 ) then if ( ierr == - 1 ) then write ( * , '(a,es13.4,a)' ), \"BiCGStab:\" , time , \" Day: Temperature solver occures BREAKDOWN.\" else if ( ierr == - 2 ) then write ( * , '(a,es13.4,a)' ), \"BiCGStab:\" , time , \" Day: Temperature solver occures MAXITER.\" end if stop end if end subroutine Solver_Check_Error subroutine ILS_Destructor ( self ) implicit none type ( ILS ) :: self ! ポインタコンポーネントをnullify nullify ( self % M ) nullify ( self % p ) nullify ( self % phat ) nullify ( self % s ) nullify ( self % shat ) nullify ( self % r ) nullify ( self % r0 ) nullify ( self % t ) nullify ( self % v ) nullify ( self % x ) nullify ( self % b ) ! CRS_Aのリソースを解放 if ( allocated ( self % CRS_A % Val )) deallocate ( self % CRS_A % Val ) if ( allocated ( self % CRS_A % Ind )) deallocate ( self % CRS_A % Ind ) if ( allocated ( self % CRS_A % Ptr )) deallocate ( self % CRS_A % Ptr ) end subroutine ILS_Destructor type ( DLS ) function Solve_Initialize_LU ( Solver ) implicit none type ( SolverInfo ) :: Solver Solve_Initialize_LU % N = Solver % N % node end function Solve_Initialize_LU subroutine Solver_LU ( self , LU_A , LU_b , LU_x ) implicit none class ( DLS ) :: self real ( real64 ), intent ( inout ) :: LU_A (:,:), LU_b (:), LU_x (:) ! integer(int32), intent(in)    :: n integer ( int32 ) :: ipiv ( self % N ), info !* LU decomposition call Dgetrf ( self % N , self % N , LU_A , self % N , ipiv , info ) if ( info /= 0 ) call error_message ( 942 ) !* solve linear equation call Dgetrs ( 'N' , self % N , 1 , LU_A , self % N , ipiv , LU_b , self % N , info ) if ( info /= 0 ) call error_message ( 943 ) LU_x (:) = LU_b (:) end subroutine Solver_LU end module Solver_Solve","tags":"","loc":"sourcefile/solve.f90.html"},{"title":"error.f90 – FTDSS","text":"Files dependent on this one sourcefile~~error.f90~~AfferentGraph sourcefile~error.f90 error.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~shape.f90 Shape.f90 sourcefile~shape.f90->sourcefile~error.f90 sourcefile~points.f90 Points.f90 sourcefile~shape.f90->sourcefile~points.f90 sourcefile~count.f90 Count.f90 sourcefile~count.f90->sourcefile~error.f90 sourcefile~output.f90 Output.f90 sourcefile~output.f90->sourcefile~error.f90 sourcefile~setprojectpath.f90 SetProjectPath.f90 sourcefile~output.f90->sourcefile~setprojectpath.f90 sourcefile~output.f90->sourcefile~allocate.f90 sourcefile~setprojectpath.f90->sourcefile~error.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~assemble.f90->sourcefile~error.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~assemble.f90->sourcefile~allocate.f90 sourcefile~area.f90 Area.f90 sourcefile~area.f90->sourcefile~error.f90 sourcefile~area.f90->sourcefile~points.f90 sourcefile~points.f90->sourcefile~error.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~error.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~solve.f90->sourcefile~allocate.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~error.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate_structure.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~allocate_structure.f90 sourcefile~heat.f90->sourcefile~count.f90 sourcefile~heat.f90->sourcefile~allocate.f90 sourcefile~convertcrs.f90 ConvertCRS.f90 sourcefile~convertcrs.f90->sourcefile~allocate.f90 sourcefile~observation.f90 Observation.f90 sourcefile~observation.f90->sourcefile~allocate.f90 sourcefile~observation.f90->sourcefile~points.f90 sourcefile~initialize.f90 Initialize.f90 sourcefile~initialize.f90->sourcefile~allocate.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules error Source Code error.f90 Source Code module error use , intrinsic :: iso_fortran_env , only : int32 , real64 use , intrinsic :: ieee_arithmetic , only : ieee_is_nan implicit none private public :: error_message public :: has_nan public :: value_in_range interface has_nan procedure :: has_nan_real64_scalar procedure :: has_nan_real64_rank1 procedure :: has_nan_real64_rank2 end interface interface value_in_range procedure :: value_in_range_int32 procedure :: value_in_range_real64 end interface contains !* Check whether the array has NaN or not logical function has_nan_real64_scalar ( scalar ) implicit none real ( real64 ), intent ( in ) :: scalar has_nan_real64_scalar = ieee_is_nan ( scalar ) end function has_nan_real64_scalar logical function has_nan_real64_rank1 ( array ) implicit none real ( real64 ), intent ( in ) :: array (:) has_nan_real64_rank1 = any ( ieee_is_nan ( array )) end function has_nan_real64_rank1 logical function has_nan_real64_rank2 ( array ) implicit none real ( real64 ), intent ( in ) :: array (:, :) has_nan_real64_rank2 = any ( ieee_is_nan ( array )) end function has_nan_real64_rank2 subroutine error_message ( err_number , myrank , opt , opt_file_name , copt1 , copt2 ) implicit none integer ( int32 ), intent ( in ) :: err_number real ( real64 ), optional , intent ( in ) :: opt integer ( int32 ), optional , intent ( in ) :: myrank character ( 256 ) :: msg character ( * ), optional , intent ( in ) :: opt_file_name , copt1 , copt2 integer ( int32 ) :: ierr if ( err_number == 901 ) then write ( msg , '(3a)' ) \"Error: Does not exit file '\" , trim ( adjustl ( opt_file_name )), \"'.\" else if ( err_number == 902 ) then write ( msg , '(3a)' ) \"Error: Can not open file '\" , trim ( adjustl ( opt_file_name )), \"'.\" else if ( err_number == 903 ) then write ( msg , '(3a)' ) \"Error: Selected \" , trim ( adjustl ( copt1 )), \" number is invalid.\" else if ( err_number == 904 ) then msg = \"Error: Opening file 'coordinate.in'\" else if ( err_number == 905 ) then msg = \"Error: Opening file 'top.in'\" else if ( err_number == 906 ) then msg = \"Error: Opening file 'coordinate.in'\" else if ( err_number == 911 ) then msg = \"Error: The number of elements must be positive.\" else if ( err_number == 912 ) then msg = \"Error: The number of nodal must be positive.\" else if ( err_number == 913 ) then msg = \"Error: The number of shape must be positive.\" else if ( err_number == 914 ) then msg = \"Error: The number of dimention must be positive.\" else if ( err_number == 915 ) then msg = \"Error: Dirichlet boundary conditions for water transport must be positive.\" else if ( err_number == 916 ) then msg = \"Error: Dirichlet boundary conditions for heat transport must be positive.\" else if ( err_number == 917 ) then msg = \"Error: The value of porosity must be positive.\" else if ( err_number == 918 ) then msg = \"Error: The value of density must be positive.\" else if ( err_number == 919 ) then msg = \"Error: The value of hydrulic conductivity must be positive.\" else if ( err_number == 920 ) then msg = \"Error: The value of thermal conductivity must be positive.\" else if ( err_number == 921 ) then msg = \"Error: The value of specific heat must be positive.\" else if ( err_number == 922 ) then msg = \"Error: The value of latent heat must be positive.\" else if ( err_number == 923 ) then msg = \"Error: The number of concering time information must be positive.\" else if ( err_number == 924 ) then msg = \"Error: The initial and coolant temperature are same.\" else if ( err_number == 928 ) then msg = \"Error: Two or more points are the same.\" else if ( err_number == 929 ) then msg = \"Error: The number of array elements must be positive.\" else if ( err_number == 930 ) then msg = \"Error: The number of matrix elements must be positive.\" else if ( err_number == 931 ) then msg = \"Error: opening output file\" else if ( err_number == 932 ) then msg = \"Error: Invalid element index\" else if ( err_number == 933 ) then msg = \"Error: Solver type is not selected.\" else if ( err_number == 934 ) then msg = \"Error: Freezing calculation is not selected.\" else if ( err_number == 941 ) then msg = \"Error: The solution to the simultaneous linear equations could not be found.\" else if ( err_number == 942 ) then msg = \"Error: LU decomposition could not be successed.\" else if ( err_number == 943 ) then msg = \"Error: The inverse matrix could not be found.\" else if ( err_number == 944 ) then msg = \"Error: The target result is too high.\" else if ( err_number == 945 ) then msg = \"Error: The target result is too low.\" else if ( err_number == 946 ) then msg = \"Error: The solution has been diverged.\" else if ( err_number == 951 ) then write ( msg , '(a)' ) \"Error: The number of vector elements must be positive.\" else if ( err_number == 952 ) then write ( msg , '(a)' ) \"Error: The number of matrix elements must be positive.\" else if ( err_number == 953 ) then write ( msg , '(a)' ) \"Error: Vector has already allocated.\" else if ( err_number == 954 ) then write ( msg , '(a)' ) \"Error: Matrix has already allocated.\" else if ( err_number == 955 ) then write ( msg , '(a)' ) \"Error: Pointer has already allocated.\" else msg = \"Error: Unknown error\" end if #ifdef _MPI if ( myrank == 0 ) then call MPI_Finalize ( ierr ) #endif write ( * , '(a)' ) msg stop #ifdef _MPI end if #endif end subroutine error_message function value_in_range_int32 ( value , min , max ) result ( in_range ) implicit none integer ( int32 ), intent ( in ) :: value , min , max logical :: in_range in_range = . true . if ( value < min . or . value > max ) then in_range = . false . end if end function value_in_range_int32 function value_in_range_real64 ( value , min , max ) result ( in_range ) implicit none real ( real64 ), intent ( in ) :: value , min , max logical :: in_range in_range = . true . if ( value < min . or . value > max ) then in_range = . false . end if end function value_in_range_real64 end module error","tags":"","loc":"sourcefile/error.f90.html"},{"title":"Precon_jacobi.f90 – FTDSS","text":"This file depends on sourcefile~~precon_jacobi.f90~~EfferentGraph sourcefile~precon_jacobi.f90 Precon_jacobi.f90 sourcefile~types.f90 Types.f90 sourcefile~precon_jacobi.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~precon_jacobi.f90~~AfferentGraph sourcefile~precon_jacobi.f90 Precon_jacobi.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~precon_jacobi.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Solver_Precon_jacobi Source Code Precon_jacobi.f90 Source Code module Solver_Precon_jacobi use omp_lib use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none public :: Create_Precond_Jacobi public :: Apply_Precond_Jacobi contains subroutine Create_Precond_Jacobi ( N , A , M ) implicit none integer ( int32 ), intent ( in ) :: N type ( CRS ), intent ( in ) :: A real ( real64 ), intent ( inout ) :: M (:) integer ( int32 ) :: i , j M (:) = 0.0d0 !$omp parallel do private(i, j) do i = 1 , N do j = A % Ptr ( i - 1 ), A % Ptr ( i ) - 1 if (( i - 1 ) == A % Ind ( j )) then M ( i ) = 1.0d0 / A % Val ( j ) end if end do end do !$omp end parallel do end subroutine Create_Precond_Jacobi subroutine Apply_Precond_Jacobi ( N , M , r , z ) implicit none integer ( int32 ), intent ( in ) :: N real ( real64 ), intent ( in ) :: M (:) real ( real64 ), intent ( in ) :: r (:) real ( real64 ), intent ( inout ) :: z (:) integer ( int32 ) :: i ! $omp parallel do private(i) do i = 1 , N z ( i ) = M ( i ) * r ( i ) end do ! $omp end parallel do end subroutine Apply_Precond_Jacobi end module Solver_Precon_jacobi","tags":"","loc":"sourcefile/precon_jacobi.f90.html"},{"title":"InitCopy.f90 – FTDSS","text":"This file depends on sourcefile~~initcopy.f90~~EfferentGraph sourcefile~initcopy.f90 InitCopy.f90 sourcefile~types.f90 Types.f90 sourcefile~initcopy.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Solver_InitCopy Source Code InitCopy.f90 Source Code module Solver_InitCopy use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none private public :: Init_Copy_Temperature public :: Init_Copy_Pressure contains subroutine Init_Copy_Temperature ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver Solver % T % old (:) = Solver % T % pre (:) Solver % Si % old (:) = Solver % Si % pre (:) Solver % mWater % old (:) = Solver % mWater % pre (:) Solver % mIce % old (:) = Solver % mIce % pre (:) Solver % Heat % Variables % Ca % old (:) = Solver % Heat % Variables % Ca % pre (:) end subroutine Init_Copy_Temperature subroutine Init_Copy_Pressure ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver Solver % P % old (:) = Solver % P % pre (:) Solver % Water % Variables % Klh % old (:) = Solver % Water % Variables % Klh % pre (:) end subroutine Init_Copy_Pressure end module Solver_InitCopy","tags":"","loc":"sourcefile/initcopy.f90.html"},{"title":"Initialize.f90 – FTDSS","text":"This file depends on sourcefile~~initialize.f90~~EfferentGraph sourcefile~initialize.f90 Initialize.f90 sourcefile~types.f90 Types.f90 sourcefile~initialize.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~initialize.f90->sourcefile~allocate.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~initialize.f90->sourcefile~latentheat.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Solver_Initialize Source Code Initialize.f90 Source Code module Solver_Initialize use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: Allocate use :: Calculate_LatentHeat , only : Find_Ca_max implicit none private public :: Initialize_Solver contains subroutine Initialize_Solver ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: i call Allocate_Pointer ( Solver % Time % tst ) call Allocate_Pointer ( Solver % Time % dt ) call Allocate_Pointer ( Solver % Time % odt ) ! Time settings converting to seconds Solver % Time % ts = 0.0d0 Solver % Time % tst = 0.0d0 Solver % Time % te = Solver % Time % cTime * Convert_TimeUnit ( Solver % Time , 1 ) Solver % Time % dt = Solver % Time % cdt * Convert_TimeUnit ( Solver % Time , 2 ) Solver % Time % odt = Solver % Time % dt Solver % Time % max_dt = 1.0d-8 Solver % Time % min_dt = 30 0.0d0 Solver % Time % tconv = 1.0d0 / Convert_TimeUnit ( Solver % Time , 1 ) call Allocate_Pointer ( Solver % Iter % iter ) call Allocate_Pointer ( Solver % Iter % titer ) call Allocate_Pointer ( Solver % Iter % iNL ) ! Iteration settings Solver % Iter % iter = 1 Solver % Iter % itermax = nint ( Solver % Time % te / Solver % Time % cinterval ) Solver % Iter % titer = 1 Solver % Iter % iNL = 1 Solver % Iter % iNLmax = 50 Solver % Iter % iNI = 1 Solver % Iter % digits_itermax = int ( log10 ( dble ( Solver % Iter % itermax ))) + 1 ! Output format settings write ( Solver % fmt_Stdout , '(a,i0,a,i0,a)' ), & '(a,i' , Solver % Iter % digits_itermax , ',a,i' , Solver % Iter % digits_itermax , ',a,f9.4,a,f11.4,a)' write ( Solver % fmt_Fileout , '(a,i0,a,i0,a)' ), & '(2a,i' , Solver % Iter % digits_itermax , '.' , Solver % Iter % digits_itermax , ',a)' Solver % Heat % Latent % Cp_unf = Solver % Heat % Constants % HeatCapacity % soil * ( 1.0d0 - Solver % Heat % Constants % Porosity ) & + Solver % Heat % Constants % HeatCapacity % water * Solver % Heat % Constants % Porosity ! Find the maximum value of Ca call Find_Ca_max ( Solver % Heat ) if ( Solver % BC % numEdges > 0 ) then do i = 1 , Solver % BC % numEdges ! print*,(Solver%N%vCood%x(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%x(Solver%BC%Heat%Edges%x(i))),(Solver%N%vCood%y(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%y(Solver%BC%Heat%Edges%x(i))) Solver % BC % Heat % EdgesDistance ( i ) = sqrt (( Solver % N % vCood % x ( Solver % BC % Heat % Edges % y ( i )) - Solver % N % vCood % x ( Solver % BC % Heat % Edges % x ( i ))) ** 2.0d0 + ( Solver % N % vCood % y ( Solver % BC % Heat % Edges % y ( i )) - Solver % N % vCood % y ( Solver % BC % Heat % Edges % x ( i ))) ** 2.0d0 ) end do end if end subroutine Initialize_Solver function Convert_TimeUnit ( Time , num ) result ( conv_time ) implicit none type ( TimeInfo ), intent ( in ) :: Time integer ( int32 ), intent ( in ) :: num real ( real64 ) :: conv_time if ( Time % tUnit ( num : num ) == \"1\" ) then conv_time = 1.0d0 else if ( Time % tUnit ( num : num ) == \"2\" ) then conv_time = 6 0.d0 else if ( Time % tUnit ( num : num ) == \"3\" ) then conv_time = 6 0.d0 * 6 0.d0 else if ( Time % tUnit ( num : num ) == \"4\" ) then conv_time = 6 0.d0 * 6 0.d0 * 2 4.0d0 else if ( Time % tUnit ( num : num ) == \"5\" ) then conv_time = 6 0.d0 * 6 0.d0 * 2 4.0d0 * 3 0.d0 else if ( Time % tUnit ( num : num ) == \"6\" ) then conv_time = 6 0.d0 * 6 0.d0 * 2 4.0d0 * 36 5.0d0 end if end function Convert_TimeUnit end module Solver_Initialize","tags":"","loc":"sourcefile/initialize.f90.html"},{"title":"BinaryFinding.f90 – FTDSS","text":"This file depends on sourcefile~~binaryfinding.f90~~EfferentGraph sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~types.f90 Types.f90 sourcefile~binaryfinding.f90->sourcefile~types.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~binaryfinding.f90->sourcefile~latentheat.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~binaryfinding.f90~~AfferentGraph sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~update.f90 Update.f90 sourcefile~update.f90->sourcefile~binaryfinding.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules RootFinding_BinaryFinding Source Code BinaryFinding.f90 Source Code module RootFinding_BinaryFinding use , intrinsic :: iso_fortran_env , only : real64 , int32 use , intrinsic :: IEEE_ARITHMETIC , only : ieee_is_nan use :: Types use :: Calculate_LatentHeat , only : Calc_LatentHeatTerm implicit none private real ( real64 ), parameter :: eps = 1.0d-10 integer ( int32 ), parameter :: max_iter = 100 public :: Binary_finding contains subroutine Binary_finding ( Solver , ind ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: ind real ( real64 ) :: Tnew real ( real64 ) :: x0 , x1 , x2 , f0 , f1 , err integer ( int32 ) :: i x0 = 0.0d0 x1 = Solver % T % new ( ind ) Tnew = Solver % T % new ( ind ) do i = 1 , max_iter f0 = Calc_LatentHeatTerm ( x0 , Tnew , Solver % Heat % Latent ) f1 = Calc_LatentHeatTerm ( x1 , Tnew , Solver % Heat % Latent ) if ( f0 * f1 > 0.0d0 ) then write ( * , \"(a)\" ), \"Binary_finding_Power: f0 * f1 > 0\" stop end if x2 = ( x0 + x1 ) / 2.0d0 if ( f0 * Calc_LatentHeatTerm ( x2 , Tnew , Solver % Heat % Latent ) < 0.0d0 ) then x1 = x2 else x0 = x2 end if if ( abs ( x1 - x0 ) < eps ) exit end do if ( i >= max_iter ) then if ( Solver % Flags % isGCC ) then write ( * , \"(a)\" ), \"Binary_finding_GCC: iteration limit exceeded\" else if ( Solver % Flags % isPower ) then write ( * , \"(a)\" ), \"Binary_finding_Power: iteration limit exceeded\" end if stop end if Solver % T % new ( ind ) = x2 end subroutine Binary_finding end module RootFinding_BinaryFinding","tags":"","loc":"sourcefile/binaryfinding.f90.html"},{"title":"SecantMethod.f90 – FTDSS","text":"This file depends on sourcefile~~secantmethod.f90~~EfferentGraph sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~types.f90 Types.f90 sourcefile~secantmethod.f90->sourcefile~types.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~secantmethod.f90->sourcefile~latentheat.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~secantmethod.f90~~AfferentGraph sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~update.f90 Update.f90 sourcefile~update.f90->sourcefile~secantmethod.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules RootFinding_SecantMethod Source Code SecantMethod.f90 Source Code module RootFinding_SecantMethod use , intrinsic :: iso_fortran_env , only : real64 , int32 use , intrinsic :: IEEE_ARITHMETIC , only : ieee_is_nan use :: Types use :: Calculate_LatentHeat , only : Calc_LatentHeatTerm implicit none private real ( real64 ), parameter :: eps = 1.0d-10 integer ( int32 ), parameter :: max_iter = 100 public :: Secant_method contains subroutine Secant_method ( Solver , ind ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: ind real ( real64 ) :: Tnew real ( real64 ) :: x0 , x1 , x2 , f0 , f1 , err integer ( int32 ) :: i x0 = 0.0d0 x1 = Solver % T % new ( ind ) Tnew = Solver % T % new ( ind ) do i = 1 , max_iter f0 = Calc_LatentHeatTerm ( x0 , Tnew , Solver % Heat % Latent ) f1 = Calc_LatentHeatTerm ( x1 , Tnew , Solver % Heat % Latent ) if ( abs ( f1 - f0 ) < epsilon ( 1.0d0 )) then stop else err = f1 * ( x1 - x0 ) / ( f1 - f0 ) x2 = x1 - err if ( abs ( err ) < eps ) exit x0 = x1 x1 = x2 end if end do if ( i >= max_iter ) then if ( Solver % Flags % isGCC ) then write ( * , \"(a)\" ), \"Secant_method_GCC: iteration limit exceeded\" else if ( Solver % Flags % isPower ) then write ( * , \"(a)\" ), \"Secant_method_Power: iteration limit exceeded\" end if stop end if if ( ieee_is_nan ( x2 )) x2 = 0.0d0 Solver % T % new ( ind ) = x2 end subroutine Secant_method end module RootFinding_SecantMethod","tags":"","loc":"sourcefile/secantmethod.f90.html"},{"title":"Allocate_Structure.f90 – FTDSS","text":"This file depends on sourcefile~~allocate_structure.f90~~EfferentGraph sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~error.f90 error.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~types.f90 Types.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~allocate.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~allocate_structure.f90~~AfferentGraph sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate_structure.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~solve.f90 Solve.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~allocate_structure.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Allocate_Structure Source Code Allocate_Structure.f90 Source Code module Allocate_Structure use :: error use :: Types use :: allocate use , intrinsic :: iso_fortran_env , only : int32 , real64 implicit none private public :: Allocate_DF public :: Allocate_DP2d public :: Allocate_BCinfo public :: Allocate_Solver public :: Allocate_Structure_Thermal_Type public :: Allocate_Structure_Ice_Type public :: Allocate_Structure_WRF_Type public :: Allocate_Structure_Hydraulic_Type contains subroutine Allocate_DF ( ar_DF , n ) implicit none type ( DF ), intent ( inout ) :: ar_DF integer ( int32 ), intent ( in ) :: n call Allocate_Vector ( ar_DF % old , n ) call Allocate_Vector ( ar_DF % pre , n ) call Allocate_Vector ( ar_DF % new , n ) call Allocate_Vector ( ar_DF % dif , n ) call Allocate_Vector ( ar_DF % div , n ) call Allocate_Vector ( ar_DF % tmp , n ) end subroutine Allocate_DF subroutine Allocate_DP2d ( ar_DP2d , n ) implicit none type ( DP2d ), intent ( inout ) :: ar_DP2d integer ( int32 ), intent ( in ) :: n call Allocate_Vector ( ar_DP2d % x , n ) call Allocate_Vector ( ar_DP2d % y , n ) end subroutine Allocate_DP2d subroutine Allocate_INT2d ( ar_INT2d , n ) implicit none type ( INT2d ), intent ( inout ) :: ar_INT2d integer ( int32 ), intent ( in ) :: n call Allocate_Vector ( ar_INT2d % x , n ) call Allocate_Vector ( ar_INT2d % y , n ) end subroutine Allocate_INT2d subroutine Allocate_BCinfo ( BCinfo , nNode , nType , nEdge ) implicit none type ( BoudaryConditionInfo ), intent ( inout ) :: BCinfo integer ( int32 ), intent ( in ) :: nNode , nType integer ( int32 ), intent ( in ), optional :: nEdge call Allocate_Vector ( BCinfo % Node , nNode ) call Allocate_Vector ( BCinfo % TypeKey , nNode ) call Allocate_Vector ( BCinfo % type , nType ) call Allocate_Vector ( BCinfo % value , nType ) if ( present ( nEdge )) then ! print*, nEdge call Allocate_INT2d ( BCinfo % Edges , nEdge ) call Allocate_Vector ( BCinfo % EdgesDirection , nEdge ) call Allocate_Vector ( BCinfo % EdgesDistance , nEdge ) end if end subroutine Allocate_BCinfo subroutine Allocate_Solver ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver !* Allocate Geometry2d call Allocate_Matrix ( Solver % N % pElement , Solver % N % shape , Solver % N % element ) call Allocate_Vector ( Solver % N % vCood % x , Solver % N % node ) call Allocate_Vector ( Solver % N % vCood % y , Solver % N % node ) call Allocate_Vector ( Solver % N % eArea , Solver % N % element ) call Allocate_Matrix ( Solver % N % Basis % a , Solver % N % ShCoe , Solver % N % element ) call Allocate_Matrix ( Solver % N % Basis % b , Solver % N % ShCoe , Solver % N % element ) call Allocate_Matrix ( Solver % N % Basis % c , Solver % N % ShCoe , Solver % N % element ) if ( Solver % N % ShCoe == 4 ) call Allocate_Matrix ( Solver % N % Basis % d , Solver % N % ShCoe , Solver % N % element ) call Allocate_Vector ( Solver % mWater % old , Solver % N % node ) call Allocate_Vector ( Solver % mWater % pre , Solver % N % node ) call Allocate_Vector ( Solver % mIce % old , Solver % N % node ) call Allocate_Vector ( Solver % mIce % pre , Solver % N % node ) call Allocate_Vector ( Solver % mIce % dif , Solver % N % node ) call Allocate_DF ( Solver % Si , Solver % N % node ) if ( Solver % isHeat ) then call Allocate_DF ( Solver % Heat % Variables % Cs , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % Cp , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % lambda , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % rho , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % Ca , Solver % N % node ) call Allocate_DF ( Solver % T , Solver % N % node ) call Allocate_Vector ( Solver % Heat % Rhs , Solver % N % node ) call Allocate_Vector ( Solver % Heat % Variables % Phase , Solver % N % node ) call Allocate_Matrix ( Solver % Heat % RA , Solver % N % node , Solver % N % node ) call Allocate_DP2d ( Solver % Heat % Variables % Tgrad , Solver % N % node ) call Allocate_DP2d ( Solver % Heat % Variables % TFlux , Solver % N % node ) end if if ( Solver % isWater ) then call Allocate_DF ( Solver % Water % Variables % Klh , Solver % N % node ) call Allocate_DP2d ( Solver % Water % Variables % wFlux , Solver % N % node ) call Allocate_DP2d ( Solver % Water % Variables % hGrad , Solver % N % node ) call Allocate_DF ( Solver % P , Solver % N % node ) call Allocate_Vector ( Solver % Water % Rhs , Solver % N % node ) call Allocate_Matrix ( Solver % Water % RA , Solver % N % node , Solver % N % node ) end if end subroutine Allocate_Solver subroutine Allocate_Structure_Thermal_Type ( Structure_Thermal , Flags ) ! Allocate thermal structure type implicit none type ( Type_Thermal ), intent ( inout ) :: Structure_Thermal ! Thermal structure type ( Type_Region_Flags ), intent ( in ) :: Flags ! Region flags if ( allocated ( Structure_Thermal % Density )) deallocate ( Structure_Thermal % Density ) if ( allocated ( Structure_Thermal % SpecificHeat )) deallocate ( Structure_Thermal % SpecificHeat ) if ( allocated ( Structure_Thermal % ThermalConductivity )) deallocate ( Structure_Thermal % ThermalConductivity ) if ( Flags % is1Phase ) then allocate ( Type_Density_1Phase :: Structure_Thermal % Density ) allocate ( Type_SpecificHeat_1Phase :: Structure_Thermal % SpecificHeat ) allocate ( Type_ThermalConductivity_1Phase :: Structure_Thermal % ThermalConductivity ) else if ( Flags % is2Phase ) then allocate ( Type_Density_2Phase :: Structure_Thermal % Density ) allocate ( Type_SpecificHeat_2Phase :: Structure_Thermal % SpecificHeat ) allocate ( Type_ThermalConductivity_2Phase :: Structure_Thermal % ThermalConductivity ) else if ( Flags % is3Phase ) then allocate ( Type_Density_3Phase :: Structure_Thermal % Density ) allocate ( Type_SpecificHeat_3Phase :: Structure_Thermal % SpecificHeat ) if ( Flags % isDispersity ) then allocate ( Type_ThermalConductivity_3Phase_Dispersity_2D :: Structure_Thermal % ThermalConductivity ) ! allocate (Type_ThermalConductivity_3Phase_Dispersity_3D :: Structure_Thermal%ThermalConductivity) else allocate ( Type_ThermalConductivity_3Phase :: Structure_Thermal % ThermalConductivity ) end if end if end subroutine Allocate_Structure_Thermal_Type subroutine Allocate_Structure_Ice_Type ( Structure_Thermal , QiceModelType ) ! Allocate ice model type implicit none type ( Type_Thermal ), intent ( inout ) :: Structure_Thermal ! Thermal structure integer ( int32 ), intent ( in ) :: QiceModelType ! Ice model type if ( allocated ( Structure_Thermal % Ice )) deallocate ( Structure_Thermal % Ice ) if ( QiceModelType == 1 ) then allocate ( Type_Ice_TRM :: Structure_Thermal % Ice ) else if ( QiceModelType == 2 ) then allocate ( Type_Ice_GCC :: Structure_Thermal % Ice ) else if ( QiceModelType == 3 ) then allocate ( Type_Ice_EXP :: Structure_Thermal % Ice ) end if end subroutine Allocate_Structure_Ice_Type subroutine Allocate_Structure_WRF_Type ( Structure_Thermal , WRFModelType ) ! Allocate WRF model type implicit none type ( Type_Thermal ), intent ( inout ) :: Structure_Thermal ! Thermal structure integer ( int32 ), intent ( in ) :: WRFModelType ! WRF model type if (. not . allocated ( Structure_Thermal % Ice )) then print * , \"Error: Ice structure is not allocated.\" return end if select type ( Ice => Structure_Thermal % Ice ) type is ( Type_Ice_GCC ) select case ( WRFModelType ) case ( 1 ) allocate ( Type_WRF_BC :: Ice % WRF ) case ( 2 ) allocate ( Type_WRF_VG :: Ice % WRF ) case ( 3 ) allocate ( Type_WRF_KO :: Ice % WRF ) case ( 4 ) allocate ( Type_WRF_MVG :: Ice % WRF ) case ( 5 ) allocate ( Type_WRF_Durner :: Ice % WRF ) case ( 6 ) allocate ( Type_WRF_DVGCH :: Ice % WRF ) case default print * , \"Error: WRFModelType is not defined.\" end select end select end subroutine Allocate_Structure_WRF_Type subroutine Allocate_Structure_Hydraulic_Type ( Structure_Hydraulic ) ! Allocate hydraulic structure type implicit none type ( Type_Hydraulic ), intent ( inout ) :: Structure_Hydraulic ! Hydraulic structure if ( Structure_Hydraulic % useHCF > 0 ) then call Allocate_Structure_HCF_Type ( Structure_Hydraulic ) end if if ( Structure_Hydraulic % useImpedance ) then allocate ( Type_Impedance :: Structure_Hydraulic % Impedance ) end if select case ( Structure_Hydraulic % useKTDynamics ) case ( 1 : 2 ) allocate ( Type_KTDynamics :: Structure_Hydraulic % KTDynamics ) end select end subroutine Allocate_Structure_Hydraulic_Type subroutine Allocate_Structure_HCF_Type ( Structure_Hydraulic ) ! Allocate WRF model type implicit none type ( Type_Hydraulic ), intent ( inout ) :: Structure_Hydraulic ! Hydraulic structure select case ( Structure_Hydraulic % useHCF ) case ( 1 ) allocate ( Type_HCF_BC :: Structure_Hydraulic % HCF ) case ( 2 ) allocate ( Type_HCF_VG :: Structure_Hydraulic % HCF ) case ( 3 ) allocate ( Type_HCF_KO :: Structure_Hydraulic % HCF ) case ( 4 ) allocate ( Type_HCF_MVG :: Structure_Hydraulic % HCF ) case ( 5 ) allocate ( Type_HCF_Durner :: Structure_Hydraulic % HCF ) case ( 6 ) allocate ( Type_HCF_DVGCH :: Structure_Hydraulic % HCF ) case default print * , \"Error: HCFModelType is not defined.\" end select end subroutine Allocate_Structure_HCF_Type end module Allocate_Structure","tags":"","loc":"sourcefile/allocate_structure.f90.html"},{"title":"Allocate.f90 – FTDSS","text":"This file depends on sourcefile~~allocate.f90~~EfferentGraph sourcefile~allocate.f90 Allocate.f90 sourcefile~error.f90 error.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~types.f90 Types.f90 sourcefile~allocate.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~allocate.f90~~AfferentGraph sourcefile~allocate.f90 Allocate.f90 sourcefile~convertcrs.f90 ConvertCRS.f90 sourcefile~convertcrs.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~observation.f90 Observation.f90 sourcefile~observation.f90->sourcefile~allocate.f90 sourcefile~output.f90 Output.f90 sourcefile~output.f90->sourcefile~allocate.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~assemble.f90->sourcefile~allocate.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~allocate.f90 sourcefile~heat.f90->sourcefile~allocate_structure.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~allocate.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~initialize.f90 Initialize.f90 sourcefile~initialize.f90->sourcefile~allocate.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate_structure.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Allocate Source Code Allocate.f90 Source Code module Allocate use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: error use :: Types implicit none private interface Allocate_Vector procedure :: Check_Allocate_rank1_int32 procedure :: Check_Allocate_rank1_real64 procedure :: Check_Allocate_rank1_logical procedure :: Check_Allocate_rank1_int32_specify procedure :: Check_Allocate_rank1_real64_specify end interface interface Allocate_Matrix procedure :: Check_Allocate_rank2_int32 procedure :: Check_Allocate_rank2_real64 end interface interface Allocate_Pointer procedure :: Check_Allocate_Pointer_real64 procedure :: Check_Allocate_Pointer_int32 end interface public :: Allocate_Vector public :: Allocate_Matrix public :: Allocate_Pointer public :: Duplicate_CRS contains subroutine Check_Allocate_rank1_int32 ( iar , ar_size ) implicit none integer ( int32 ), intent ( in ) :: ar_size integer ( int32 ), intent ( inout ), allocatable :: iar (:) if ( ar_size <= 0 ) call error_message ( 951 ) if (. not . allocated ( iar )) then allocate ( iar ( ar_size )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_int32 subroutine Check_Allocate_rank1_real64 ( dar , ar_size ) implicit none integer ( int32 ), intent ( in ) :: ar_size real ( real64 ), intent ( inout ), allocatable :: dar (:) if ( ar_size <= 0 ) call error_message ( 951 ) if (. not . allocated ( dar )) then allocate ( dar ( ar_size )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_real64 subroutine Check_Allocate_rank1_logical ( lar , ar_size ) implicit none integer ( int32 ), intent ( in ) :: ar_size logical , intent ( inout ), allocatable :: lar (:) if ( ar_size <= 0 ) call error_message ( 951 ) if (. not . allocated ( lar )) then allocate ( lar ( ar_size )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_logical subroutine Check_Allocate_rank1_int32_specify ( iar , ar_first , ar_last ) implicit none integer ( int32 ), intent ( in ) :: ar_first , ar_last integer ( int32 ), intent ( inout ), allocatable :: iar (:) if (. not . allocated ( iar )) then allocate ( iar ( ar_first : ar_last )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_int32_specify subroutine Check_Allocate_rank1_real64_specify ( dar , ar_first , ar_last ) implicit none integer ( int32 ), intent ( in ) :: ar_first , ar_last real ( real64 ), intent ( inout ), allocatable :: dar (:) if (. not . allocated ( dar )) then allocate ( dar ( ar_first : ar_last )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_real64_specify subroutine Check_Allocate_rank2_int32 ( imt , mt_size_1 , mt_size_2 ) implicit none integer ( int32 ), intent ( in ) :: mt_size_1 , mt_size_2 integer ( int32 ), intent ( inout ), allocatable :: imt (:,:) if ( mt_size_1 <= 0 . or . mt_size_2 <= 0 ) call error_message ( 952 ) if (. not . allocated ( imt )) then allocate ( imt ( mt_size_1 , mt_size_2 )) else call error_message ( 954 ) end if end subroutine Check_Allocate_rank2_int32 subroutine Check_Allocate_rank2_real64 ( dmt , mt_size_1 , mt_size_2 ) implicit none integer ( int32 ), intent ( in ) :: mt_size_1 , mt_size_2 real ( real64 ), intent ( inout ), allocatable :: dmt (:,:) if ( mt_size_1 <= 0 . or . mt_size_2 <= 0 ) call error_message ( 952 ) if (. not . allocated ( dmt )) then allocate ( dmt ( mt_size_1 , mt_size_2 )) else call error_message ( 954 ) end if end subroutine Check_Allocate_rank2_real64 subroutine Check_Allocate_Pointer_int32 ( iptr ) implicit none integer ( int32 ), pointer :: iptr if (. not . associated ( iptr )) then allocate ( iptr ) else call error_message ( 955 ) end if end subroutine Check_Allocate_Pointer_int32 subroutine Check_Allocate_Pointer_real64 ( dptr ) implicit none real ( real64 ), pointer :: dptr if (. not . associated ( dptr )) then allocate ( dptr ) else call error_message ( 955 ) end if end subroutine Check_Allocate_Pointer_real64 subroutine Duplicate_CRS ( A , B ) implicit none type ( CRS ), intent ( in ) :: A type ( CRS ), intent ( inout ) :: B B % nnz = A % nnz if (. not . allocated ( B % Ptr )) then allocate ( B % Ptr , source = A % Ptr ) else ! call error_message(951) end if if (. not . allocated ( B % Ind )) then allocate ( B % Ind , source = A % Ind ) else ! call error_message(951) end if if (. not . allocated ( B % val )) then allocate ( B % val , source = A % Val ) else ! call error_message(951) end if B % val = 0.0d0 end subroutine Duplicate_CRS end module Allocate","tags":"","loc":"sourcefile/allocate.f90.html"},{"title":"FixInitialCondition.f90 – FTDSS","text":"This file depends on sourcefile~~fixinitialcondition.f90~~EfferentGraph sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~types.f90 Types.f90 sourcefile~fixinitialcondition.f90->sourcefile~types.f90 sourcefile~fixboundarycondition.f90 FixBoundaryCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~fixboundarycondition.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate_structure.f90 sourcefile~update.f90 Update.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate.f90 sourcefile~error.f90 error.f90 sourcefile~fixinitialcondition.f90->sourcefile~error.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~solve.f90 Solve.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 sourcefile~fixboundarycondition.f90->sourcefile~types.f90 sourcefile~findind.f90 FindInd.f90 sourcefile~fixboundarycondition.f90->sourcefile~findind.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~update.f90->sourcefile~types.f90 sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~update.f90->sourcefile~binaryfinding.f90 sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~update.f90->sourcefile~secantmethod.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~assemble.f90->sourcefile~types.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~assemble.f90->sourcefile~allocate.f90 sourcefile~assemble.f90->sourcefile~error.f90 sourcefile~assemble.f90->sourcefile~findind.f90 sourcefile~product.f90 Product.f90 sourcefile~assemble.f90->sourcefile~product.f90 sourcefile~solve.f90->sourcefile~types.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~solve.f90->sourcefile~allocate.f90 sourcefile~solve.f90->sourcefile~error.f90 sourcefile~precon_jacobi.f90 Precon_jacobi.f90 sourcefile~solve.f90->sourcefile~precon_jacobi.f90 sourcefile~blas.f90 BLAS.f90 sourcefile~solve.f90->sourcefile~blas.f90 sourcefile~solve.f90->sourcefile~product.f90 sourcefile~precon_jacobi.f90->sourcefile~types.f90 sourcefile~blas.f90->sourcefile~types.f90 sourcefile~findind.f90->sourcefile~types.f90 sourcefile~product.f90->sourcefile~types.f90 sourcefile~binaryfinding.f90->sourcefile~types.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~binaryfinding.f90->sourcefile~latentheat.f90 sourcefile~secantmethod.f90->sourcefile~types.f90 sourcefile~secantmethod.f90->sourcefile~latentheat.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Condition_FixInitialCondition Source Code FixInitialCondition.f90 Source Code module Condition_FixInitialCondition use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types , g => GravityAcceleration use :: Allocate , only : Duplicate_CRS use :: Allocate_Structure use :: error use :: Calculate_Update use :: Condition_FixBoundaryCondition use :: Matrix_Assemble , only : Assemble_GM_Heat_IC , Assemble_GM_Water_IC use :: Solver_Solve implicit none private public :: Fix_InitialCondition contains subroutine Fix_InitialCondition ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver if ( Solver % isHeat ) then if ( Solver % IC % Heat % type == 1 ) then call Fix_InitialCondtion_Constant_Heat ( Solver ) else if ( Solver % IC % Heat % type == 2 ) then call Fix_InitialCondition_Gradient_Heat ( Solver ) Solver % IC % Heat % isSet = . false . end if if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) \"Set initial value of Temperature.\" end if if ( Solver % isWater ) then if ( Solver % IC % Water % type == 1 ) then call Fix_InitialCondtion_Constant_Water ( Solver ) else if ( Solver % IC % Water % type == 2 ) then call Fix_InitialCondition_Gradient_Water ( Solver ) Solver % IC % Water % isSet = . false . end if if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) \"Set initial value of Pressure.\" end if if ( Solver % isStress ) then ! To be implemented ! if (Solver%IC%Stress%type == 1) then !     call Fix_InitialCondtion_Constant(Solver) ! else if (Solver%IC%Stress%type == 2) then !     call Fix_InitialCondition_Gradient(Solver) ! end if ! if (Solver%Flags%isStdOut) write(*,'(a)') \"Set initial value of Stress.\" end if call Fix_InitialCondition_FreezingRate ( Solver ) end subroutine Fix_InitialCondition subroutine Fix_InitialCondtion_Constant_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , iBC integer ( int32 ) :: ntBC , nBC do iN = 1 , Solver % N % node Solver % T % pre ( iN ) = Solver % IC % Heat % Value end do ! 初期温度場への境界条件の設定 do iBC = 1 , Solver % BC % numNode ntBC = Solver % BC % Heat % Type ( Solver % BC % Heat % TypeKey ( iBC )) if ( 10 <= ntBC . and . ntBC <= 19 ) then Solver % T % pre ( Solver % BC % Heat % Node ( iBC )) = Solver % BC % Heat % Value ( Solver % BC % Heat % TypeKey ( iBC )) end if end do end subroutine Fix_InitialCondtion_Constant_Heat subroutine Fix_InitialCondtion_Constant_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , iBC integer ( int32 ) :: ntBC , nBC do iN = 1 , Solver % N % node Solver % P % pre ( iN ) = Solver % IC % Water % Value end do ! 初期圧力場への境界条件の設定 do iBC = 1 , Solver % BC % numNode ntBC = Solver % BC % Water % Type ( Solver % BC % Water % TypeKey ( iBC )) if ( 20 <= ntBC . and . ntBC <= 29 ) then Solver % P % pre ( Solver % BC % Water % Node ( iBC )) = Solver % BC % Water % Value ( Solver % BC % Water % TypeKey ( iBC )) end if end do end subroutine Fix_InitialCondtion_Constant_Water subroutine Fix_InitialCondition_Gradient_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver type ( ILS ), allocatable :: ILEQ integer ( int32 ) :: ierr ILEQ = ILS ( Solver , Solver % Heat % LHS_A ) call Update_Parameters_Heat ( Solver ) call Assemble_GM_Heat_IC ( Solver ) call Fix_BoundaryConditions ( Solver , Temperature ) call ILEQ % BiCGStab ( Solver , Solver % Heat % LHS_A , Solver % Heat % Rhs , Solver % T % pre , ierr ) call ILEQ % Chkerr ( ierr , 0.0d0 ) deallocate ( ILEQ ) end subroutine Fix_InitialCondition_Gradient_Heat subroutine Fix_InitialCondition_Gradient_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver type ( DLS ) :: DLEQ Solver % Si % old (:) = Solver % Si % pre (:) Solver % Si % pre (:) = 0.0d0 call Update_Parameters_Water ( Solver ) Solver % Si % pre (:) = Solver % Si % old (:) call Assemble_GM_Water_IC ( Solver ) call Fix_BoundaryConditions ( Solver , Pressure ) DLEQ = DLS ( Solver ) call DLEQ % LU ( Solver % Water % RA , Solver % Water % Rhs , Solver % P % pre ) end subroutine Fix_InitialCondition_Gradient_Water subroutine Fix_InitialCondition_FreezingRate ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , iBC real ( real64 ) :: Tf ! GCC model real ( real64 ) :: Qs , Qr , alpha , n , m , Lf real ( real64 ), parameter :: TtoK = 27 3.15d0 ! Power model real ( real64 ) :: a if ( Solver % Flags % isTRM ) then do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < 0.0d0 ) then Solver % Si % pre ( iN ) = 1.0d0 else Solver % Si % pre ( iN ) = 0.0d0 end if end do else if ( Solver % Flags % isGCC ) then Qs = Solver % Heat % Latent % GCC % thetaS Qr = Solver % Heat % Latent % GCC % thetaR alpha = Solver % Heat % Latent % GCC % alpha n = Solver % Heat % Latent % GCC % n m = Solver % Heat % Latent % GCC % m Lf = Solver % Heat % Latent % Lf Tf = Solver % Heat % Latent % GCC % Tf do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = (( Qs - Qr ) * ( 1.0d0 - ( 1.0d0 + abs ( alpha * Lf * log (( Solver % T % pre ( iN ) + TtoK ) / TtoK ) / g ) & ** n ) ** ( - m ))) / Qs else Solver % Si % pre ( iN ) = 0.0d0 end if end do else if ( Solver % Flags % isPower ) then Tf = Solver % Heat % Latent % Power % Tf a = Solver % Heat % Latent % Power % a do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = 1.0d0 - ( 1.0d0 - Solver % T % pre ( iN ) + Tf ) ** a else Solver % Si % pre ( iN ) = 0.0d0 end if end do end if if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) \"Set initial value of Freezing rate.\" end subroutine Fix_InitialCondition_FreezingRate end module Condition_FixInitialCondition","tags":"","loc":"sourcefile/fixinitialcondition.f90.html"},{"title":"FixBoundaryCondition.f90 – FTDSS","text":"This file depends on sourcefile~~fixboundarycondition.f90~~EfferentGraph sourcefile~fixboundarycondition.f90 FixBoundaryCondition.f90 sourcefile~types.f90 Types.f90 sourcefile~fixboundarycondition.f90->sourcefile~types.f90 sourcefile~findind.f90 FindInd.f90 sourcefile~fixboundarycondition.f90->sourcefile~findind.f90 sourcefile~findind.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~fixboundarycondition.f90~~AfferentGraph sourcefile~fixboundarycondition.f90 FixBoundaryCondition.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~fixboundarycondition.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules Condition_FixBoundaryCondition Source Code FixBoundaryCondition.f90 Source Code module Condition_FixBoundaryCondition use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types , Tmp => Temperature , Prs => Pressure , Sts => Stress use :: Matrix_FindInd implicit none private public :: Fix_BoundaryConditions contains subroutine Fix_BoundaryConditions ( Solver , inTarget ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: inTarget integer ( int32 ) :: iBC , i integer ( int32 ) :: iBCType integer ( int32 ) :: p1 , p2 do iBC = 1 , Solver % BC % numNode if ( inTarget == Tmp ) then iBCType = Solver % BC % Heat % type ( Solver % BC % Heat % TypeKey ( iBC )) if ( 10 <= iBCType . and . iBCType <= 19 ) then call Fix_DirichletBoundaryCondition_Temperature ( Solver , iBC ) ! call Fix_DirichletBoundaryCondition_Temperature_F(Solver, iBC) end if else if ( inTarget == Prs ) then iBCType = Solver % BC % Water % type ( Solver % BC % Water % TypeKey ( iBC )) if ( 10 <= iBCType . and . iBCType <= 19 ) then ! call Fix_DirichletBoundaryCondition_Water(Solver, iBC) call Fix_DirichletBoundaryCondition_Water_F ( Solver , iBC ) end if end if ! stop ! Solver%Water%Variables%wFlux%y(Solver%BC%Water%TypeKey(iBC)) = 0.0d0 ! if (Solver%BC%Water%TypeKey(iBC) == 4) Solver%Water%Variables%wFlux%x(Solver%BC%Water%TypeKey(iBC)) = 0.0d0 end do if ( inTarget == Tmp . and . Solver % BC % numEdges > 0 ) then do i = 1 , Solver % BC % numEdges p1 = Solver % BC % Heat % Edges % x ( i ) p2 = Solver % BC % Heat % Edges % y ( i ) Solver % Heat % Rhs ( p1 ) = Solver % Heat % Rhs ( p1 ) - ( 2.0d0 * Solver % Heat % Variables % TFlux % x ( p1 ) + Solver % Heat % Variables % TFlux % x ( p2 )) * Solver % BC % Heat % EdgesDistance ( i ) / 6.0d0 Solver % Heat % Rhs ( p2 ) = Solver % Heat % Rhs ( p2 ) - ( Solver % Heat % Variables % TFlux % x ( p1 ) + 2.0d0 * Solver % Heat % Variables % TFlux % x ( p2 )) * Solver % BC % Heat % EdgesDistance ( i ) / 6.0d0 ! print*,Solver%Heat%Rhs(p1),Solver%Heat%Rhs(p2) ! print*,Solver%Heat%Variables%TFlux%x(p1),Solver%Heat%Variables%TFlux%x(p2) ! print*,(Solver%N%vCood%x(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%x(Solver%BC%Heat%Edges%x(i))),(Solver%N%vCood%y(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%y(Solver%BC%Heat%Edges%x(i))) end do ! print*, Solver%BC%Heat%EdgesDistance(:) ! print *, \"Water\" ! stop end if end subroutine Fix_BoundaryConditions subroutine Fix_DirichletBoundaryCondition_Temperature ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Heat % Node ( iBC ) call Find_CRS_Index ( Solver % Heat % LHS_A , iCol , iCol , ind ) ps = Solver % Heat % LHS_A % Ptr ( iCol - 1 ) pe = Solver % Heat % LHS_A % Ptr ( iCol ) - 1 Solver % Heat % LHS_A % val ( ps : pe ) = 0.0d0 Solver % Heat % LHS_A % val ( ind ) = 1.0d0 Solver % Heat % Rhs ( iCol ) = Solver % BC % Heat % value ( Solver % BC % Heat % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Temperature subroutine Fix_DirichletBoundaryCondition_Temperature_F ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Heat % Node ( iBC ) ! print*,iCol,iBC Solver % Heat % RA ( iCol , :) = 0.0d0 Solver % Heat % RA ( iCol , iCol ) = 1.0d0 Solver % Heat % Rhs ( iCol ) = Solver % BC % Heat % value ( Solver % BC % Heat % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Temperature_F subroutine Fix_DirichletBoundaryCondition_Water ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Water % Node ( iBC ) call Find_CRS_Index ( Solver % Water % LHS_A , iCol , iCol , ind ) ps = Solver % Water % LHS_A % Ptr ( iCol - 1 ) pe = Solver % Water % LHS_A % Ptr ( iCol ) - 1 Solver % Water % LHS_A % val ( ps : pe ) = 0.0d0 Solver % Water % LHS_A % val ( ind ) = 1.0d0 Solver % Water % Rhs ( iCol ) = Solver % BC % Water % value ( Solver % BC % Water % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Water subroutine Fix_DirichletBoundaryCondition_Water_F ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Water % Node ( iBC ) Solver % Water % RA ( iCol , :) = 0.0d0 Solver % Water % RA ( iCol , iCol ) = 1.0d0 Solver % Water % Rhs ( iCol ) = Solver % BC % Water % value ( Solver % BC % Water % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Water_F end module Condition_FixBoundaryCondition","tags":"","loc":"sourcefile/fixboundarycondition.f90.html"},{"title":"Read Me – FTDSS","text":"Freezing Thawing Dynamics Simulation Solver Compiler Support Goals and Motivations Scope Install Software environment Fortran 90 and later Intel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2024.1.0 Build 20240308 Lis version 2.1.3 GNU Make 3.81 Operation System Host OS エディション  Windows 11 Pro バージョン   23H2 インストール日 2024/05/24 OS ビルド  22631.3958 エクスペリエンス    Windows Feature Experience Pack 1000.22700.1026.0 Windows subsytem for linux (WSL2) Ubuntu 24.04.1 LTS Red Hat Enterprise Linux release 9.4 (Plow) Execution environment CPU Intel Core i9 14900K MB Z790 Steel Legend WiFi Memory DDR5-5600 32GB×4 GPU NVIDIA GeForce RTX 4060Ti Usage Contributions Links Documents","tags":"","loc":"page/index.html"},{"title":"license – FTDSS","text":"Copyright (C) 2025 Kikuchi Shun Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. lis lisence\nTERMS AND CONDITIONS OF LICENSE FOR THE SOFTWARE Copyright (C) 2005 The Scalable Software Infrastructure Project, \nsupported by ``Development of Software Infrastructure for Large Scale\nScientific Simulation'' Team, CREST, JST. Akira Nishida, CREST team director, JST. All rights reserved. JSON-Fortran: A Modern Fortran JSON API https://github.com/jacobwilliams/json-fortran Copyright (c) 2014-2024, Jacob Williams\nAll rights reserved.","tags":"","loc":"page/lisence.html"}]}