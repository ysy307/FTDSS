var tipuesearch = {"pages":[{"title":" Freezing Thawing Dynamics Simulation Solver ","text":"Freezing Thawing Dynamics Simulation Solver 土壌凍結融解過程における数値計算ソルバーへの実装 Warning Work in progress 概要 土壌凍結融解過程の水分・熱移動の数値計算 Note このプロジェクトでは，Fortranで係れている． Todo リファクタリング コマンドライン引数への対応 他 Bug 現在の所バグは見つかっていない． Developer Info Kikuchi Shun","tags":"home","loc":"index.html"},{"title":"Heat – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Heat Inherits type~~heat~~InheritsGraph type~heat Heat type~geometry_2d Geometry_2D type~heat->type~geometry_2d Geometry type~boudary_condition Boudary_Condition type~heat->type~boudary_condition BC type~hcf HCF type~heat->type~hcf HCFs type~dp2d DP2d type~geometry_2d->type~dp2d Nodes_2D type~shape Shape type~geometry_2d->type~shape Shape_Function type~boudary_condition_dirichlet Boudary_Condition_Dirichlet type~boudary_condition->type~boudary_condition_dirichlet Dirichlet type~boudary_condition_neumann Boudary_Condition_Neumann type~boudary_condition->type~boudary_condition_neumann Neumann type~hcf_parameters HCF_Parameters type~hcf->type~hcf_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Constructor Heat Constructor public interface Heat private function Heat_Constructor(Structure_Input) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Structure_Input Return Value type( Heat )","tags":"","loc":"type/heat.html"},{"title":"Output – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Output Contents Constructor Output Type-Bound Procedures Output_All Output_Observation Constructor public interface Output private function Output_Constructor(Inputs) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Inputs Return Value type( Output ) Type-Bound Procedures procedure, public :: Output_All => Inout_Output_All private subroutine Inout_Output_All(self, Solver, num) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: num procedure, public :: Output_Observation => Inout_Output_Observation private subroutine Inout_Output_Observation(self, Solver, time) Arguments Type Intent Optional Attributes Name class( Output ) :: self type( SolverInfo ), intent(inout) :: Solver real(kind=real64), intent(in) :: time","tags":"","loc":"type/output.html"},{"title":"HCF – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( HCF_Parameters ) :: HCF Inherits type~~hcf~~InheritsGraph type~hcf HCF type~hcf_parameters HCF_Parameters type~hcf->type~hcf_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~hcf~~InheritedByGraph type~hcf HCF type~heat Heat type~heat->type~hcf HCFs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR alpha1 alpha2 n1 n2 m1 m2 hcrit w1 w2 Ks kzero l Omega Calculate_HCF Calculate_HCF_mu Constructor HCF Type-Bound Procedures Calculate_Kflh Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: Ks real(kind=real64), public :: kzero real(kind=real64), public :: l real(kind=real64), public :: Omega procedure( Calculation_HCF ), public, pointer, nopass :: Calculate_HCF => null() procedure( Calculation_HCF_mu ), public, pointer, nopass :: Calculate_HCF_mu => null() Constructor public interface HCF public function HCF_Constructor (in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in_HCF_Parameters (:) integer(kind=int32), intent(in) :: HCF_Model_id integer(kind=int32), intent(in) :: Kflh_Model_id Return Value type( HCF ) Type-Bound Procedures procedure, public :: Calculate_Kflh => Calculate_Ks public function Calculate_Ks (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name class( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64)","tags":"","loc":"type/hcf.html"},{"title":"VC – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: VC sequence Contents Variables x y Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y","tags":"","loc":"type/vc.html"},{"title":"Vector2D – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Vector2D sequence Inherited by type~~vector2d~~InheritedByGraph type~vector2d Vector2D type~type_thermalconductivity_3phase_dispersity_2d Type_ThermalConductivity_3Phase_Dispersity_2D type~type_thermalconductivity_3phase_dispersity_2d->type~vector2d dispersity type~heatconstants HeatConstants type~heatconstants->type~vector2d dispersity type~heatfields HeatFields type~heatfields->type~heatconstants Constants type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables x y Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y","tags":"","loc":"type/vector2d.html"},{"title":"Vector3D – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Vector3D sequence Inherited by type~~vector3d~~InheritedByGraph type~vector3d Vector3D type~type_thermalconductivity_3phase_dispersity_3d Type_ThermalConductivity_3Phase_Dispersity_3D type~type_thermalconductivity_3phase_dispersity_3d->type~vector3d dispersity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables x y z Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y real(kind=real64), public :: z","tags":"","loc":"type/vector3d.html"},{"title":"DP2d – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: DP2d sequence Inherited by type~~dp2d~~InheritedByGraph type~dp2d DP2d type~geometry_2d Geometry_2D type~geometry_2d->type~dp2d Nodes_2D type~watervariables WaterVariables type~watervariables->type~dp2d wFlux, hGrad type~heatvariables HeatVariables type~heatvariables->type~dp2d Tgrad, TFlux type~observation2d Observation2d type~observation2d->type~dp2d obsCOO type~geometry2d Geometry2d type~geometry2d->type~dp2d vCood type~heat Heat type~heat->type~geometry_2d Geometry type~solverinfo SolverInfo type~solverinfo->type~observation2d Obs type~solverinfo->type~geometry2d N type~waterfields WaterFields type~solverinfo->type~waterfields Water type~heatfields HeatFields type~solverinfo->type~heatfields Heat type~waterfields->type~watervariables Variables type~heatfields->type~heatvariables Variables Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables x y Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: x (:) real(kind=real64), public, allocatable :: y (:)","tags":"","loc":"type/dp2d.html"},{"title":"DP3d – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: DP3d sequence Contents Variables x y z Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: x (:) real(kind=real64), public, allocatable :: y (:) real(kind=real64), public, allocatable :: z (:)","tags":"","loc":"type/dp3d.html"},{"title":"INT2d – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: INT2d sequence Inherited by type~~int2d~~InheritedByGraph type~int2d INT2d type~boudaryconditioninfo BoudaryConditionInfo type~boudaryconditioninfo->type~int2d Edges type~boudarycondition BoudaryCondition type~boudarycondition->type~boudaryconditioninfo Heat, Water, Stress type~solverinfo SolverInfo type~solverinfo->type~boudarycondition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables x y Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: x (:) integer(kind=int32), public, allocatable :: y (:)","tags":"","loc":"type/int2d.html"},{"title":"INT3d – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: INT3d sequence Contents Variables x y z Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: x (:) integer(kind=int32), public, allocatable :: y (:) integer(kind=int32), public, allocatable :: z (:)","tags":"","loc":"type/int3d.html"},{"title":"PH – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: PH sequence Contents Variables soil water ice Components Type Visibility Attributes Name Initial real(kind=real64), public :: soil real(kind=real64), public :: water real(kind=real64), public :: ice","tags":"","loc":"type/ph.html"},{"title":"Phases – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Phases sequence Inherited by type~~phases~~InheritedByGraph type~phases Phases type~heatconstants HeatConstants type~heatconstants->type~phases Density, ThermalConductivity, SpecificHeat, HeatCapacity type~waterconstants WaterConstants type~waterconstants->type~phases HydraulicConductivity type~heatfields HeatFields type~heatfields->type~heatconstants Constants type~waterfields WaterFields type~waterfields->type~waterconstants Constants type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat type~solverinfo->type~waterfields Water Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables soil water ice Components Type Visibility Attributes Name Initial real(kind=real64), public :: soil real(kind=real64), public :: water real(kind=real64), public :: ice","tags":"","loc":"type/phases.html"},{"title":"Shape – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Shape sequence Inherited by type~~shape~~InheritedByGraph type~shape Shape type~geometry_2d Geometry_2D type~geometry_2d->type~shape Shape_Function type~geometry2d Geometry2d type~geometry2d->type~shape Basis type~heat Heat type~heat->type~geometry_2d Geometry type~solverinfo SolverInfo type~solverinfo->type~geometry2d N Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables a b c d Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: a (:,:) real(kind=real64), public, allocatable :: b (:,:) real(kind=real64), public, allocatable :: c (:,:) real(kind=real64), public, allocatable :: d (:,:)","tags":"","loc":"type/shape.html"},{"title":"BoudaryConditionInfo – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: BoudaryConditionInfo Inherits type~~boudaryconditioninfo~~InheritsGraph type~boudaryconditioninfo BoudaryConditionInfo type~int2d INT2d type~boudaryconditioninfo->type~int2d Edges Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~boudaryconditioninfo~~InheritedByGraph type~boudaryconditioninfo BoudaryConditionInfo type~boudarycondition BoudaryCondition type~boudarycondition->type~boudaryconditioninfo Heat, Water, Stress type~solverinfo SolverInfo type~solverinfo->type~boudarycondition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Node TypeKey type value Edges EdgesDirection EdgesDistance Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: Node (:) integer(kind=int32), public, allocatable :: TypeKey (:) integer(kind=int32), public, allocatable :: type (:) real(kind=real64), public, allocatable :: value (:) type( INT2d ), public :: Edges integer(kind=int32), public, allocatable :: EdgesDirection (:) real(kind=real64), public, allocatable :: EdgesDistance (:)","tags":"","loc":"type/boudaryconditioninfo.html"},{"title":"BoudaryCondition – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: BoudaryCondition Inherits type~~boudarycondition~~InheritsGraph type~boudarycondition BoudaryCondition type~boudaryconditioninfo BoudaryConditionInfo type~boudarycondition->type~boudaryconditioninfo Heat, Water, Stress type~int2d INT2d type~boudaryconditioninfo->type~int2d Edges Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~boudarycondition~~InheritedByGraph type~boudarycondition BoudaryCondition type~solverinfo SolverInfo type~solverinfo->type~boudarycondition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Heat Water Stress numNode numType numEdges Components Type Visibility Attributes Name Initial type( BoudaryConditionInfo ), public :: Heat type( BoudaryConditionInfo ), public :: Water type( BoudaryConditionInfo ), public :: Stress integer(kind=int32), public :: numNode integer(kind=int32), public :: numType integer(kind=int32), public :: numEdges","tags":"","loc":"type/boudarycondition.html"},{"title":"Boudary_Condition_Dirichlet – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Boudary_Condition_Dirichlet Inherited by type~~boudary_condition_dirichlet~~InheritedByGraph type~boudary_condition_dirichlet Boudary_Condition_Dirichlet type~boudary_condition Boudary_Condition type~boudary_condition->type~boudary_condition_dirichlet Dirichlet type~heat Heat type~heat->type~boudary_condition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Num_Node Num_Type Node Node_Type Value_Info value Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Node integer(kind=int32), public :: Num_Type integer(kind=int32), public, allocatable :: Node (:) integer(kind=int32), public, allocatable :: Node_Type (:) integer(kind=int32), public, allocatable :: Value_Info (:) real(kind=real64), public, allocatable :: value (:)","tags":"","loc":"type/boudary_condition_dirichlet.html"},{"title":"Boudary_Condition_Neumann – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Boudary_Condition_Neumann Inherited by type~~boudary_condition_neumann~~InheritedByGraph type~boudary_condition_neumann Boudary_Condition_Neumann type~boudary_condition Boudary_Condition type~boudary_condition->type~boudary_condition_neumann Neumann type~heat Heat type~heat->type~boudary_condition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Num_Edge Num_Edge_Type Num_Type Edge Edge_Type Value_Info value Heat_Transfer Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Edge integer(kind=int32), public :: Num_Edge_Type integer(kind=int32), public :: Num_Type integer(kind=int32), public, allocatable :: Edge (:,:) integer(kind=int32), public, allocatable :: Edge_Type (:) integer(kind=int32), public, allocatable :: Value_Info (:) real(kind=real64), public, allocatable :: value (:) real(kind=real64), public, allocatable :: Heat_Transfer (:)","tags":"","loc":"type/boudary_condition_neumann.html"},{"title":"Boudary_Condition – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Boudary_Condition Inherits type~~boudary_condition~~InheritsGraph type~boudary_condition Boudary_Condition type~boudary_condition_dirichlet Boudary_Condition_Dirichlet type~boudary_condition->type~boudary_condition_dirichlet Dirichlet type~boudary_condition_neumann Boudary_Condition_Neumann type~boudary_condition->type~boudary_condition_neumann Neumann Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~boudary_condition~~InheritedByGraph type~boudary_condition Boudary_Condition type~heat Heat type~heat->type~boudary_condition BC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Dirichlet Neumann Components Type Visibility Attributes Name Initial type( Boudary_Condition_Dirichlet ), public :: Dirichlet type( Boudary_Condition_Neumann ), public :: Neumann","tags":"","loc":"type/boudary_condition.html"},{"title":"InitialConditionInfo – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: InitialConditionInfo Inherited by type~~initialconditioninfo~~InheritedByGraph type~initialconditioninfo InitialConditionInfo type~initialcondition InitialCondition type~initialcondition->type~initialconditioninfo Heat, Water, Stress type~solverinfo SolverInfo type~solverinfo->type~initialcondition IC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables type value isSet Components Type Visibility Attributes Name Initial integer(kind=int32), public :: type real(kind=real64), public :: value logical, public :: isSet","tags":"","loc":"type/initialconditioninfo.html"},{"title":"InitialCondition – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: InitialCondition Inherits type~~initialcondition~~InheritsGraph type~initialcondition InitialCondition type~initialconditioninfo InitialConditionInfo type~initialcondition->type~initialconditioninfo Heat, Water, Stress Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~initialcondition~~InheritedByGraph type~initialcondition InitialCondition type~solverinfo SolverInfo type~solverinfo->type~initialcondition IC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Heat Water Stress Components Type Visibility Attributes Name Initial type( InitialConditionInfo ), public :: Heat type( InitialConditionInfo ), public :: Water type( InitialConditionInfo ), public :: Stress","tags":"","loc":"type/initialcondition.html"},{"title":"MPIInfo – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: MPIInfo Inherited by type~~mpiinfo~~InheritedByGraph type~mpiinfo MPIInfo type~solverinfo SolverInfo type~solverinfo->type~mpiinfo MPI Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables size rank Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size integer(kind=int32), public :: rank","tags":"","loc":"type/mpiinfo.html"},{"title":"Basic_params – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Basic_params Contents Variables Element Node Shape Dim Region Calculation_timeUnit Input_timeUnit Output_timeUnit Interval_timeUnit Calculation_step CalculationPeriod Interval isDisplayPrompt FileOutput Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Element integer(kind=int32), public :: Node integer(kind=int32), public :: Shape integer(kind=int32), public :: Dim integer(kind=int32), public :: Region character, public, allocatable :: Calculation_timeUnit character, public, allocatable :: Input_timeUnit character, public, allocatable :: Output_timeUnit character, public, allocatable :: Interval_timeUnit integer(kind=int32), public :: Calculation_step integer(kind=int32), public :: CalculationPeriod integer(kind=int32), public :: Interval logical, public :: isDisplayPrompt character, public, allocatable :: FileOutput","tags":"","loc":"type/basic_params.html"},{"title":"Base_Density – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Base_Density Inherited by type~~base_density~~InheritedByGraph type~base_density Base_Density type~type_thermal Type_Thermal type~type_thermal->type~base_density Density type~type_density_1phase Type_Density_1Phase type~type_density_1phase->type~base_density type~type_density_2phase Type_Density_2Phase type~type_density_2phase->type~base_density type~type_density_3phase Type_Density_3Phase type~type_density_3phase->type~base_density type~type_region Type_Region type~type_region->type~type_thermal Thermal Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents None","tags":"","loc":"type/base_density.html"},{"title":"Type_Density_3Phase – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_Density ) :: Type_Density_3Phase Inherits type~~type_density_3phase~~InheritsGraph type~type_density_3phase Type_Density_3Phase type~base_density Base_Density type~type_density_3phase->type~base_density Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Soil Water Ice Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice","tags":"","loc":"type/type_density_3phase.html"},{"title":"Type_Density_2Phase – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_Density ) :: Type_Density_2Phase Inherits type~~type_density_2phase~~InheritsGraph type~type_density_2phase Type_Density_2Phase type~base_density Base_Density type~type_density_2phase->type~base_density Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Phase1 Phase2 Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2","tags":"","loc":"type/type_density_2phase.html"},{"title":"Type_Density_1Phase – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_Density ) :: Type_Density_1Phase Inherits type~~type_density_1phase~~InheritsGraph type~type_density_1phase Type_Density_1Phase type~base_density Base_Density type~type_density_1phase->type~base_density Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Phase1 Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1","tags":"","loc":"type/type_density_1phase.html"},{"title":"Base_SpecificHeat – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Base_SpecificHeat Inherited by type~~base_specificheat~~InheritedByGraph type~base_specificheat Base_SpecificHeat type~type_thermal Type_Thermal type~type_thermal->type~base_specificheat SpecificHeat type~type_specificheat_2phase Type_SpecificHeat_2Phase type~type_specificheat_2phase->type~base_specificheat type~type_specificheat_1phase Type_SpecificHeat_1Phase type~type_specificheat_1phase->type~base_specificheat type~type_specificheat_3phase Type_SpecificHeat_3Phase type~type_specificheat_3phase->type~base_specificheat type~type_region Type_Region type~type_region->type~type_thermal Thermal Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents None","tags":"","loc":"type/base_specificheat.html"},{"title":"Type_SpecificHeat_3Phase – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_3Phase Inherits type~~type_specificheat_3phase~~InheritsGraph type~type_specificheat_3phase Type_SpecificHeat_3Phase type~base_specificheat Base_SpecificHeat type~type_specificheat_3phase->type~base_specificheat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Soil Water Ice Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice","tags":"","loc":"type/type_specificheat_3phase.html"},{"title":"Type_SpecificHeat_2Phase – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_2Phase Inherits type~~type_specificheat_2phase~~InheritsGraph type~type_specificheat_2phase Type_SpecificHeat_2Phase type~base_specificheat Base_SpecificHeat type~type_specificheat_2phase->type~base_specificheat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Phase1 Phase2 Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2","tags":"","loc":"type/type_specificheat_2phase.html"},{"title":"Type_SpecificHeat_1Phase – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_1Phase Inherits type~~type_specificheat_1phase~~InheritsGraph type~type_specificheat_1phase Type_SpecificHeat_1Phase type~base_specificheat Base_SpecificHeat type~type_specificheat_1phase->type~base_specificheat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Phase1 Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1","tags":"","loc":"type/type_specificheat_1phase.html"},{"title":"Base_ThermalConductivity – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Base_ThermalConductivity Inherited by type~~base_thermalconductivity~~InheritedByGraph type~base_thermalconductivity Base_ThermalConductivity type~type_thermal Type_Thermal type~type_thermal->type~base_thermalconductivity ThermalConductivity type~type_thermalconductivity_1phase Type_ThermalConductivity_1Phase type~type_thermalconductivity_1phase->type~base_thermalconductivity type~type_thermalconductivity_3phase Type_ThermalConductivity_3Phase type~type_thermalconductivity_3phase->type~base_thermalconductivity type~type_thermalconductivity_2phase Type_ThermalConductivity_2Phase type~type_thermalconductivity_2phase->type~base_thermalconductivity type~type_region Type_Region type~type_region->type~type_thermal Thermal type~type_thermalconductivity_3phase_dispersity_3d Type_ThermalConductivity_3Phase_Dispersity_3D type~type_thermalconductivity_3phase_dispersity_3d->type~type_thermalconductivity_3phase type~type_thermalconductivity_3phase_dispersity_2d Type_ThermalConductivity_3Phase_Dispersity_2D type~type_thermalconductivity_3phase_dispersity_2d->type~type_thermalconductivity_3phase Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents None","tags":"","loc":"type/base_thermalconductivity.html"},{"title":"Type_ThermalConductivity_3Phase – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_3Phase Inherits type~~type_thermalconductivity_3phase~~InheritsGraph type~type_thermalconductivity_3phase Type_ThermalConductivity_3Phase type~base_thermalconductivity Base_ThermalConductivity type~type_thermalconductivity_3phase->type~base_thermalconductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_thermalconductivity_3phase~~InheritedByGraph type~type_thermalconductivity_3phase Type_ThermalConductivity_3Phase type~type_thermalconductivity_3phase_dispersity_2d Type_ThermalConductivity_3Phase_Dispersity_2D type~type_thermalconductivity_3phase_dispersity_2d->type~type_thermalconductivity_3phase type~type_thermalconductivity_3phase_dispersity_3d Type_ThermalConductivity_3Phase_Dispersity_3D type~type_thermalconductivity_3phase_dispersity_3d->type~type_thermalconductivity_3phase Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Soil Water Ice Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice","tags":"","loc":"type/type_thermalconductivity_3phase.html"},{"title":"Type_ThermalConductivity_3Phase_Dispersity_2D – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_2D Inherits type~~type_thermalconductivity_3phase_dispersity_2d~~InheritsGraph type~type_thermalconductivity_3phase_dispersity_2d Type_ThermalConductivity_3Phase_Dispersity_2D type~vector2d Vector2D type~type_thermalconductivity_3phase_dispersity_2d->type~vector2d dispersity type~type_thermalconductivity_3phase Type_ThermalConductivity_3Phase type~type_thermalconductivity_3phase_dispersity_2d->type~type_thermalconductivity_3phase type~base_thermalconductivity Base_ThermalConductivity type~type_thermalconductivity_3phase->type~base_thermalconductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Soil Water Ice dispersity Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type( Vector2D ), public :: dispersity","tags":"","loc":"type/type_thermalconductivity_3phase_dispersity_2d.html"},{"title":"Type_ThermalConductivity_3Phase_Dispersity_3D – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_3D Inherits type~~type_thermalconductivity_3phase_dispersity_3d~~InheritsGraph type~type_thermalconductivity_3phase_dispersity_3d Type_ThermalConductivity_3Phase_Dispersity_3D type~vector3d Vector3D type~type_thermalconductivity_3phase_dispersity_3d->type~vector3d dispersity type~type_thermalconductivity_3phase Type_ThermalConductivity_3Phase type~type_thermalconductivity_3phase_dispersity_3d->type~type_thermalconductivity_3phase type~base_thermalconductivity Base_ThermalConductivity type~type_thermalconductivity_3phase->type~base_thermalconductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Soil Water Ice dispersity Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type( Vector3D ), public :: dispersity","tags":"","loc":"type/type_thermalconductivity_3phase_dispersity_3d.html"},{"title":"Type_ThermalConductivity_2Phase – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_2Phase Inherits type~~type_thermalconductivity_2phase~~InheritsGraph type~type_thermalconductivity_2phase Type_ThermalConductivity_2Phase type~base_thermalconductivity Base_ThermalConductivity type~type_thermalconductivity_2phase->type~base_thermalconductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Phase1 Phase2 Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2","tags":"","loc":"type/type_thermalconductivity_2phase.html"},{"title":"Type_ThermalConductivity_1Phase – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_1Phase Inherits type~~type_thermalconductivity_1phase~~InheritsGraph type~type_thermalconductivity_1phase Type_ThermalConductivity_1Phase type~base_thermalconductivity Base_ThermalConductivity type~type_thermalconductivity_1phase->type~base_thermalconductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Phase1 Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1","tags":"","loc":"type/type_thermalconductivity_1phase.html"},{"title":"Base_Ice – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Base_Ice Inherited by type~~base_ice~~InheritedByGraph type~base_ice Base_Ice type~type_thermal Type_Thermal type~type_thermal->type~base_ice Ice type~type_ice_gcc Type_Ice_GCC type~type_ice_gcc->type~base_ice type~type_ice_exp Type_Ice_EXP type~type_ice_exp->type~base_ice type~type_ice_trm Type_Ice_TRM type~type_ice_trm->type~base_ice type~type_region Type_Region type~type_region->type~type_thermal Thermal Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables LatentHeat Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat","tags":"","loc":"type/base_ice.html"},{"title":"Type_Ice_TRM – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_Ice ) :: Type_Ice_TRM Inherits type~~type_ice_trm~~InheritsGraph type~type_ice_trm Type_Ice_TRM type~base_ice Base_Ice type~type_ice_trm->type~base_ice Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables LatentHeat Tf Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf","tags":"","loc":"type/type_ice_trm.html"},{"title":"Type_Ice_GCC – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_Ice ) :: Type_Ice_GCC Inherits type~~type_ice_gcc~~InheritsGraph type~type_ice_gcc Type_Ice_GCC type~base_wrf Base_WRF type~type_ice_gcc->type~base_wrf WRF type~base_ice Base_Ice type~type_ice_gcc->type~base_ice Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables LatentHeat Tf ModelType WRF Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf integer(kind=int32), public :: ModelType class( Base_WRF ), public, allocatable :: WRF","tags":"","loc":"type/type_ice_gcc.html"},{"title":"Type_Ice_EXP – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_Ice ) :: Type_Ice_EXP Inherits type~~type_ice_exp~~InheritsGraph type~type_ice_exp Type_Ice_EXP type~base_ice Base_Ice type~type_ice_exp->type~base_ice Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables LatentHeat Tf a Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf real(kind=real64), public :: a","tags":"","loc":"type/type_ice_exp.html"},{"title":"Type_Thermal – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Type_Thermal Inherits type~~type_thermal~~InheritsGraph type~type_thermal Type_Thermal type~base_density Base_Density type~type_thermal->type~base_density Density type~base_specificheat Base_SpecificHeat type~type_thermal->type~base_specificheat SpecificHeat type~base_thermalconductivity Base_ThermalConductivity type~type_thermal->type~base_thermalconductivity ThermalConductivity type~base_ice Base_Ice type~type_thermal->type~base_ice Ice Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~type_thermal~~InheritedByGraph type~type_thermal Type_Thermal type~type_region Type_Region type~type_region->type~type_thermal Thermal Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Density SpecificHeat ThermalConductivity Porosity Ice Components Type Visibility Attributes Name Initial class( Base_Density ), public, allocatable :: Density class( Base_SpecificHeat ), public, allocatable :: SpecificHeat class( Base_ThermalConductivity ), public, allocatable :: ThermalConductivity real(kind=real64), public :: Porosity class( Base_Ice ), public, allocatable :: Ice","tags":"","loc":"type/type_thermal.html"},{"title":"Base_Hydraulic – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Base_Hydraulic Inherits type~~base_hydraulic~~InheritsGraph type~base_hydraulic Base_Hydraulic type~base_impedance Base_Impedance type~base_hydraulic->type~base_impedance Impedance type~base_ktdynamics Base_KTDynamics type~base_hydraulic->type~base_ktdynamics KTDynamics type~base_hcf Base_HCF type~base_hydraulic->type~base_hcf HCF Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables useImpedance Impedance useKTDynamics KTDynamics useHCF HCF Ks Components Type Visibility Attributes Name Initial logical, public :: useImpedance class( Base_Impedance ), public, allocatable :: Impedance integer(kind=int32), public :: useKTDynamics class( Base_KTDynamics ), public, allocatable :: KTDynamics logical, public :: useHCF class( Base_HCF ), public, allocatable :: HCF real(kind=real64), public :: Ks","tags":"","loc":"type/base_hydraulic.html"},{"title":"Base_Impedance – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Base_Impedance Inherited by type~~base_impedance~~InheritedByGraph type~base_impedance Base_Impedance type~base_hydraulic Base_Hydraulic type~base_hydraulic->type~base_impedance Impedance type~type_impedance Type_Impedance type~type_impedance->type~base_impedance Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents None","tags":"","loc":"type/base_impedance.html"},{"title":"Type_Impedance – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_Impedance ) :: Type_Impedance Inherits type~~type_impedance~~InheritsGraph type~type_impedance Type_Impedance type~base_impedance Base_Impedance type~type_impedance->type~base_impedance Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Omega Components Type Visibility Attributes Name Initial real(kind=real64), public :: Omega","tags":"","loc":"type/type_impedance.html"},{"title":"Base_KTDynamics – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Base_KTDynamics Inherited by type~~base_ktdynamics~~InheritedByGraph type~base_ktdynamics Base_KTDynamics type~base_hydraulic Base_Hydraulic type~base_hydraulic->type~base_ktdynamics KTDynamics type~type_ktdynamics Type_KTDynamics type~type_ktdynamics->type~base_ktdynamics Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents None","tags":"","loc":"type/base_ktdynamics.html"},{"title":"Type_KTDynamics – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_KTDynamics ) :: Type_KTDynamics Inherits type~~type_ktdynamics~~InheritsGraph type~type_ktdynamics Type_KTDynamics type~base_ktdynamics Base_KTDynamics type~type_ktdynamics->type~base_ktdynamics Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables kzero Components Type Visibility Attributes Name Initial real(kind=real64), public :: kzero","tags":"","loc":"type/type_ktdynamics.html"},{"title":"Type_Region_Flags – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Type_Region_Flags Inherited by type~~type_region_flags~~InheritedByGraph type~type_region_flags Type_Region_Flags type~type_region Type_Region type~type_region->type~type_region_flags Flags Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables isHeat isWater isStress is1Phase is2Phase is3Phase isCompression isFrostHeavePressure isDispersity isFrozen Components Type Visibility Attributes Name Initial logical, public :: isHeat logical, public :: isWater logical, public :: isStress logical, public :: is1Phase logical, public :: is2Phase logical, public :: is3Phase logical, public :: isCompression logical, public :: isFrostHeavePressure logical, public :: isDispersity logical, public :: isFrozen","tags":"","loc":"type/type_region_flags.html"},{"title":"Type_Region – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Type_Region Inherits type~~type_region~~InheritsGraph type~type_region Type_Region type~type_thermal Type_Thermal type~type_region->type~type_thermal Thermal type~type_region_flags Type_Region_Flags type~type_region->type~type_region_flags Flags type~base_density Base_Density type~type_thermal->type~base_density Density type~base_specificheat Base_SpecificHeat type~type_thermal->type~base_specificheat SpecificHeat type~base_thermalconductivity Base_ThermalConductivity type~type_thermal->type~base_thermalconductivity ThermalConductivity type~base_ice Base_Ice type~type_thermal->type~base_ice Ice Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables CalculationType Modelnumber Thermal Flags Components Type Visibility Attributes Name Initial integer(kind=int32), public :: CalculationType integer(kind=int32), public :: Modelnumber type( Type_Thermal ), public :: Thermal type( Type_Region_Flags ), public :: Flags","tags":"","loc":"type/type_region.html"},{"title":"DF – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: DF Inherited by type~~df~~InheritedByGraph type~df DF type~heatvariables HeatVariables type~heatvariables->type~df Cs, Cp, lambda, rho, Ca type~watervariables WaterVariables type~watervariables->type~df Klh type~solverinfo SolverInfo type~solverinfo->type~df mWater, mIce, T, P, Si, Sw type~heatfields HeatFields type~solverinfo->type~heatfields Heat type~waterfields WaterFields type~solverinfo->type~waterfields Water type~heatfields->type~heatvariables Variables type~waterfields->type~watervariables Variables Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables new old pre dif div tmp Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: new (:) real(kind=real64), public, allocatable :: old (:) real(kind=real64), public, allocatable :: pre (:) real(kind=real64), public, allocatable :: dif (:) real(kind=real64), public, allocatable :: div (:) real(kind=real64), public, allocatable :: tmp (:)","tags":"","loc":"type/df.html"},{"title":"Flag – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Flag Inherited by type~~flag~~InheritedByGraph type~flag Flag type~solverinfo SolverInfo type~solverinfo->type~flag Flags Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables isTRM isGCC isPower isSwitchTRM isSwitchOnceTRM isStdOut isOutputAll isOutput isPrintLisMem outOBS Components Type Visibility Attributes Name Initial logical, public :: isTRM logical, public :: isGCC logical, public :: isPower logical, public :: isSwitchTRM logical, public :: isSwitchOnceTRM logical, public :: isStdOut logical, public :: isOutputAll logical, public :: isOutput logical, public :: isPrintLisMem logical, public, allocatable :: outOBS (:)","tags":"","loc":"type/flag.html"},{"title":"CRS – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: CRS Inherited by type~~crs~~InheritedByGraph type~crs CRS type~heatfields HeatFields type~heatfields->type~crs LHS_A type~ils ILS type~ils->type~crs CRS_A type~waterfields WaterFields type~waterfields->type~crs LHS_A type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat type~solverinfo->type~waterfields Water Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nnz Ptr Ind Val Components Type Visibility Attributes Name Initial integer(kind=int32), public :: nnz integer(kind=int32), public, allocatable :: Ptr (:) integer(kind=int32), public, allocatable :: Ind (:) real(kind=real64), public, allocatable :: Val (:)","tags":"","loc":"type/crs.html"},{"title":"Lis – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Lis Inherited by type~~lis~~InheritedByGraph type~lis Lis type~solverinfo SolverInfo type~solverinfo->type~lis Lis Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables TSolver TOption PSolver POption Maxiter Tol isOMP Components Type Visibility Attributes Name Initial integer(kind=int32), public :: TSolver integer(kind=int32), public :: TOption integer(kind=int32), public :: PSolver integer(kind=int32), public :: POption integer(kind=int32), public :: Maxiter real(kind=real64), public :: Tol logical, public :: isOMP","tags":"","loc":"type/lis.html"},{"title":"Observation2d – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Observation2d Inherits type~~observation2d~~InheritsGraph type~observation2d Observation2d type~dp2d DP2d type~observation2d->type~dp2d obsCOO Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~observation2d~~InheritedByGraph type~observation2d Observation2d type~solverinfo SolverInfo type~solverinfo->type~observation2d Obs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nObs nObsType obsPoint obsCOO nAreaObs vAreaObs Components Type Visibility Attributes Name Initial integer(kind=int32), public :: nObs integer(kind=int32), public :: nObsType integer(kind=int32), public, allocatable :: obsPoint (:) type( DP2d ), public :: obsCOO integer(kind=int32), public, allocatable :: nAreaObs (:) real(kind=real64), public, allocatable :: vAreaObs (:,:)","tags":"","loc":"type/observation2d.html"},{"title":"HeatVariables – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: HeatVariables Inherits type~~heatvariables~~InheritsGraph type~heatvariables HeatVariables type~df DF type~heatvariables->type~df Cs, Cp, lambda, rho, Ca type~dp2d DP2d type~heatvariables->type~dp2d Tgrad, TFlux Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~heatvariables~~InheritedByGraph type~heatvariables HeatVariables type~heatfields HeatFields type~heatfields->type~heatvariables Variables type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Cs Cp lambda rho Ca Tgrad TFlux Phase Components Type Visibility Attributes Name Initial type( DF ), public :: Cs type( DF ), public :: Cp type( DF ), public :: lambda type( DF ), public :: rho type( DF ), public :: Ca type( DP2d ), public :: Tgrad type( DP2d ), public :: TFlux integer(kind=int32), public, allocatable :: Phase (:)","tags":"","loc":"type/heatvariables.html"},{"title":"HeatConstants – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: HeatConstants Inherits type~~heatconstants~~InheritsGraph type~heatconstants HeatConstants type~phases Phases type~heatconstants->type~phases Density, ThermalConductivity, SpecificHeat, HeatCapacity type~vector2d Vector2D type~heatconstants->type~vector2d dispersity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~heatconstants~~InheritedByGraph type~heatconstants HeatConstants type~heatfields HeatFields type~heatfields->type~heatconstants Constants type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Density ThermalConductivity SpecificHeat HeatCapacity dispersity Porosity LatentHeat Components Type Visibility Attributes Name Initial type( Phases ), public :: Density type( Phases ), public :: ThermalConductivity type( Phases ), public :: SpecificHeat type( Phases ), public :: HeatCapacity type( Vector2D ), public :: dispersity real(kind=real64), public :: Porosity real(kind=real64), public :: LatentHeat","tags":"","loc":"type/heatconstants.html"},{"title":"PowerModel – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: PowerModel Inherited by type~~powermodel~~InheritedByGraph type~powermodel PowerModel type~latentheattreatment LatentHeatTreatment type~latentheattreatment->type~powermodel Power type~heatfields HeatFields type~heatfields->type~latentheattreatment Latent type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables phi Tf a Ca_max Components Type Visibility Attributes Name Initial real(kind=real64), public :: phi real(kind=real64), public :: Tf real(kind=real64), public :: a real(kind=real64), public :: Ca_max","tags":"","loc":"type/powermodel.html"},{"title":"GCCModel – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: GCCModel Inherited by type~~gccmodel~~InheritedByGraph type~gccmodel GCCModel type~latentheattreatment LatentHeatTreatment type~latentheattreatment->type~gccmodel GCC type~heatfields HeatFields type~heatfields->type~latentheattreatment Latent type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR alpha n m Tf Ca_max Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha real(kind=real64), public :: n real(kind=real64), public :: m real(kind=real64), public :: Tf real(kind=real64), public :: Ca_max","tags":"","loc":"type/gccmodel.html"},{"title":"WRF_Parameters – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: WRF_Parameters Contents Variables thetaS thetaR alpha1 alpha2 n1 n2 m1 m2 hcrit w1 w2 Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2","tags":"","loc":"type/wrf_parameters.html"},{"title":"Base_WRF – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Base_WRF Inherited by type~~base_wrf~~InheritedByGraph type~base_wrf Base_WRF type~type_ice_gcc Type_Ice_GCC type~type_ice_gcc->type~base_wrf WRF type~type_wrf_dvgch Type_WRF_DVGCH type~type_wrf_dvgch->type~base_wrf type~type_wrf_mvg Type_WRF_MVG type~type_wrf_mvg->type~base_wrf type~type_wrf_vg Type_WRF_VG type~type_wrf_vg->type~base_wrf type~type_wrf_bc Type_WRF_BC type~type_wrf_bc->type~base_wrf type~type_wrf_durner Type_WRF_Durner type~type_wrf_durner->type~base_wrf type~type_wrf_ko Type_WRF_KO type~type_wrf_ko->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR","tags":"","loc":"type/base_wrf.html"},{"title":"Type_WRF_BC – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_WRF ) :: Type_WRF_BC Inherits type~~type_wrf_bc~~InheritsGraph type~type_wrf_bc Type_WRF_BC type~base_wrf Base_WRF type~type_wrf_bc->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR alpha1 n1 Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1","tags":"","loc":"type/type_wrf_bc.html"},{"title":"Type_WRF_VG – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_WRF ) :: Type_WRF_VG Inherits type~~type_wrf_vg~~InheritsGraph type~type_wrf_vg Type_WRF_VG type~base_wrf Base_WRF type~type_wrf_vg->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR alpha1 n1 m1 Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1","tags":"","loc":"type/type_wrf_vg.html"},{"title":"Type_WRF_KO – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_WRF ) :: Type_WRF_KO Inherits type~~type_wrf_ko~~InheritsGraph type~type_wrf_ko Type_WRF_KO type~base_wrf Base_WRF type~type_wrf_ko->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR alpha1 n1 Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1","tags":"","loc":"type/type_wrf_ko.html"},{"title":"Type_WRF_MVG – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_WRF ) :: Type_WRF_MVG Inherits type~~type_wrf_mvg~~InheritsGraph type~type_wrf_mvg Type_WRF_MVG type~base_wrf Base_WRF type~type_wrf_mvg->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR alpha1 n1 m1 hcrit Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: hcrit","tags":"","loc":"type/type_wrf_mvg.html"},{"title":"Type_WRF_Durner – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_WRF ) :: Type_WRF_Durner Inherits type~~type_wrf_durner~~InheritsGraph type~type_wrf_durner Type_WRF_Durner type~base_wrf Base_WRF type~type_wrf_durner->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR alpha1 n1 m1 alpha2 n2 m2 w1 w2 Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2","tags":"","loc":"type/type_wrf_durner.html"},{"title":"Type_WRF_DVGCH – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_WRF ) :: Type_WRF_DVGCH Inherits type~~type_wrf_dvgch~~InheritsGraph type~type_wrf_dvgch Type_WRF_DVGCH type~base_wrf Base_WRF type~type_wrf_dvgch->type~base_wrf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR alpha1 n1 m1 n2 m2 w1 w2 Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2","tags":"","loc":"type/type_wrf_dvgch.html"},{"title":"HCF_Parameters – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: HCF_Parameters Inherited by type~~hcf_parameters~~InheritedByGraph type~hcf_parameters HCF_Parameters type~hcf HCF type~hcf->type~hcf_parameters type~heat Heat type~heat->type~hcf HCFs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR alpha1 alpha2 n1 n2 m1 m2 hcrit w1 w2 Ks kzero l Omega Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: Ks real(kind=real64), public :: kzero real(kind=real64), public :: l real(kind=real64), public :: Omega","tags":"","loc":"type/hcf_parameters.html"},{"title":"Base_HCF – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Base_HCF Inherited by type~~base_hcf~~InheritedByGraph type~base_hcf Base_HCF type~base_hydraulic Base_Hydraulic type~base_hydraulic->type~base_hcf HCF type~type_hcf_bc Type_HCF_BC type~type_hcf_bc->type~base_hcf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR","tags":"","loc":"type/base_hcf.html"},{"title":"Type_HCF_BC – Freezing Thawing Dynamics Simulation Solver ","text":"type, public, extends( Base_HCF ) :: Type_HCF_BC Inherits type~~type_hcf_bc~~InheritsGraph type~type_hcf_bc Type_HCF_BC type~base_hcf Base_HCF type~type_hcf_bc->type~base_hcf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables thetaS thetaR alpha1 n1 Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1","tags":"","loc":"type/type_hcf_bc.html"},{"title":"LatentHeatTreatment – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: LatentHeatTreatment Inherits type~~latentheattreatment~~InheritsGraph type~latentheattreatment LatentHeatTreatment type~gccmodel GCCModel type~latentheattreatment->type~gccmodel GCC type~powermodel PowerModel type~latentheattreatment->type~powermodel Power Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~latentheattreatment~~InheritedByGraph type~latentheattreatment LatentHeatTreatment type~heatfields HeatFields type~heatfields->type~latentheattreatment Latent type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables useModel Lf rhoI Cp_unf GCC Power Components Type Visibility Attributes Name Initial integer(kind=int32), public :: useModel real(kind=real64), public :: Lf real(kind=real64), public :: rhoI real(kind=real64), public :: Cp_unf type( GCCModel ), public :: GCC type( PowerModel ), public :: Power","tags":"","loc":"type/latentheattreatment.html"},{"title":"HeatFields – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: HeatFields Inherits type~~heatfields~~InheritsGraph type~heatfields HeatFields type~heatvariables HeatVariables type~heatfields->type~heatvariables Variables type~heatconstants HeatConstants type~heatfields->type~heatconstants Constants type~latentheattreatment LatentHeatTreatment type~heatfields->type~latentheattreatment Latent type~crs CRS type~heatfields->type~crs LHS_A type~df DF type~heatvariables->type~df Cs, Cp, lambda, rho, Ca type~dp2d DP2d type~heatvariables->type~dp2d Tgrad, TFlux type~phases Phases type~heatconstants->type~phases Density, ThermalConductivity, SpecificHeat, HeatCapacity type~vector2d Vector2D type~heatconstants->type~vector2d dispersity type~powermodel PowerModel type~latentheattreatment->type~powermodel Power type~gccmodel GCCModel type~latentheattreatment->type~gccmodel GCC Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~heatfields~~InheritedByGraph type~heatfields HeatFields type~solverinfo SolverInfo type~solverinfo->type~heatfields Heat Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Variables Constants Latent LHS_A RA Rhs Components Type Visibility Attributes Name Initial type( HeatVariables ), public :: Variables type( HeatConstants ), public :: Constants type( LatentHeatTreatment ), public :: Latent type( CRS ), public :: LHS_A real(kind=real64), public, allocatable :: RA (:,:) real(kind=real64), public, allocatable :: Rhs (:)","tags":"","loc":"type/heatfields.html"},{"title":"WaterVariables – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: WaterVariables Inherits type~~watervariables~~InheritsGraph type~watervariables WaterVariables type~df DF type~watervariables->type~df Klh type~dp2d DP2d type~watervariables->type~dp2d wFlux, hGrad Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~watervariables~~InheritedByGraph type~watervariables WaterVariables type~waterfields WaterFields type~waterfields->type~watervariables Variables type~solverinfo SolverInfo type~solverinfo->type~waterfields Water Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Klh wFlux hGrad Components Type Visibility Attributes Name Initial type( DF ), public :: Klh type( DP2d ), public :: wFlux type( DP2d ), public :: hGrad","tags":"","loc":"type/watervariables.html"},{"title":"WaterConstants – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: WaterConstants Inherits type~~waterconstants~~InheritsGraph type~waterconstants WaterConstants type~phases Phases type~waterconstants->type~phases HydraulicConductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~waterconstants~~InheritedByGraph type~waterconstants WaterConstants type~waterfields WaterFields type~waterfields->type~waterconstants Constants type~solverinfo SolverInfo type~solverinfo->type~waterfields Water Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables HydraulicConductivity zeta Components Type Visibility Attributes Name Initial type( Phases ), public :: HydraulicConductivity real(kind=real64), public :: zeta","tags":"","loc":"type/waterconstants.html"},{"title":"WaterFields – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: WaterFields Inherits type~~waterfields~~InheritsGraph type~waterfields WaterFields type~watervariables WaterVariables type~waterfields->type~watervariables Variables type~waterconstants WaterConstants type~waterfields->type~waterconstants Constants type~crs CRS type~waterfields->type~crs LHS_A type~df DF type~watervariables->type~df Klh type~dp2d DP2d type~watervariables->type~dp2d wFlux, hGrad type~phases Phases type~waterconstants->type~phases HydraulicConductivity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~waterfields~~InheritedByGraph type~waterfields WaterFields type~solverinfo SolverInfo type~solverinfo->type~waterfields Water Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Variables Constants LHS_A RA Rhs Components Type Visibility Attributes Name Initial type( WaterVariables ), public :: Variables type( WaterConstants ), public :: Constants type( CRS ), public :: LHS_A real(kind=real64), public, allocatable :: RA (:,:) real(kind=real64), public, allocatable :: Rhs (:)","tags":"","loc":"type/waterfields.html"},{"title":"Geometry2d – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Geometry2d Inherits type~~geometry2d~~InheritsGraph type~geometry2d Geometry2d type~dp2d DP2d type~geometry2d->type~dp2d vCood type~shape Shape type~geometry2d->type~shape Basis Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~geometry2d~~InheritedByGraph type~geometry2d Geometry2d type~solverinfo SolverInfo type~solverinfo->type~geometry2d N Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables element node shape dim ShCoe pElement vCood eArea Basis Components Type Visibility Attributes Name Initial integer(kind=int32), public :: element integer(kind=int32), public :: node integer(kind=int32), public :: shape integer(kind=int32), public :: dim integer(kind=int32), public :: ShCoe integer(kind=int32), public, allocatable :: pElement (:,:) type( DP2d ), public :: vCood real(kind=real64), public, allocatable :: eArea (:) type( Shape ), public :: Basis","tags":"","loc":"type/geometry2d.html"},{"title":"Geometry_2D – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Geometry_2D Inherits type~~geometry_2d~~InheritsGraph type~geometry_2d Geometry_2D type~dp2d DP2d type~geometry_2d->type~dp2d Nodes_2D type~shape Shape type~geometry_2d->type~shape Shape_Function Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~geometry_2d~~InheritedByGraph type~geometry_2d Geometry_2D type~heat Heat type~heat->type~geometry_2d Geometry Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Num_Elements Num_Nodes Num_Shape Num_Dimention Num_Shape_Type Num_Region Element Element_Region COO_Region Nodes_2D Area Shape_Function Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Elements integer(kind=int32), public :: Num_Nodes integer(kind=int32), public :: Num_Shape integer(kind=int32), public :: Num_Dimention integer(kind=int32), public :: Num_Shape_Type integer(kind=int32), public :: Num_Region integer(kind=int32), public, allocatable :: Element (:,:) integer(kind=int32), public, allocatable :: Element_Region (:) integer(kind=int32), public, allocatable :: COO_Region (:) type( DP2d ), public :: Nodes_2D real(kind=real64), public, allocatable :: Area (:) type( Shape ), public :: Shape_Function","tags":"","loc":"type/geometry_2d.html"},{"title":"TimeInfo – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: TimeInfo Inherited by type~~timeinfo~~InheritedByGraph type~timeinfo TimeInfo type~solverinfo SolverInfo type~solverinfo->type~timeinfo Time Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables tUnit cTime cdt cinterval ts te max_dt min_dt tconv tst dt odt Components Type Visibility Attributes Name Initial character(len=3), public :: tUnit real(kind=real64), public :: cTime real(kind=real64), public :: cdt real(kind=real64), public :: cinterval real(kind=real64), public :: ts real(kind=real64), public :: te real(kind=real64), public :: max_dt real(kind=real64), public :: min_dt real(kind=real64), public :: tconv real(kind=real64), public, pointer :: tst real(kind=real64), public, pointer :: dt real(kind=real64), public, pointer :: odt","tags":"","loc":"type/timeinfo.html"},{"title":"Iteration – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: Iteration Inherited by type~~iteration~~InheritedByGraph type~iteration Iteration type~solverinfo SolverInfo type~solverinfo->type~iteration Iter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables itermax iNLmax iNI iter titer iNL digits_itermax Components Type Visibility Attributes Name Initial integer(kind=int32), public :: itermax integer(kind=int32), public :: iNLmax integer(kind=int32), public :: iNI integer(kind=int32), public, pointer :: iter integer(kind=int32), public, pointer :: titer integer(kind=int32), public, pointer :: iNL integer(kind=int32), public :: digits_itermax","tags":"","loc":"type/iteration.html"},{"title":"SolverInfo – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: SolverInfo Inherits type~~solverinfo~~InheritsGraph type~solverinfo SolverInfo type~timeinfo TimeInfo type~solverinfo->type~timeinfo Time type~waterfields WaterFields type~solverinfo->type~waterfields Water type~boudarycondition BoudaryCondition type~solverinfo->type~boudarycondition BC type~lis Lis type~solverinfo->type~lis Lis type~flag Flag type~solverinfo->type~flag Flags type~geometry2d Geometry2d type~solverinfo->type~geometry2d N type~iteration Iteration type~solverinfo->type~iteration Iter type~observation2d Observation2d type~solverinfo->type~observation2d Obs type~heatfields HeatFields type~solverinfo->type~heatfields Heat type~initialcondition InitialCondition type~solverinfo->type~initialcondition IC type~df DF type~solverinfo->type~df mWater, mIce, T, P, Si, Sw type~mpiinfo MPIInfo type~solverinfo->type~mpiinfo MPI type~watervariables WaterVariables type~waterfields->type~watervariables Variables type~waterconstants WaterConstants type~waterfields->type~waterconstants Constants type~crs CRS type~waterfields->type~crs LHS_A type~boudaryconditioninfo BoudaryConditionInfo type~boudarycondition->type~boudaryconditioninfo Heat, Water, Stress type~dp2d DP2d type~geometry2d->type~dp2d vCood type~shape Shape type~geometry2d->type~shape Basis type~observation2d->type~dp2d obsCOO type~heatvariables HeatVariables type~heatfields->type~heatvariables Variables type~latentheattreatment LatentHeatTreatment type~heatfields->type~latentheattreatment Latent type~heatfields->type~crs LHS_A type~heatconstants HeatConstants type~heatfields->type~heatconstants Constants type~initialconditioninfo InitialConditionInfo type~initialcondition->type~initialconditioninfo Heat, Water, Stress type~watervariables->type~df Klh type~watervariables->type~dp2d wFlux, hGrad type~int2d INT2d type~boudaryconditioninfo->type~int2d Edges type~heatvariables->type~df Cs, Cp, lambda, rho, Ca type~heatvariables->type~dp2d Tgrad, TFlux type~powermodel PowerModel type~latentheattreatment->type~powermodel Power type~gccmodel GCCModel type~latentheattreatment->type~gccmodel GCC type~phases Phases type~waterconstants->type~phases HydraulicConductivity type~heatconstants->type~phases Density, ThermalConductivity, SpecificHeat, HeatCapacity type~vector2d Vector2D type~heatconstants->type~vector2d dispersity Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables N isHeat isWater isStress nAnalysis nFrTreat nTimeDisc isStdOut outputFile Time Iter Obs Heat Water BC IC mWater mIce T P Si Sw Lis Flags fmt_Stdout fmt_Fileout MPI Components Type Visibility Attributes Name Initial type( Geometry2d ), public :: N logical, public :: isHeat logical, public :: isWater logical, public :: isStress integer(kind=int32), public :: nAnalysis integer(kind=int32), public :: nFrTreat integer(kind=int32), public :: nTimeDisc integer(kind=int32), public :: isStdOut integer(kind=int32), public :: outputFile type( TimeInfo ), public :: Time type( Iteration ), public :: Iter type( Observation2d ), public :: Obs type( HeatFields ), public :: Heat type( WaterFields ), public :: Water type( BoudaryCondition ), public :: BC type( InitialCondition ), public :: IC type( DF ), public :: mWater type( DF ), public :: mIce type( DF ), public :: T type( DF ), public :: P type( DF ), public :: Si type( DF ), public :: Sw type( Lis ), public :: Lis type( Flag ), public :: Flags character(len=64), public :: fmt_Stdout character(len=64), public :: fmt_Fileout type( MPIInfo ), public :: MPI","tags":"","loc":"type/solverinfo.html"},{"title":"ILS – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: ILS Inherits type~~ils~~InheritsGraph type~ils ILS type~crs CRS type~ils->type~crs CRS_A Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Constructor ILS Finalization Procedures ILS_Destructor Type-Bound Procedures BiCGStab Chkerr Constructor public interface ILS private function Solve_Initialize_BiCGStab(Solver, MCRS) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(in) :: MCRS Return Value type( ILS ) Finalization Procedures final :: ILS_Destructor private subroutine ILS_Destructor(self) Arguments Type Intent Optional Attributes Name type( ILS ) :: self Type-Bound Procedures procedure, public :: BiCGStab => Solver_BiCGStab private subroutine Solver_BiCGStab(self, Solver, BiCG_A, BiCG_b, BiCG_x, status) Arguments Type Intent Optional Attributes Name class( ILS ) :: self type( SolverInfo ), intent(inout) :: Solver type( CRS ), intent(in) :: BiCG_A real(kind=real64), intent(in) :: BiCG_b (:) real(kind=real64), intent(inout) :: BiCG_x (:) integer(kind=int32), intent(inout) :: status procedure, public :: Chkerr => Solver_Check_Error private subroutine Solver_Check_Error(self, ierr, time) Arguments Type Intent Optional Attributes Name class( ILS ) :: self integer(kind=int32), intent(in) :: ierr real(kind=real64), intent(in) :: time","tags":"","loc":"type/ils.html"},{"title":"DLS – Freezing Thawing Dynamics Simulation Solver ","text":"type, public :: DLS Contents Constructor DLS Type-Bound Procedures LU Constructor public interface DLS private function Solve_Initialize_LU(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ) :: Solver Return Value type( DLS ) Type-Bound Procedures procedure, public :: LU => Solver_LU private subroutine Solver_LU(self, LU_A, LU_b, LU_x) solve linear equation Arguments Type Intent Optional Attributes Name class( DLS ) :: self real(kind=real64), intent(inout) :: LU_A (:,:) real(kind=real64), intent(inout) :: LU_b (:) real(kind=real64), intent(inout) :: LU_x (:)","tags":"","loc":"type/dls.html"},{"title":"Calculation_HCF – Freezing Thawing Dynamics Simulation Solver","text":"abstract interface public function Calculation_HCF(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64)","tags":"","loc":"interface/calculation_hcf.html"},{"title":"Calculation_HCF_mu – Freezing Thawing Dynamics Simulation Solver","text":"abstract interface public function Calculation_HCF_mu(T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64)","tags":"","loc":"interface/calculation_hcf_mu.html"},{"title":"Find_CRS_Index – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Find_CRS_Index(A, serch_column, serch_index, index) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A integer(kind=int32), intent(in) :: serch_column integer(kind=int32), intent(in) :: serch_index integer(kind=int32), intent(inout) :: index Called by proc~~find_crs_index~~CalledByGraph proc~find_crs_index Find_CRS_Index proc~find_crs_indexes Find_CRS_Indexes proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_crs_index.html"},{"title":"Find_CRS_Indexes – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Find_CRS_Indexes(lump, A, serch_index1, serch_index2, serch_index3, indexes) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lump type( CRS ), intent(in) :: A integer(kind=int32), intent(in) :: serch_index1 integer(kind=int32), intent(in) :: serch_index2 integer(kind=int32), intent(in) :: serch_index3 integer(kind=int32), intent(inout) :: indexes (:) Calls proc~~find_crs_indexes~~CallsGraph proc~find_crs_indexes Find_CRS_Indexes proc~find_crs_index Find_CRS_Index proc~find_crs_indexes->proc~find_crs_index Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_crs_indexes.html"},{"title":"Init_Assemble – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Init_Assemble(A) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A Calls proc~~init_assemble~~CallsGraph proc~init_assemble Init_Assemble proc~duplicate_crs Duplicate_CRS proc~init_assemble->proc~duplicate_crs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_assemble.html"},{"title":"Assemble_GM_Heat – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Assemble_GM_Heat(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~assemble_gm_heat~~CallsGraph proc~assemble_gm_heat Assemble_GM_Heat proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~assemble_gm_heat->proc~matrix_vector_product_crs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/assemble_gm_heat.html"},{"title":"Assemble_GM_Heat_IC – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Assemble_GM_Heat_IC(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~assemble_gm_heat_ic~~CallsGraph proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~assemble_gm_heat_ic->proc~matrix_vector_product_crs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/assemble_gm_heat_ic.html"},{"title":"Assemble_GM_Water – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Assemble_GM_Water(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~assemble_gm_water~~CallsGraph proc~assemble_gm_water Assemble_GM_Water proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~assemble_gm_water->proc~matrix_vector_product_crs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/assemble_gm_water.html"},{"title":"Assemble_GM_Water_IC – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Assemble_GM_Water_IC(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents None","tags":"","loc":"proc/assemble_gm_water_ic.html"},{"title":"Convert_CRS – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Convert_CRS(Solver, A) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(inout) :: A Calls proc~~convert_crs~~CallsGraph proc~convert_crs Convert_CRS interface~allocate_vector Allocate_Vector proc~convert_crs->interface~allocate_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/convert_crs.html"},{"title":"Heat – Freezing Thawing Dynamics Simulation Solver","text":"public interface Heat Contents Module Procedures Heat_Constructor Module Procedures private function Heat_Constructor(Structure_Input) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Structure_Input Return Value type( Heat )","tags":"","loc":"interface/heat.html"},{"title":"init_omp_config – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine init_omp_config(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~init_omp_config~~CallsGraph proc~init_omp_config init_omp_config omp_set_max_active_levels omp_set_max_active_levels proc~init_omp_config->omp_set_max_active_levels omp_get_num_procs omp_get_num_procs proc~init_omp_config->omp_get_num_procs omp_get_max_threads omp_get_max_threads proc~init_omp_config->omp_get_max_threads Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_omp_config.html"},{"title":"Output – Freezing Thawing Dynamics Simulation Solver","text":"public interface Output Contents Module Procedures Output_Constructor Module Procedures private function Output_Constructor(Inputs) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Inputs Return Value type( Output )","tags":"","loc":"interface/output.html"},{"title":"Inout_SetProjectPath_GetProjectPath – Freezing Thawing Dynamics Simulation Solver","text":"public function Inout_SetProjectPath_GetProjectPath() Arguments None Return Value character(len=256) Contents None","tags":"","loc":"proc/inout_setprojectpath_getprojectpath.html"},{"title":"Calc_Area_31 – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Calc_Area_31(Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry Calls proc~~calc_area_31~~CallsGraph proc~calc_area_31 Calc_Area_31 interface~set_point Set_Point proc~calc_area_31->interface~set_point proc~error_message error_message proc~calc_area_31->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calc_area_31~~CalledByGraph proc~calc_area_31 Calc_Area_31 interface~calc_area Calc_Area interface~calc_area->proc~calc_area_31 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_area_31.html"},{"title":"Calc_Area – Freezing Thawing Dynamics Simulation Solver","text":"public interface Calc_Area Calls interface~~calc_area~~CallsGraph interface~calc_area Calc_Area proc~calc_area_31 Calc_Area_31 interface~calc_area->proc~calc_area_31 interface~set_point Set_Point proc~calc_area_31->interface~set_point proc~error_message error_message proc~calc_area_31->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures Calc_Area_31 Module Procedures public subroutine Calc_Area_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry","tags":"","loc":"interface/calc_area.html"},{"title":"Set_Point – Freezing Thawing Dynamics Simulation Solver","text":"public interface Set_Point Called by interface~~set_point~~CalledByGraph interface~set_point Set_Point proc~calc_area_31 Calc_Area_31 proc~calc_area_31->interface~set_point proc~calc_shape_31 Calc_Shape_31 proc~calc_shape_31->interface~set_point interface~calc_area Calc_Area interface~calc_area->proc~calc_area_31 interface~calc_shape Calc_Shape interface~calc_shape->proc~calc_shape_31 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures Set_Point_31 Module Procedures private subroutine Set_Point_31(Geometry, triangle_index, p1, p2, p3) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(in) :: Geometry integer(kind=int32), intent(in) :: triangle_index type( Vector2D ), intent(inout) :: p1 type( Vector2D ), intent(inout) :: p2 type( Vector2D ), intent(inout) :: p3","tags":"","loc":"interface/set_point.html"},{"title":"HCF_Constructor – Freezing Thawing Dynamics Simulation Solver","text":"public function HCF_Constructor(in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in_HCF_Parameters (:) integer(kind=int32), intent(in) :: HCF_Model_id integer(kind=int32), intent(in) :: Kflh_Model_id Return Value type( HCF ) Called by proc~~hcf_constructor~~CalledByGraph proc~hcf_constructor HCF_Constructor interface~hcf HCF interface~hcf->proc~hcf_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hcf_constructor.html"},{"title":"Calculate_Ks – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_Ks(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name class( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_ks.html"},{"title":"Calculate_HCF_BC – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_HCF_BC(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_hcf_bc.html"},{"title":"Calculate_HCF_VG – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_HCF_VG(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_hcf_vg.html"},{"title":"Calculate_HCF_KO – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_HCF_KO(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_hcf_ko.html"},{"title":"Calculate_HCF_MVG – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_HCF_MVG(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_hcf_mvg.html"},{"title":"Calculate_HCF_Durner – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_HCF_Durner(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_hcf_durner.html"},{"title":"Calculate_HCF_DVGCH – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_HCF_DVGCH(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_hcf_dvgch.html"},{"title":"Calc_HCF_mu_Exponential – Freezing Thawing Dynamics Simulation Solver","text":"public function Calc_HCF_mu_Exponential(T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calc_hcf_mu_exponential.html"},{"title":"Calc_HCF_mu_Exponential_Supercooled – Freezing Thawing Dynamics Simulation Solver","text":"public function Calc_HCF_mu_Exponential_Supercooled(T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calc_hcf_mu_exponential_supercooled.html"},{"title":"HCF – Freezing Thawing Dynamics Simulation Solver","text":"public interface HCF Calls interface~~hcf~~CallsGraph interface~hcf HCF proc~hcf_constructor HCF_Constructor interface~hcf->proc~hcf_constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures HCF_Constructor Module Procedures public function HCF_Constructor (in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in_HCF_Parameters (:) integer(kind=int32), intent(in) :: HCF_Model_id integer(kind=int32), intent(in) :: Kflh_Model_id Return Value type( HCF )","tags":"","loc":"interface/hcf.html"},{"title":"Matrix_Vector_Product_CRS – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Matrix_Vector_Product_CRS(A, x, y) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A real(kind=real64), intent(in) :: x (:) real(kind=real64), intent(inout) :: y (:) Called by proc~~matrix_vector_product_crs~~CalledByGraph proc~matrix_vector_product_crs Matrix_Vector_Product_CRS proc~assemble_gm_heat Assemble_GM_Heat proc~assemble_gm_heat->proc~matrix_vector_product_crs proc~assemble_gm_heat_ic Assemble_GM_Heat_IC proc~assemble_gm_heat_ic->proc~matrix_vector_product_crs proc~assemble_gm_water Assemble_GM_Water proc~assemble_gm_water->proc~matrix_vector_product_crs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/matrix_vector_product_crs.html"},{"title":"Calculate_WRF_BC – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_WRF_BC(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_BC ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_wrf_bc.html"},{"title":"Calculate_WRF_Derivative_BC – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_WRF_Derivative_BC(structure_WRF, h) result(Cw) Arguments Type Intent Optional Attributes Name type( Type_WRF_BC ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_wrf_derivative_bc.html"},{"title":"Calculate_WRF_VG – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_WRF_VG(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_VG ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_wrf_vg.html"},{"title":"Calculate_WRF_KO – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_WRF_KO(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_KO ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_wrf_ko.html"},{"title":"Calculate_WRF_MVG – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_WRF_MVG(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_MVG ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_wrf_mvg.html"},{"title":"Calculate_WRF_Durner – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_WRF_Durner(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_Durner ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_wrf_durner.html"},{"title":"Calculate_WRF_DVGCH – Freezing Thawing Dynamics Simulation Solver","text":"public function Calculate_WRF_DVGCH(structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_DVGCH ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) Contents None","tags":"","loc":"proc/calculate_wrf_dvgch.html"},{"title":"Update_Parameters_Heat – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Update_Parameters_Heat(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~update_parameters_heat~~CallsGraph proc~update_parameters_heat Update_Parameters_Heat proc~update_theta Update_theta proc~update_parameters_heat->proc~update_theta proc~update_gradient Update_Gradient proc~update_parameters_heat->proc~update_gradient Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/update_parameters_heat.html"},{"title":"Update_Parameters_Water – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Update_Parameters_Water(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents None","tags":"","loc":"proc/update_parameters_water.html"},{"title":"Update_theta – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Update_theta(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Called by proc~~update_theta~~CalledByGraph proc~update_theta Update_theta proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_theta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/update_theta.html"},{"title":"Update_Phase_Revise – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Update_Phase_Revise(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~update_phase_revise~~CallsGraph proc~update_phase_revise Update_Phase_Revise proc~binary_finding Binary_finding proc~update_phase_revise->proc~binary_finding proc~calc_latentheatterm Calc_LatentHeatTerm proc~binary_finding->proc~calc_latentheatterm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/update_phase_revise.html"},{"title":"Update_Si – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Update_Si(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents None","tags":"","loc":"proc/update_si.html"},{"title":"Update_Gradient – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Update_Gradient(Solver, ar, Grad) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver real(kind=real64), intent(in) :: ar (:) type( DP2d ), intent(inout) :: Grad Called by proc~~update_gradient~~CalledByGraph proc~update_gradient Update_Gradient proc~update_parameters_heat Update_Parameters_Heat proc~update_parameters_heat->proc~update_gradient Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/update_gradient.html"},{"title":"Count_if_int32 – Freezing Thawing Dynamics Simulation Solver","text":"public function Count_if_int32(array, Condition) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value logical Return Value integer Called by proc~~count_if_int32~~CalledByGraph proc~count_if_int32 Count_if_int32 interface~count_if Count_if interface~count_if->proc~count_if_int32 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/count_if_int32.html"},{"title":"Count_if_int32_Array – Freezing Thawing Dynamics Simulation Solver","text":"public function Count_if_int32_Array(array, Condition, condition_array) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x, condition_array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: condition_array (:) Return Value logical integer, intent(in) :: condition_array (:) Return Value integer Called by proc~~count_if_int32_array~~CalledByGraph proc~count_if_int32_array Count_if_int32_Array interface~count_if Count_if interface~count_if->proc~count_if_int32_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/count_if_int32_array.html"},{"title":"Count_if – Freezing Thawing Dynamics Simulation Solver","text":"public interface Count_if Calls interface~~count_if~~CallsGraph interface~count_if Count_if proc~count_if_int32 Count_if_int32 interface~count_if->proc~count_if_int32 proc~count_if_int32_array Count_if_int32_Array interface~count_if->proc~count_if_int32_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures Count_if_int32 Count_if_int32_Array Module Procedures public function Count_if_int32 (array, Condition) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value logical Return Value integer public function Count_if_int32_Array (array, Condition, condition_array) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x, condition_array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: condition_array (:) Return Value logical integer, intent(in) :: condition_array (:) Return Value integer","tags":"","loc":"interface/count_if.html"},{"title":"TRMethod – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine TRMethod(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents None","tags":"","loc":"proc/trmethod.html"},{"title":"Set_Obs_COO – Freezing Thawing Dynamics Simulation Solver","text":"public interface Set_Obs_COO Contents Module Procedures Set_Obs_COO_31 Module Procedures private subroutine Set_Obs_COO_31(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"interface/set_obs_coo.html"},{"title":"Calc_LatentHeatTerm – Freezing Thawing Dynamics Simulation Solver","text":"public function Calc_LatentHeatTerm(T, Tnew, Latent) result(res) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tnew type( LatentHeatTreatment ), intent(in) :: Latent Return Value real(kind=real64) Called by proc~~calc_latentheatterm~~CalledByGraph proc~calc_latentheatterm Calc_LatentHeatTerm proc~binary_finding Binary_finding proc~binary_finding->proc~calc_latentheatterm proc~secant_method Secant_method proc~secant_method->proc~calc_latentheatterm proc~update_phase_revise Update_Phase_Revise proc~update_phase_revise->proc~binary_finding Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_latentheatterm.html"},{"title":"Find_Ca_max – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Find_Ca_max(Heat) Arguments Type Intent Optional Attributes Name type( HeatFields ), intent(inout) :: Heat Called by proc~~find_ca_max~~CalledByGraph proc~find_ca_max Find_Ca_max proc~initialize_solver Initialize_Solver proc~initialize_solver->proc~find_ca_max Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/find_ca_max.html"},{"title":"Set_Calculate_GCC_Segregation – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Set_Calculate_GCC_Segregation(Segregation_type) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: Segregation_type Contents None","tags":"","loc":"proc/set_calculate_gcc_segregation.html"},{"title":"Calculate_GCC_NonSegregation – Freezing Thawing Dynamics Simulation Solver","text":"public interface Calculate_GCC_NonSegregation Contents Module Procedures Calculate_GCC_NonSegregation_kPa Calculate_GCC_NonSegregation_m Module Procedures private function Calculate_GCC_NonSegregation_kPa(T, Tf, Lf, rhoW) result(Suction_kPa) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW Return Value real(kind=real64) private function Calculate_GCC_NonSegregation_m(T, Tf, Lf) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf Return Value real(kind=real64)","tags":"","loc":"interface/calculate_gcc_nonsegregation.html"},{"title":"Calc_Shape_31 – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Calc_Shape_31(Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry Calls proc~~calc_shape_31~~CallsGraph proc~calc_shape_31 Calc_Shape_31 interface~set_point Set_Point proc~calc_shape_31->interface~set_point proc~error_message error_message proc~calc_shape_31->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~calc_shape_31~~CalledByGraph proc~calc_shape_31 Calc_Shape_31 interface~calc_shape Calc_Shape interface~calc_shape->proc~calc_shape_31 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calc_shape_31.html"},{"title":"Calc_Shape – Freezing Thawing Dynamics Simulation Solver","text":"public interface Calc_Shape Calls interface~~calc_shape~~CallsGraph interface~calc_shape Calc_Shape proc~calc_shape_31 Calc_Shape_31 interface~calc_shape->proc~calc_shape_31 interface~set_point Set_Point proc~calc_shape_31->interface~set_point proc~error_message error_message proc~calc_shape_31->proc~error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures Calc_Shape_31 Module Procedures public subroutine Calc_Shape_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry","tags":"","loc":"interface/calc_shape.html"},{"title":"norm_2 – Freezing Thawing Dynamics Simulation Solver","text":"public function norm_2(N, x) result(norm) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: x (:) Return Value real(kind=real64) Contents None","tags":"","loc":"proc/norm_2.html"},{"title":"ddots – Freezing Thawing Dynamics Simulation Solver","text":"public function ddots(N, x, y) result(dot) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: x (:) real(kind=real64), intent(in) :: y (:) Return Value real(kind=real64) Contents None","tags":"","loc":"proc/ddots.html"},{"title":"ILS – Freezing Thawing Dynamics Simulation Solver","text":"public interface ILS Contents Module Procedures Solve_Initialize_BiCGStab Module Procedures private function Solve_Initialize_BiCGStab(Solver, MCRS) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(in) :: MCRS Return Value type( ILS )","tags":"","loc":"interface/ils.html"},{"title":"DLS – Freezing Thawing Dynamics Simulation Solver","text":"public interface DLS Contents Module Procedures Solve_Initialize_LU Module Procedures private function Solve_Initialize_LU(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ) :: Solver Return Value type( DLS )","tags":"","loc":"interface/dls.html"},{"title":"error_message – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine error_message(err_number, myrank, opt, opt_file_name, copt1, copt2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: err_number integer(kind=int32), intent(in), optional :: myrank real(kind=real64), intent(in), optional :: opt character, intent(in), optional :: opt_file_name character, intent(in), optional :: copt1 character, intent(in), optional :: copt2 Calls proc~~error_message~~CallsGraph proc~error_message error_message mpi_finalize mpi_finalize proc~error_message->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~error_message~~CalledByGraph proc~error_message error_message proc~calc_area_31 Calc_Area_31 proc~calc_area_31->proc~error_message proc~calc_shape_31 Calc_Shape_31 proc~calc_shape_31->proc~error_message interface~calc_area Calc_Area interface~calc_area->proc~calc_area_31 interface~calc_shape Calc_Shape interface~calc_shape->proc~calc_shape_31 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/error_message.html"},{"title":"has_nan – Freezing Thawing Dynamics Simulation Solver","text":"public interface has_nan Contents Module Procedures has_nan_real64_scalar has_nan_real64_rank1 has_nan_real64_rank2 Module Procedures private function has_nan_real64_scalar(scalar) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar Return Value logical private function has_nan_real64_rank1(array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Return Value logical private function has_nan_real64_rank2(array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:,:) Return Value logical","tags":"","loc":"interface/has_nan.html"},{"title":"value_in_range – Freezing Thawing Dynamics Simulation Solver","text":"public interface value_in_range Contents Module Procedures value_in_range_int32 value_in_range_real64 Module Procedures private function value_in_range_int32(value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max Return Value logical private function value_in_range_real64(value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: value real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max Return Value logical","tags":"","loc":"interface/value_in_range.html"},{"title":"Create_Precond_Jacobi – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Create_Precond_Jacobi(N, A, M) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N type( CRS ), intent(in) :: A real(kind=real64), intent(inout) :: M (:) Contents None","tags":"","loc":"proc/create_precond_jacobi.html"},{"title":"Apply_Precond_Jacobi – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Apply_Precond_Jacobi(N, M, r, z) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: M (:) real(kind=real64), intent(in) :: r (:) real(kind=real64), intent(inout) :: z (:) Contents None","tags":"","loc":"proc/apply_precond_jacobi.html"},{"title":"Init_Copy_Temperature – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Init_Copy_Temperature(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents None","tags":"","loc":"proc/init_copy_temperature.html"},{"title":"Init_Copy_Pressure – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Init_Copy_Pressure(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents None","tags":"","loc":"proc/init_copy_pressure.html"},{"title":"Initialize_Solver – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Initialize_Solver(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Calls proc~~initialize_solver~~CallsGraph proc~initialize_solver Initialize_Solver interface~allocate_pointer Allocate_Pointer proc~initialize_solver->interface~allocate_pointer proc~find_ca_max Find_Ca_max proc~initialize_solver->proc~find_ca_max Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/initialize_solver.html"},{"title":"Binary_finding – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Binary_finding(Solver, ind) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: ind Calls proc~~binary_finding~~CallsGraph proc~binary_finding Binary_finding proc~calc_latentheatterm Calc_LatentHeatTerm proc~binary_finding->proc~calc_latentheatterm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~binary_finding~~CalledByGraph proc~binary_finding Binary_finding proc~update_phase_revise Update_Phase_Revise proc~update_phase_revise->proc~binary_finding Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/binary_finding.html"},{"title":"Secant_method – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Secant_method(Solver, ind) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: ind Calls proc~~secant_method~~CallsGraph proc~secant_method Secant_method proc~calc_latentheatterm Calc_LatentHeatTerm proc~secant_method->proc~calc_latentheatterm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/secant_method.html"},{"title":"Allocate_DF – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Allocate_DF(ar_DF, n) Arguments Type Intent Optional Attributes Name type( DF ), intent(inout) :: ar_DF integer(kind=int32), intent(in) :: n Calls proc~~allocate_df~~CallsGraph proc~allocate_df Allocate_DF interface~allocate_vector Allocate_Vector proc~allocate_df->interface~allocate_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~allocate_df~~CalledByGraph proc~allocate_df Allocate_DF proc~allocate_solver Allocate_Solver proc~allocate_solver->proc~allocate_df Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_df.html"},{"title":"Allocate_DP2d – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Allocate_DP2d(ar_DP2d, n) Arguments Type Intent Optional Attributes Name type( DP2d ), intent(inout) :: ar_DP2d integer(kind=int32), intent(in) :: n Calls proc~~allocate_dp2d~~CallsGraph proc~allocate_dp2d Allocate_DP2d interface~allocate_vector Allocate_Vector proc~allocate_dp2d->interface~allocate_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~allocate_dp2d~~CalledByGraph proc~allocate_dp2d Allocate_DP2d proc~allocate_solver Allocate_Solver proc~allocate_solver->proc~allocate_dp2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_dp2d.html"},{"title":"Allocate_BCinfo – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Allocate_BCinfo(BCinfo, nNode, nType, nEdge) Arguments Type Intent Optional Attributes Name type( BoudaryConditionInfo ), intent(inout) :: BCinfo integer(kind=int32), intent(in) :: nNode integer(kind=int32), intent(in) :: nType integer(kind=int32), intent(in), optional :: nEdge Calls proc~~allocate_bcinfo~~CallsGraph proc~allocate_bcinfo Allocate_BCinfo interface~allocate_vector Allocate_Vector proc~allocate_bcinfo->interface~allocate_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_bcinfo.html"},{"title":"Allocate_Solver – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Allocate_Solver(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Allocate Geometry2d Calls proc~~allocate_solver~~CallsGraph proc~allocate_solver Allocate_Solver interface~allocate_matrix Allocate_Matrix proc~allocate_solver->interface~allocate_matrix interface~allocate_vector Allocate_Vector proc~allocate_solver->interface~allocate_vector proc~allocate_df Allocate_DF proc~allocate_solver->proc~allocate_df proc~allocate_dp2d Allocate_DP2d proc~allocate_solver->proc~allocate_dp2d proc~allocate_df->interface~allocate_vector proc~allocate_dp2d->interface~allocate_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_solver.html"},{"title":"Allocate_Structure_Thermal_Type – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Allocate_Structure_Thermal_Type(Structure_Thermal, Flags) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal type( Type_Region_Flags ), intent(in) :: Flags Contents None","tags":"","loc":"proc/allocate_structure_thermal_type.html"},{"title":"Allocate_Structure_Ice_Type – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Allocate_Structure_Ice_Type(Structure_Thermal, QiceModelType) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal integer(kind=int32), intent(in) :: QiceModelType Contents None","tags":"","loc":"proc/allocate_structure_ice_type.html"},{"title":"Allocate_Structure_WRF_Type – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Allocate_Structure_WRF_Type(Structure_Thermal, WRFModelType) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal integer(kind=int32), intent(in) :: WRFModelType Contents None","tags":"","loc":"proc/allocate_structure_wrf_type.html"},{"title":"Duplicate_CRS – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Duplicate_CRS(A, B) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A type( CRS ), intent(inout) :: B Called by proc~~duplicate_crs~~CalledByGraph proc~duplicate_crs Duplicate_CRS proc~init_assemble Init_Assemble proc~init_assemble->proc~duplicate_crs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/duplicate_crs.html"},{"title":"Allocate_Vector – Freezing Thawing Dynamics Simulation Solver","text":"public interface Allocate_Vector Called by interface~~allocate_vector~~CalledByGraph interface~allocate_vector Allocate_Vector proc~convert_crs Convert_CRS proc~convert_crs->interface~allocate_vector proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_vector proc~allocate_dp2d Allocate_DP2d proc~allocate_solver->proc~allocate_dp2d proc~allocate_df Allocate_DF proc~allocate_solver->proc~allocate_df proc~allocate_dp2d->interface~allocate_vector proc~allocate_df->interface~allocate_vector proc~allocate_bcinfo Allocate_BCinfo proc~allocate_bcinfo->interface~allocate_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures Check_Allocate_rank1_int32 Check_Allocate_rank1_real64 Check_Allocate_rank1_logical Check_Allocate_rank1_int32_specify Check_Allocate_rank1_real64_specify Module Procedures private subroutine Check_Allocate_rank1_int32(iar, ar_size) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_real64(dar, ar_size) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_logical(lar, ar_size) Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: lar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_int32_specify(iar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last private subroutine Check_Allocate_rank1_real64_specify(dar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last","tags":"","loc":"interface/allocate_vector.html"},{"title":"Allocate_Matrix – Freezing Thawing Dynamics Simulation Solver","text":"public interface Allocate_Matrix Called by interface~~allocate_matrix~~CalledByGraph interface~allocate_matrix Allocate_Matrix proc~allocate_solver Allocate_Solver proc~allocate_solver->interface~allocate_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures Check_Allocate_rank2_int32 Check_Allocate_rank2_real64 Module Procedures private subroutine Check_Allocate_rank2_int32(imt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: imt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2 private subroutine Check_Allocate_rank2_real64(dmt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dmt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2","tags":"","loc":"interface/allocate_matrix.html"},{"title":"Allocate_Pointer – Freezing Thawing Dynamics Simulation Solver","text":"public interface Allocate_Pointer Called by interface~~allocate_pointer~~CalledByGraph interface~allocate_pointer Allocate_Pointer proc~initialize_solver Initialize_Solver proc~initialize_solver->interface~allocate_pointer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures Check_Allocate_Pointer_real64 Check_Allocate_Pointer_int32 Module Procedures private subroutine Check_Allocate_Pointer_real64(dptr) Arguments Type Intent Optional Attributes Name real(kind=real64), pointer :: dptr private subroutine Check_Allocate_Pointer_int32(iptr) Arguments Type Intent Optional Attributes Name integer(kind=int32), pointer :: iptr","tags":"","loc":"interface/allocate_pointer.html"},{"title":"Fix_InitialCondition – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Fix_InitialCondition(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Contents None","tags":"","loc":"proc/fix_initialcondition.html"},{"title":"Fix_BoundaryConditions – Freezing Thawing Dynamics Simulation Solver","text":"public subroutine Fix_BoundaryConditions(Solver, inTarget) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: inTarget Contents None","tags":"","loc":"proc/fix_boundaryconditions.html"},{"title":"Matrix_FindInd – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types module~~matrix_findind~~UsesGraph module~matrix_findind Matrix_FindInd iso_fortran_env iso_fortran_env module~matrix_findind->iso_fortran_env module~types Types module~matrix_findind->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~matrix_findind~~UsedByGraph module~matrix_findind Matrix_FindInd module~matrix_assemble Matrix_Assemble module~matrix_assemble->module~matrix_findind module~condition_fixboundarycondition Condition_FixBoundaryCondition module~condition_fixboundarycondition->module~matrix_findind module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~matrix_assemble module~condition_fixinitialcondition->module~condition_fixboundarycondition Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Find_CRS_Index Find_CRS_Indexes Subroutines public subroutine Find_CRS_Index (A, serch_column, serch_index, index) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A integer(kind=int32), intent(in) :: serch_column integer(kind=int32), intent(in) :: serch_index integer(kind=int32), intent(inout) :: index public subroutine Find_CRS_Indexes (lump, A, serch_index1, serch_index2, serch_index3, indexes) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: lump type( CRS ), intent(in) :: A integer(kind=int32), intent(in) :: serch_index1 integer(kind=int32), intent(in) :: serch_index2 integer(kind=int32), intent(in) :: serch_index3 integer(kind=int32), intent(inout) :: indexes (:)","tags":"","loc":"module/matrix_findind.html"},{"title":"Matrix_Assemble – Freezing Thawing Dynamics Simulation Solver","text":"時間項の要素行列を全体CRS行列に組み込むサブルーチン\n拡散項の要素行列を全体CRS行列に組み込むサブルーチン\n拡散・移流項の要素行列を全体CRS行列に組み込むサブルーチン Uses Allocate Calculate_Product Matrix_FindInd Allocate_Structure iso_fortran_env error Types omp_lib module~~matrix_assemble~~UsesGraph module~matrix_assemble Matrix_Assemble module~allocate_structure Allocate_Structure module~matrix_assemble->module~allocate_structure module~error error module~matrix_assemble->module~error iso_fortran_env iso_fortran_env module~matrix_assemble->iso_fortran_env module~calculate_product Calculate_Product module~matrix_assemble->module~calculate_product module~allocate Allocate module~matrix_assemble->module~allocate module~matrix_findind Matrix_FindInd module~matrix_assemble->module~matrix_findind module~types Types module~matrix_assemble->module~types omp_lib omp_lib module~matrix_assemble->omp_lib module~allocate_structure->module~error module~allocate_structure->iso_fortran_env module~allocate_structure->module~allocate module~allocate_structure->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~calculate_product->iso_fortran_env module~calculate_product->module~types module~calculate_product->omp_lib module~allocate->module~error module~allocate->iso_fortran_env module~allocate->module~types module~matrix_findind->iso_fortran_env module~matrix_findind->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~matrix_assemble~~UsedByGraph module~matrix_assemble Matrix_Assemble module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~matrix_assemble Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Init_Assemble Assemble_GM_Heat Assemble_GM_Heat_IC Assemble_GM_Water Assemble_GM_Water_IC Subroutines public subroutine Init_Assemble (A) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A public subroutine Assemble_GM_Heat (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Assemble_GM_Heat_IC (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Assemble_GM_Water (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Assemble_GM_Water_IC (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/matrix_assemble.html"},{"title":"Matrix_ConvertCRS – Freezing Thawing Dynamics Simulation Solver","text":"Uses Allocate iso_fortran_env Types module~~matrix_convertcrs~~UsesGraph module~matrix_convertcrs Matrix_ConvertCRS module~allocate Allocate module~matrix_convertcrs->module~allocate iso_fortran_env iso_fortran_env module~matrix_convertcrs->iso_fortran_env module~types Types module~matrix_convertcrs->module~types module~allocate->iso_fortran_env module~allocate->module~types module~error error module~allocate->module~error module~types->iso_fortran_env module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Convert_CRS Subroutines public subroutine Convert_CRS (Solver, A) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(inout) :: A","tags":"","loc":"module/matrix_convertcrs.html"},{"title":"Main_Heat – Freezing Thawing Dynamics Simulation Solver","text":"Uses Allocate Inout_Input iso_fortran_env Allocate_Structure Calculate_HCF Types module~~main_heat~~UsesGraph module~main_heat Main_Heat module~allocate_structure Allocate_Structure module~main_heat->module~allocate_structure iso_fortran_env iso_fortran_env module~main_heat->iso_fortran_env module~calculate_hcf Calculate_HCF module~main_heat->module~calculate_hcf module~allocate Allocate module~main_heat->module~allocate Inout_Input Inout_Input module~main_heat->Inout_Input module~types Types module~main_heat->module~types module~allocate_structure->iso_fortran_env module~allocate_structure->module~allocate module~allocate_structure->module~types module~error error module~allocate_structure->module~error module~calculate_hcf->iso_fortran_env module~calculate_hcf->module~types module~allocate->iso_fortran_env module~allocate->module~types module~allocate->module~error module~types->iso_fortran_env module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces Heat Derived Types Heat Interfaces public interface Heat private function Heat_Constructor(Structure_Input) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Structure_Input Return Value type( Heat ) Derived Types type, public :: Heat Constructor private  function Heat_Constructor (Structure_Input)","tags":"","loc":"module/main_heat.html"},{"title":"Inout_Stdout – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types omp_lib module~~inout_stdout~~UsesGraph module~inout_stdout Inout_Stdout iso_fortran_env iso_fortran_env module~inout_stdout->iso_fortran_env module~types Types module~inout_stdout->module~types omp_lib omp_lib module~inout_stdout->omp_lib module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines init_omp_config Subroutines public subroutine init_omp_config (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/inout_stdout.html"},{"title":"Inout_Output – Freezing Thawing Dynamics Simulation Solver","text":"Uses Allocate Inout_Input Inout_SetProjectPath iso_fortran_env error Types module~~inout_output~~UsesGraph module~inout_output Inout_Output module~error error module~inout_output->module~error iso_fortran_env iso_fortran_env module~inout_output->iso_fortran_env module~allocate Allocate module~inout_output->module~allocate module~inout_setprojectpath Inout_SetProjectPath module~inout_output->module~inout_setprojectpath Inout_Input Inout_Input module~inout_output->Inout_Input module~types Types module~inout_output->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~allocate->module~error module~allocate->iso_fortran_env module~allocate->module~types module~inout_setprojectpath->module~error module~inout_setprojectpath->iso_fortran_env module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces Output Derived Types Output Interfaces public interface Output private function Output_Constructor(Inputs) Arguments Type Intent Optional Attributes Name type(Input), intent(in) :: Inputs Return Value type( Output ) Derived Types type, public :: Output Constructor private  function Output_Constructor (Inputs) Type-Bound Procedures procedure, public :: Output_All => Inout_Output_All procedure, public :: Output_Observation => Inout_Output_Observation","tags":"","loc":"module/inout_output.html"},{"title":"Inout_SetProjectPath – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env error module~~inout_setprojectpath~~UsesGraph module~inout_setprojectpath Inout_SetProjectPath iso_fortran_env iso_fortran_env module~inout_setprojectpath->iso_fortran_env module~error error module~inout_setprojectpath->module~error module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~inout_setprojectpath~~UsedByGraph module~inout_setprojectpath Inout_SetProjectPath module~inout_output Inout_Output module~inout_output->module~inout_setprojectpath Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions Inout_SetProjectPath_GetProjectPath Functions public function Inout_SetProjectPath_GetProjectPath () Arguments None Return Value character(len=256)","tags":"","loc":"module/inout_setprojectpath.html"},{"title":"Calculate_Area – Freezing Thawing Dynamics Simulation Solver","text":"Uses Calculate_Points iso_fortran_env Types error module~~calculate_area~~UsesGraph module~calculate_area Calculate_Area module~calculate_points Calculate_Points module~calculate_area->module~calculate_points module~error error module~calculate_area->module~error iso_fortran_env iso_fortran_env module~calculate_area->iso_fortran_env module~types Types module~calculate_area->module~types module~calculate_points->module~error module~calculate_points->iso_fortran_env module~calculate_points->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces Calc_Area Subroutines Calc_Area_31 Interfaces public interface Calc_Area public subroutine Calc_Area_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry Subroutines public subroutine Calc_Area_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry","tags":"","loc":"module/calculate_area.html"},{"title":"Calculate_Points – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types error module~~calculate_points~~UsesGraph module~calculate_points Calculate_Points iso_fortran_env iso_fortran_env module~calculate_points->iso_fortran_env module~error error module~calculate_points->module~error module~types Types module~calculate_points->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~calculate_points~~UsedByGraph module~calculate_points Calculate_Points module~calculate_area Calculate_Area module~calculate_area->module~calculate_points module~calculate_observation Calculate_Observation module~calculate_observation->module~calculate_points module~calculate_shape Calculate_Shape module~calculate_shape->module~calculate_points Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces Set_Point Interfaces public interface Set_Point private subroutine Set_Point_31(Geometry, triangle_index, p1, p2, p3) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(in) :: Geometry integer(kind=int32), intent(in) :: triangle_index type( Vector2D ), intent(inout) :: p1 type( Vector2D ), intent(inout) :: p2 type( Vector2D ), intent(inout) :: p3","tags":"","loc":"module/calculate_points.html"},{"title":"Calculate_HCF – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types module~~calculate_hcf~~UsesGraph module~calculate_hcf Calculate_HCF iso_fortran_env iso_fortran_env module~calculate_hcf->iso_fortran_env module~types Types module~calculate_hcf->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~calculate_hcf~~UsedByGraph module~calculate_hcf Calculate_HCF module~main_heat Main_Heat module~main_heat->module~calculate_hcf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces HCF Abstract Interfaces Calculation_HCF Calculation_HCF_mu Derived Types HCF Functions HCF_Constructor Calculate_Ks Calculate_HCF_BC Calculate_HCF_VG Calculate_HCF_KO Calculate_HCF_MVG Calculate_HCF_Durner Calculate_HCF_DVGCH Calc_HCF_mu_Exponential Calc_HCF_mu_Exponential_Supercooled Interfaces public interface HCF public function HCF_Constructor (in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in_HCF_Parameters (:) integer(kind=int32), intent(in) :: HCF_Model_id integer(kind=int32), intent(in) :: Kflh_Model_id Return Value type( HCF ) Abstract Interfaces abstract interface public function Calculation_HCF(Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) abstract interface public function Calculation_HCF_mu(T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64) Derived Types type, public, extends( HCF_Parameters ) :: HCF Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: Ks real(kind=real64), public :: kzero real(kind=real64), public :: l real(kind=real64), public :: Omega procedure( Calculation_HCF ), public, pointer, nopass :: Calculate_HCF => null() procedure( Calculation_HCF_mu ), public, pointer, nopass :: Calculate_HCF_mu => null() Constructor public  function HCF_Constructor (in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Type-Bound Procedures procedure, public :: Calculate_Kflh => Calculate_Ks Functions public function HCF_Constructor (in_HCF_Parameters, HCF_Model_id, Kflh_Model_id) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: in_HCF_Parameters (:) integer(kind=int32), intent(in) :: HCF_Model_id integer(kind=int32), intent(in) :: Kflh_Model_id Return Value type( HCF ) public function Calculate_Ks (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name class( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_BC (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_VG (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_KO (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_MVG (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_Durner (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_HCF_DVGCH (Instance_HCF, h) result(kr) Arguments Type Intent Optional Attributes Name type( HCF ), intent(in) :: Instance_HCF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calc_HCF_mu_Exponential (T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64) public function Calc_HCF_mu_Exponential_Supercooled (T) result(mu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T Return Value real(kind=real64)","tags":"","loc":"module/calculate_hcf.html"},{"title":"Calculate_Product – Freezing Thawing Dynamics Simulation Solver","text":"行列ベクトル積を計算するサブルーチン Uses iso_fortran_env Types omp_lib module~~calculate_product~~UsesGraph module~calculate_product Calculate_Product iso_fortran_env iso_fortran_env module~calculate_product->iso_fortran_env module~types Types module~calculate_product->module~types omp_lib omp_lib module~calculate_product->omp_lib module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~calculate_product~~UsedByGraph module~calculate_product Calculate_Product module~matrix_assemble Matrix_Assemble module~matrix_assemble->module~calculate_product module~solver_solve Solver_Solve module~solver_solve->module~calculate_product module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~matrix_assemble module~condition_fixinitialcondition->module~solver_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Matrix_Vector_Product_CRS Subroutines public subroutine Matrix_Vector_Product_CRS (A, x, y) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A real(kind=real64), intent(in) :: x (:) real(kind=real64), intent(inout) :: y (:)","tags":"","loc":"module/calculate_product.html"},{"title":"Calculate_WRF – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types module~~calculate_wrf~~UsesGraph module~calculate_wrf Calculate_WRF iso_fortran_env iso_fortran_env module~calculate_wrf->iso_fortran_env module~types Types module~calculate_wrf->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions Calculate_WRF_BC Calculate_WRF_Derivative_BC Calculate_WRF_VG Calculate_WRF_KO Calculate_WRF_MVG Calculate_WRF_Durner Calculate_WRF_DVGCH Functions public function Calculate_WRF_BC (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_BC ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_Derivative_BC (structure_WRF, h) result(Cw) Arguments Type Intent Optional Attributes Name type( Type_WRF_BC ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_VG (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_VG ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_KO (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_KO ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_MVG (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_MVG ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_Durner (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_Durner ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64) public function Calculate_WRF_DVGCH (structure_WRF, h) result(thetaW) Arguments Type Intent Optional Attributes Name type( Type_WRF_DVGCH ), intent(in) :: structure_WRF real(kind=real64), intent(in) :: h Return Value real(kind=real64)","tags":"","loc":"module/calculate_wrf.html"},{"title":"Calculate_Update – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env RootFinding_BinaryFinding RootFinding_SecantMethod Types omp_lib module~~calculate_update~~UsesGraph module~calculate_update Calculate_Update iso_fortran_env iso_fortran_env module~calculate_update->iso_fortran_env module~rootfinding_binaryfinding RootFinding_BinaryFinding module~calculate_update->module~rootfinding_binaryfinding module~rootfinding_secantmethod RootFinding_SecantMethod module~calculate_update->module~rootfinding_secantmethod module~types Types module~calculate_update->module~types omp_lib omp_lib module~calculate_update->omp_lib module~rootfinding_binaryfinding->iso_fortran_env module~rootfinding_binaryfinding->module~types module~calculate_latentheat Calculate_LatentHeat module~rootfinding_binaryfinding->module~calculate_latentheat ieee_arithmetic ieee_arithmetic module~rootfinding_binaryfinding->ieee_arithmetic module~rootfinding_secantmethod->iso_fortran_env module~rootfinding_secantmethod->module~types module~rootfinding_secantmethod->module~calculate_latentheat module~rootfinding_secantmethod->ieee_arithmetic module~types->iso_fortran_env module~calculate_latentheat->iso_fortran_env module~calculate_latentheat->module~types module~calculate_latentheat->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~calculate_update~~UsedByGraph module~calculate_update Calculate_Update module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~calculate_update Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Update_Parameters_Heat Update_Parameters_Water Update_theta Update_Phase_Revise Update_Si Update_Gradient Subroutines public subroutine Update_Parameters_Heat (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Update_Parameters_Water (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Update_theta (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Update_Phase_Revise (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Update_Si (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Update_Gradient (Solver, ar, Grad) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver real(kind=real64), intent(in) :: ar (:) type( DP2d ), intent(inout) :: Grad","tags":"","loc":"module/calculate_update.html"},{"title":"Calculate_Count – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types error module~~calculate_count~~UsesGraph module~calculate_count Calculate_Count iso_fortran_env iso_fortran_env module~calculate_count->iso_fortran_env module~error error module~calculate_count->module~error module~types Types module~calculate_count->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces Count_if Functions Count_if_int32 Count_if_int32_Array Interfaces public interface Count_if public function Count_if_int32 (array, Condition) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value logical Return Value integer public function Count_if_int32_Array (array, Condition, condition_array) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x, condition_array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: condition_array (:) Return Value logical integer, intent(in) :: condition_array (:) Return Value integer Functions public function Count_if_int32 (array, Condition) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value logical Return Value integer public function Count_if_int32_Array (array, Condition, condition_array) result(count) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) public function Condition(x, condition_array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: condition_array (:) Return Value logical integer, intent(in) :: condition_array (:) Return Value integer","tags":"","loc":"module/calculate_count.html"},{"title":"Calculate_TRM – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types omp_lib module~~calculate_trm~~UsesGraph module~calculate_trm Calculate_TRM iso_fortran_env iso_fortran_env module~calculate_trm->iso_fortran_env module~types Types module~calculate_trm->module~types omp_lib omp_lib module~calculate_trm->omp_lib module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines TRMethod Subroutines public subroutine TRMethod (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/calculate_trm.html"},{"title":"Calculate_Observation – Freezing Thawing Dynamics Simulation Solver","text":"Uses Allocate iso_fortran_env Types Calculate_Points module~~calculate_observation~~UsesGraph module~calculate_observation Calculate_Observation module~allocate Allocate module~calculate_observation->module~allocate module~types Types module~calculate_observation->module~types iso_fortran_env iso_fortran_env module~calculate_observation->iso_fortran_env module~calculate_points Calculate_Points module~calculate_observation->module~calculate_points module~allocate->module~types module~allocate->iso_fortran_env module~error error module~allocate->module~error module~types->iso_fortran_env module~calculate_points->module~types module~calculate_points->iso_fortran_env module~calculate_points->module~error module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces Set_Obs_COO Interfaces public interface Set_Obs_COO private subroutine Set_Obs_COO_31(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/calculate_observation.html"},{"title":"Calculate_LatentHeat – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types omp_lib module~~calculate_latentheat~~UsesGraph module~calculate_latentheat Calculate_LatentHeat iso_fortran_env iso_fortran_env module~calculate_latentheat->iso_fortran_env module~types Types module~calculate_latentheat->module~types omp_lib omp_lib module~calculate_latentheat->omp_lib module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~calculate_latentheat~~UsedByGraph module~calculate_latentheat Calculate_LatentHeat module~rootfinding_binaryfinding RootFinding_BinaryFinding module~rootfinding_binaryfinding->module~calculate_latentheat module~solver_initialize Solver_Initialize module~solver_initialize->module~calculate_latentheat module~rootfinding_secantmethod RootFinding_SecantMethod module~rootfinding_secantmethod->module~calculate_latentheat module~calculate_update Calculate_Update module~calculate_update->module~rootfinding_binaryfinding module~calculate_update->module~rootfinding_secantmethod module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~calculate_update Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions Calc_LatentHeatTerm Subroutines Find_Ca_max Functions public function Calc_LatentHeatTerm (T, Tnew, Latent) result(res) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tnew type( LatentHeatTreatment ), intent(in) :: Latent Return Value real(kind=real64) Subroutines public subroutine Find_Ca_max (Heat) Arguments Type Intent Optional Attributes Name type( HeatFields ), intent(inout) :: Heat","tags":"","loc":"module/calculate_latentheat.html"},{"title":"Calculate_GCC – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env module~~calculate_gcc~~UsesGraph module~calculate_gcc Calculate_GCC iso_fortran_env iso_fortran_env module~calculate_gcc->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables Calculate_GCC_Segregation Interfaces Calculate_GCC_NonSegregation Subroutines Set_Calculate_GCC_Segregation Variables Type Visibility Attributes Name Initial procedure(Calculate_GCC_Segregation_interface), public, pointer :: Calculate_GCC_Segregation => null() Interfaces public interface Calculate_GCC_NonSegregation private function Calculate_GCC_NonSegregation_kPa(T, Tf, Lf, rhoW) result(Suction_kPa) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf real(kind=real64), intent(in) :: rhoW Return Value real(kind=real64) private function Calculate_GCC_NonSegregation_m(T, Tf, Lf) result(Suction_m) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T real(kind=real64), intent(in) :: Tf real(kind=real64), intent(in) :: Lf Return Value real(kind=real64) Subroutines public subroutine Set_Calculate_GCC_Segregation (Segregation_type) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: Segregation_type","tags":"","loc":"module/calculate_gcc.html"},{"title":"Calculate_Shape – Freezing Thawing Dynamics Simulation Solver","text":"Uses Calculate_Points iso_fortran_env Types error module~~calculate_shape~~UsesGraph module~calculate_shape Calculate_Shape module~calculate_points Calculate_Points module~calculate_shape->module~calculate_points module~error error module~calculate_shape->module~error iso_fortran_env iso_fortran_env module~calculate_shape->iso_fortran_env module~types Types module~calculate_shape->module~types module~calculate_points->module~error module~calculate_points->iso_fortran_env module~calculate_points->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces Calc_Shape Subroutines Calc_Shape_31 Interfaces public interface Calc_Shape public subroutine Calc_Shape_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry Subroutines public subroutine Calc_Shape_31 (Geometry) Arguments Type Intent Optional Attributes Name type( Geometry2d ), intent(inout) :: Geometry","tags":"","loc":"module/calculate_shape.html"},{"title":"Calculate_BLAS – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types omp_lib module~~calculate_blas~~UsesGraph module~calculate_blas Calculate_BLAS iso_fortran_env iso_fortran_env module~calculate_blas->iso_fortran_env module~types Types module~calculate_blas->module~types omp_lib omp_lib module~calculate_blas->omp_lib module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~calculate_blas~~UsedByGraph module~calculate_blas Calculate_BLAS module~solver_solve Solver_Solve module~solver_solve->module~calculate_blas module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~solver_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions norm_2 ddots Functions public function norm_2 (N, x) result(norm) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: x (:) Return Value real(kind=real64) public function ddots (N, x, y) result(dot) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: x (:) real(kind=real64), intent(in) :: y (:) Return Value real(kind=real64)","tags":"","loc":"module/calculate_blas.html"},{"title":"Types – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env module~~types~~UsesGraph module~types Types iso_fortran_env iso_fortran_env module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~types~~UsedByGraph module~types Types module~allocate_structure Allocate_Structure module~allocate_structure->module~types module~allocate Allocate module~allocate_structure->module~allocate module~calculate_trm Calculate_TRM module~calculate_trm->module~types module~calculate_area Calculate_Area module~calculate_area->module~types module~calculate_points Calculate_Points module~calculate_area->module~calculate_points module~solver_initialize Solver_Initialize module~solver_initialize->module~types module~solver_initialize->module~allocate module~calculate_latentheat Calculate_LatentHeat module~solver_initialize->module~calculate_latentheat module~allocate->module~types module~calculate_update Calculate_Update module~calculate_update->module~types module~rootfinding_secantmethod RootFinding_SecantMethod module~calculate_update->module~rootfinding_secantmethod module~rootfinding_binaryfinding RootFinding_BinaryFinding module~calculate_update->module~rootfinding_binaryfinding module~calculate_shape Calculate_Shape module~calculate_shape->module~types module~calculate_shape->module~calculate_points module~calculate_product Calculate_Product module~calculate_product->module~types module~inout_output Inout_Output module~inout_output->module~types module~inout_output->module~allocate module~rootfinding_secantmethod->module~types module~rootfinding_secantmethod->module~calculate_latentheat module~solver_precon_jacobi Solver_Precon_jacobi module~solver_precon_jacobi->module~types module~matrix_convertcrs Matrix_ConvertCRS module~matrix_convertcrs->module~types module~matrix_convertcrs->module~allocate module~calculate_points->module~types module~calculate_observation Calculate_Observation module~calculate_observation->module~types module~calculate_observation->module~allocate module~calculate_observation->module~calculate_points module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~types module~condition_fixinitialcondition->module~allocate_structure module~condition_fixinitialcondition->module~allocate module~condition_fixinitialcondition->module~calculate_update module~matrix_assemble Matrix_Assemble module~condition_fixinitialcondition->module~matrix_assemble module~condition_fixboundarycondition Condition_FixBoundaryCondition module~condition_fixinitialcondition->module~condition_fixboundarycondition module~solver_solve Solver_Solve module~condition_fixinitialcondition->module~solver_solve module~calculate_hcf Calculate_HCF module~calculate_hcf->module~types module~rootfinding_binaryfinding->module~types module~rootfinding_binaryfinding->module~calculate_latentheat module~calculate_blas Calculate_BLAS module~calculate_blas->module~types module~matrix_findind Matrix_FindInd module~matrix_findind->module~types module~calculate_count Calculate_Count module~calculate_count->module~types module~solver_initcopy Solver_InitCopy module~solver_initcopy->module~types module~matrix_assemble->module~types module~matrix_assemble->module~allocate_structure module~matrix_assemble->module~allocate module~matrix_assemble->module~calculate_product module~matrix_assemble->module~matrix_findind module~main_heat Main_Heat module~main_heat->module~types module~main_heat->module~allocate_structure module~main_heat->module~allocate module~main_heat->module~calculate_hcf module~calculate_wrf Calculate_WRF module~calculate_wrf->module~types module~condition_fixboundarycondition->module~types module~condition_fixboundarycondition->module~matrix_findind module~inout_stdout Inout_Stdout module~inout_stdout->module~types module~calculate_latentheat->module~types module~solver_solve->module~types module~solver_solve->module~allocate_structure module~solver_solve->module~allocate module~solver_solve->module~calculate_product module~solver_solve->module~solver_precon_jacobi module~solver_solve->module~calculate_blas Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables Temperature Pressure Stress Linear pTransition NonLinear nTransition GravityAcceleration undumped dumped Derived Types VC Vector2D Vector3D DP2d DP3d INT2d INT3d PH Phases Shape BoudaryConditionInfo BoudaryCondition Boudary_Condition_Dirichlet Boudary_Condition_Neumann Boudary_Condition InitialConditionInfo InitialCondition MPIInfo Basic_params Base_Density Type_Density_3Phase Type_Density_2Phase Type_Density_1Phase Base_SpecificHeat Type_SpecificHeat_3Phase Type_SpecificHeat_2Phase Type_SpecificHeat_1Phase Base_ThermalConductivity Type_ThermalConductivity_3Phase Type_ThermalConductivity_3Phase_Dispersity_2D Type_ThermalConductivity_3Phase_Dispersity_3D Type_ThermalConductivity_2Phase Type_ThermalConductivity_1Phase Base_Ice Type_Ice_TRM Type_Ice_GCC Type_Ice_EXP Type_Thermal Base_Hydraulic Base_Impedance Type_Impedance Base_KTDynamics Type_KTDynamics Type_Region_Flags Type_Region DF Flag CRS Lis Observation2d HeatVariables HeatConstants PowerModel GCCModel WRF_Parameters Base_WRF Type_WRF_BC Type_WRF_VG Type_WRF_KO Type_WRF_MVG Type_WRF_Durner Type_WRF_DVGCH HCF_Parameters Base_HCF Type_HCF_BC LatentHeatTreatment HeatFields WaterVariables WaterConstants WaterFields Geometry2d Geometry_2D TimeInfo Iteration SolverInfo Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: Temperature = 1 integer(kind=int32), public, parameter :: Pressure = 2 integer(kind=int32), public, parameter :: Stress = 3 integer(kind=int32), public, parameter :: Linear = 1 integer(kind=int32), public, parameter :: pTransition = 2 integer(kind=int32), public, parameter :: NonLinear = 3 integer(kind=int32), public, parameter :: nTransition = 4 real(kind=real64), public, parameter :: GravityAcceleration = 9.80655d0 integer(kind=int32), public, parameter :: undumped = 0 integer(kind=int32), public, parameter :: dumped = 1 Derived Types type, public, sequence  :: VC Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y type, public, sequence  :: Vector2D Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y type, public, sequence  :: Vector3D Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y real(kind=real64), public :: z type, public, sequence  :: DP2d Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: x (:) real(kind=real64), public, allocatable :: y (:) type, public, sequence  :: DP3d Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: x (:) real(kind=real64), public, allocatable :: y (:) real(kind=real64), public, allocatable :: z (:) type, public, sequence  :: INT2d Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: x (:) integer(kind=int32), public, allocatable :: y (:) type, public, sequence  :: INT3d Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: x (:) integer(kind=int32), public, allocatable :: y (:) integer(kind=int32), public, allocatable :: z (:) type, public, sequence  :: PH Components Type Visibility Attributes Name Initial real(kind=real64), public :: soil real(kind=real64), public :: water real(kind=real64), public :: ice type, public, sequence  :: Phases Components Type Visibility Attributes Name Initial real(kind=real64), public :: soil real(kind=real64), public :: water real(kind=real64), public :: ice type, public, sequence  :: Shape Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: a (:,:) real(kind=real64), public, allocatable :: b (:,:) real(kind=real64), public, allocatable :: c (:,:) real(kind=real64), public, allocatable :: d (:,:) type, public :: BoudaryConditionInfo Components Type Visibility Attributes Name Initial integer(kind=int32), public, allocatable :: Node (:) integer(kind=int32), public, allocatable :: TypeKey (:) integer(kind=int32), public, allocatable :: type (:) real(kind=real64), public, allocatable :: value (:) type( INT2d ), public :: Edges integer(kind=int32), public, allocatable :: EdgesDirection (:) real(kind=real64), public, allocatable :: EdgesDistance (:) type, public :: BoudaryCondition Components Type Visibility Attributes Name Initial type( BoudaryConditionInfo ), public :: Heat type( BoudaryConditionInfo ), public :: Water type( BoudaryConditionInfo ), public :: Stress integer(kind=int32), public :: numNode integer(kind=int32), public :: numType integer(kind=int32), public :: numEdges type, public :: Boudary_Condition_Dirichlet Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Node integer(kind=int32), public :: Num_Type integer(kind=int32), public, allocatable :: Node (:) integer(kind=int32), public, allocatable :: Node_Type (:) integer(kind=int32), public, allocatable :: Value_Info (:) real(kind=real64), public, allocatable :: value (:) type, public :: Boudary_Condition_Neumann Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Edge integer(kind=int32), public :: Num_Edge_Type integer(kind=int32), public :: Num_Type integer(kind=int32), public, allocatable :: Edge (:,:) integer(kind=int32), public, allocatable :: Edge_Type (:) integer(kind=int32), public, allocatable :: Value_Info (:) real(kind=real64), public, allocatable :: value (:) real(kind=real64), public, allocatable :: Heat_Transfer (:) type, public :: Boudary_Condition Components Type Visibility Attributes Name Initial type( Boudary_Condition_Dirichlet ), public :: Dirichlet type( Boudary_Condition_Neumann ), public :: Neumann type, public :: InitialConditionInfo Components Type Visibility Attributes Name Initial integer(kind=int32), public :: type real(kind=real64), public :: value logical, public :: isSet type, public :: InitialCondition Components Type Visibility Attributes Name Initial type( InitialConditionInfo ), public :: Heat type( InitialConditionInfo ), public :: Water type( InitialConditionInfo ), public :: Stress type, public :: MPIInfo Components Type Visibility Attributes Name Initial integer(kind=int32), public :: size integer(kind=int32), public :: rank type, public :: Basic_params Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Element integer(kind=int32), public :: Node integer(kind=int32), public :: Shape integer(kind=int32), public :: Dim integer(kind=int32), public :: Region character, public, allocatable :: Calculation_timeUnit character, public, allocatable :: Input_timeUnit character, public, allocatable :: Output_timeUnit character, public, allocatable :: Interval_timeUnit integer(kind=int32), public :: Calculation_step integer(kind=int32), public :: CalculationPeriod integer(kind=int32), public :: Interval logical, public :: isDisplayPrompt character, public, allocatable :: FileOutput type, public :: Base_Density type, public, extends( Base_Density ) :: Type_Density_3Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type, public, extends( Base_Density ) :: Type_Density_2Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2 type, public, extends( Base_Density ) :: Type_Density_1Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 type, public :: Base_SpecificHeat type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_3Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_2Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2 type, public, extends( Base_SpecificHeat ) :: Type_SpecificHeat_1Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 type, public :: Base_ThermalConductivity type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_3Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type, public, extends( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_2D Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type( Vector2D ), public :: dispersity type, public, extends( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_3D Components Type Visibility Attributes Name Initial real(kind=real64), public :: Soil real(kind=real64), public :: Water real(kind=real64), public :: Ice type( Vector3D ), public :: dispersity type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_2Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 real(kind=real64), public :: Phase2 type, public, extends( Base_ThermalConductivity ) :: Type_ThermalConductivity_1Phase Components Type Visibility Attributes Name Initial real(kind=real64), public :: Phase1 type, public :: Base_Ice Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat type, public, extends( Base_Ice ) :: Type_Ice_TRM Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf type, public, extends( Base_Ice ) :: Type_Ice_GCC Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf integer(kind=int32), public :: ModelType class( Base_WRF ), public, allocatable :: WRF type, public, extends( Base_Ice ) :: Type_Ice_EXP Components Type Visibility Attributes Name Initial real(kind=real64), public :: LatentHeat real(kind=real64), public :: Tf real(kind=real64), public :: a type, public :: Type_Thermal Components Type Visibility Attributes Name Initial class( Base_Density ), public, allocatable :: Density class( Base_SpecificHeat ), public, allocatable :: SpecificHeat class( Base_ThermalConductivity ), public, allocatable :: ThermalConductivity real(kind=real64), public :: Porosity class( Base_Ice ), public, allocatable :: Ice type, public :: Base_Hydraulic Components Type Visibility Attributes Name Initial logical, public :: useImpedance class( Base_Impedance ), public, allocatable :: Impedance integer(kind=int32), public :: useKTDynamics class( Base_KTDynamics ), public, allocatable :: KTDynamics logical, public :: useHCF class( Base_HCF ), public, allocatable :: HCF real(kind=real64), public :: Ks type, public :: Base_Impedance type, public, extends( Base_Impedance ) :: Type_Impedance Components Type Visibility Attributes Name Initial real(kind=real64), public :: Omega type, public :: Base_KTDynamics type, public, extends( Base_KTDynamics ) :: Type_KTDynamics Components Type Visibility Attributes Name Initial real(kind=real64), public :: kzero type, public :: Type_Region_Flags Components Type Visibility Attributes Name Initial logical, public :: isHeat logical, public :: isWater logical, public :: isStress logical, public :: is1Phase logical, public :: is2Phase logical, public :: is3Phase logical, public :: isCompression logical, public :: isFrostHeavePressure logical, public :: isDispersity logical, public :: isFrozen type, public :: Type_Region Components Type Visibility Attributes Name Initial integer(kind=int32), public :: CalculationType integer(kind=int32), public :: Modelnumber type( Type_Thermal ), public :: Thermal type( Type_Region_Flags ), public :: Flags type, public :: DF Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: new (:) real(kind=real64), public, allocatable :: old (:) real(kind=real64), public, allocatable :: pre (:) real(kind=real64), public, allocatable :: dif (:) real(kind=real64), public, allocatable :: div (:) real(kind=real64), public, allocatable :: tmp (:) type, public :: Flag Components Type Visibility Attributes Name Initial logical, public :: isTRM logical, public :: isGCC logical, public :: isPower logical, public :: isSwitchTRM logical, public :: isSwitchOnceTRM logical, public :: isStdOut logical, public :: isOutputAll logical, public :: isOutput logical, public :: isPrintLisMem logical, public, allocatable :: outOBS (:) type, public :: CRS Components Type Visibility Attributes Name Initial integer(kind=int32), public :: nnz integer(kind=int32), public, allocatable :: Ptr (:) integer(kind=int32), public, allocatable :: Ind (:) real(kind=real64), public, allocatable :: Val (:) type, public :: Lis Components Type Visibility Attributes Name Initial integer(kind=int32), public :: TSolver integer(kind=int32), public :: TOption integer(kind=int32), public :: PSolver integer(kind=int32), public :: POption integer(kind=int32), public :: Maxiter real(kind=real64), public :: Tol logical, public :: isOMP type, public :: Observation2d Components Type Visibility Attributes Name Initial integer(kind=int32), public :: nObs integer(kind=int32), public :: nObsType integer(kind=int32), public, allocatable :: obsPoint (:) type( DP2d ), public :: obsCOO integer(kind=int32), public, allocatable :: nAreaObs (:) real(kind=real64), public, allocatable :: vAreaObs (:,:) type, public :: HeatVariables Components Type Visibility Attributes Name Initial type( DF ), public :: Cs type( DF ), public :: Cp type( DF ), public :: lambda type( DF ), public :: rho type( DF ), public :: Ca type( DP2d ), public :: Tgrad type( DP2d ), public :: TFlux integer(kind=int32), public, allocatable :: Phase (:) type, public :: HeatConstants Components Type Visibility Attributes Name Initial type( Phases ), public :: Density type( Phases ), public :: ThermalConductivity type( Phases ), public :: SpecificHeat type( Phases ), public :: HeatCapacity type( Vector2D ), public :: dispersity real(kind=real64), public :: Porosity real(kind=real64), public :: LatentHeat type, public :: PowerModel Components Type Visibility Attributes Name Initial real(kind=real64), public :: phi real(kind=real64), public :: Tf real(kind=real64), public :: a real(kind=real64), public :: Ca_max type, public :: GCCModel Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha real(kind=real64), public :: n real(kind=real64), public :: m real(kind=real64), public :: Tf real(kind=real64), public :: Ca_max type, public :: WRF_Parameters Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 type, public :: Base_WRF Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR type, public, extends( Base_WRF ) :: Type_WRF_BC Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 type, public, extends( Base_WRF ) :: Type_WRF_VG Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 type, public, extends( Base_WRF ) :: Type_WRF_KO Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 type, public, extends( Base_WRF ) :: Type_WRF_MVG Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: hcrit type, public, extends( Base_WRF ) :: Type_WRF_Durner Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2 type, public, extends( Base_WRF ) :: Type_WRF_DVGCH Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 real(kind=real64), public :: m1 real(kind=real64), public :: n2 real(kind=real64), public :: m2 real(kind=real64), public :: w1 real(kind=real64), public :: w2 type, public :: HCF_Parameters Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: alpha2 real(kind=real64), public :: n1 real(kind=real64), public :: n2 real(kind=real64), public :: m1 real(kind=real64), public :: m2 real(kind=real64), public :: hcrit real(kind=real64), public :: w1 real(kind=real64), public :: w2 real(kind=real64), public :: Ks real(kind=real64), public :: kzero real(kind=real64), public :: l real(kind=real64), public :: Omega type, public :: Base_HCF Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR type, public, extends( Base_HCF ) :: Type_HCF_BC Components Type Visibility Attributes Name Initial real(kind=real64), public :: thetaS real(kind=real64), public :: thetaR real(kind=real64), public :: alpha1 real(kind=real64), public :: n1 type, public :: LatentHeatTreatment Components Type Visibility Attributes Name Initial integer(kind=int32), public :: useModel real(kind=real64), public :: Lf real(kind=real64), public :: rhoI real(kind=real64), public :: Cp_unf type( GCCModel ), public :: GCC type( PowerModel ), public :: Power type, public :: HeatFields Components Type Visibility Attributes Name Initial type( HeatVariables ), public :: Variables type( HeatConstants ), public :: Constants type( LatentHeatTreatment ), public :: Latent type( CRS ), public :: LHS_A real(kind=real64), public, allocatable :: RA (:,:) real(kind=real64), public, allocatable :: Rhs (:) type, public :: WaterVariables Components Type Visibility Attributes Name Initial type( DF ), public :: Klh type( DP2d ), public :: wFlux type( DP2d ), public :: hGrad type, public :: WaterConstants Components Type Visibility Attributes Name Initial type( Phases ), public :: HydraulicConductivity real(kind=real64), public :: zeta type, public :: WaterFields Components Type Visibility Attributes Name Initial type( WaterVariables ), public :: Variables type( WaterConstants ), public :: Constants type( CRS ), public :: LHS_A real(kind=real64), public, allocatable :: RA (:,:) real(kind=real64), public, allocatable :: Rhs (:) type, public :: Geometry2d Components Type Visibility Attributes Name Initial integer(kind=int32), public :: element integer(kind=int32), public :: node integer(kind=int32), public :: shape integer(kind=int32), public :: dim integer(kind=int32), public :: ShCoe integer(kind=int32), public, allocatable :: pElement (:,:) type( DP2d ), public :: vCood real(kind=real64), public, allocatable :: eArea (:) type( Shape ), public :: Basis type, public :: Geometry_2D Components Type Visibility Attributes Name Initial integer(kind=int32), public :: Num_Elements integer(kind=int32), public :: Num_Nodes integer(kind=int32), public :: Num_Shape integer(kind=int32), public :: Num_Dimention integer(kind=int32), public :: Num_Shape_Type integer(kind=int32), public :: Num_Region integer(kind=int32), public, allocatable :: Element (:,:) integer(kind=int32), public, allocatable :: Element_Region (:) integer(kind=int32), public, allocatable :: COO_Region (:) type( DP2d ), public :: Nodes_2D real(kind=real64), public, allocatable :: Area (:) type( Shape ), public :: Shape_Function type, public :: TimeInfo Components Type Visibility Attributes Name Initial character(len=3), public :: tUnit real(kind=real64), public :: cTime real(kind=real64), public :: cdt real(kind=real64), public :: cinterval real(kind=real64), public :: ts real(kind=real64), public :: te real(kind=real64), public :: max_dt real(kind=real64), public :: min_dt real(kind=real64), public :: tconv real(kind=real64), public, pointer :: tst real(kind=real64), public, pointer :: dt real(kind=real64), public, pointer :: odt type, public :: Iteration Components Type Visibility Attributes Name Initial integer(kind=int32), public :: itermax integer(kind=int32), public :: iNLmax integer(kind=int32), public :: iNI integer(kind=int32), public, pointer :: iter integer(kind=int32), public, pointer :: titer integer(kind=int32), public, pointer :: iNL integer(kind=int32), public :: digits_itermax type, public :: SolverInfo Components Type Visibility Attributes Name Initial type( Geometry2d ), public :: N logical, public :: isHeat logical, public :: isWater logical, public :: isStress integer(kind=int32), public :: nAnalysis integer(kind=int32), public :: nFrTreat integer(kind=int32), public :: nTimeDisc integer(kind=int32), public :: isStdOut integer(kind=int32), public :: outputFile type( TimeInfo ), public :: Time type( Iteration ), public :: Iter type( Observation2d ), public :: Obs type( HeatFields ), public :: Heat type( WaterFields ), public :: Water type( BoudaryCondition ), public :: BC type( InitialCondition ), public :: IC type( DF ), public :: mWater type( DF ), public :: mIce type( DF ), public :: T type( DF ), public :: P type( DF ), public :: Si type( DF ), public :: Sw type( Lis ), public :: Lis type( Flag ), public :: Flags character(len=64), public :: fmt_Stdout character(len=64), public :: fmt_Fileout type( MPIInfo ), public :: MPI","tags":"","loc":"module/types.html"},{"title":"Solver_Solve – Freezing Thawing Dynamics Simulation Solver","text":"Uses Allocate Calculate_Product error Allocate_Structure iso_fortran_env Solver_Precon_jacobi Calculate_BLAS Types omp_lib module~~solver_solve~~UsesGraph module~solver_solve Solver_Solve module~allocate_structure Allocate_Structure module~solver_solve->module~allocate_structure module~solver_precon_jacobi Solver_Precon_jacobi module~solver_solve->module~solver_precon_jacobi module~error error module~solver_solve->module~error iso_fortran_env iso_fortran_env module~solver_solve->iso_fortran_env module~calculate_product Calculate_Product module~solver_solve->module~calculate_product module~calculate_blas Calculate_BLAS module~solver_solve->module~calculate_blas module~allocate Allocate module~solver_solve->module~allocate module~types Types module~solver_solve->module~types omp_lib omp_lib module~solver_solve->omp_lib module~allocate_structure->module~error module~allocate_structure->iso_fortran_env module~allocate_structure->module~allocate module~allocate_structure->module~types module~solver_precon_jacobi->iso_fortran_env module~solver_precon_jacobi->module~types module~solver_precon_jacobi->omp_lib module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~calculate_product->iso_fortran_env module~calculate_product->module~types module~calculate_product->omp_lib module~calculate_blas->iso_fortran_env module~calculate_blas->module~types module~calculate_blas->omp_lib module~allocate->module~error module~allocate->iso_fortran_env module~allocate->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~solver_solve~~UsedByGraph module~solver_solve Solver_Solve module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~solver_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces ILS DLS Derived Types ILS DLS Interfaces public interface ILS private function Solve_Initialize_BiCGStab(Solver, MCRS) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(in) :: Solver type( CRS ), intent(in) :: MCRS Return Value type( ILS ) public interface DLS private function Solve_Initialize_LU(Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ) :: Solver Return Value type( DLS ) Derived Types type, public :: ILS Constructor private  function Solve_Initialize_BiCGStab (Solver, MCRS) Finalizations Procedures final :: ILS_Destructor Type-Bound Procedures procedure, public :: BiCGStab => Solver_BiCGStab procedure, public :: Chkerr => Solver_Check_Error type, public :: DLS Constructor private  function Solve_Initialize_LU (Solver) Type-Bound Procedures procedure, public :: LU => Solver_LU","tags":"","loc":"module/solver_solve.html"},{"title":"error – Freezing Thawing Dynamics Simulation Solver","text":"Check whether the array has NaN or not Uses ieee_arithmetic iso_fortran_env module~~error~~UsesGraph module~error error ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic iso_fortran_env iso_fortran_env module~error->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~error~~UsedByGraph module~error error module~allocate_structure Allocate_Structure module~allocate_structure->module~error module~allocate Allocate module~allocate_structure->module~allocate module~inout_output Inout_Output module~inout_output->module~error module~inout_output->module~allocate module~inout_setprojectpath Inout_SetProjectPath module~inout_output->module~inout_setprojectpath module~matrix_assemble Matrix_Assemble module~matrix_assemble->module~error module~matrix_assemble->module~allocate_structure module~matrix_assemble->module~allocate module~calculate_area Calculate_Area module~calculate_area->module~error module~calculate_points Calculate_Points module~calculate_area->module~calculate_points module~allocate->module~error module~inout_setprojectpath->module~error module~calculate_points->module~error module~calculate_count Calculate_Count module~calculate_count->module~error module~calculate_shape Calculate_Shape module~calculate_shape->module~error module~calculate_shape->module~calculate_points module~solver_solve Solver_Solve module~solver_solve->module~error module~solver_solve->module~allocate_structure module~solver_solve->module~allocate module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~error module~condition_fixinitialcondition->module~allocate_structure module~condition_fixinitialcondition->module~matrix_assemble module~condition_fixinitialcondition->module~allocate module~condition_fixinitialcondition->module~solver_solve module~main_heat Main_Heat module~main_heat->module~allocate_structure module~main_heat->module~allocate module~calculate_observation Calculate_Observation module~calculate_observation->module~allocate module~calculate_observation->module~calculate_points module~matrix_convertcrs Matrix_ConvertCRS module~matrix_convertcrs->module~allocate module~solver_initialize Solver_Initialize module~solver_initialize->module~allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces has_nan value_in_range Subroutines error_message Interfaces public interface has_nan private function has_nan_real64_scalar(scalar) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: scalar Return Value logical private function has_nan_real64_rank1(array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:) Return Value logical private function has_nan_real64_rank2(array) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: array (:,:) Return Value logical public interface value_in_range private function value_in_range_int32(value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max Return Value logical private function value_in_range_real64(value, min, max) result(in_range) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: value real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max Return Value logical Subroutines public subroutine error_message (err_number, myrank, opt, opt_file_name, copt1, copt2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: err_number integer(kind=int32), intent(in), optional :: myrank real(kind=real64), intent(in), optional :: opt character, intent(in), optional :: opt_file_name character, intent(in), optional :: copt1 character, intent(in), optional :: copt2","tags":"","loc":"module/error.html"},{"title":"Solver_Precon_jacobi – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types omp_lib module~~solver_precon_jacobi~~UsesGraph module~solver_precon_jacobi Solver_Precon_jacobi iso_fortran_env iso_fortran_env module~solver_precon_jacobi->iso_fortran_env module~types Types module~solver_precon_jacobi->module~types omp_lib omp_lib module~solver_precon_jacobi->omp_lib module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~solver_precon_jacobi~~UsedByGraph module~solver_precon_jacobi Solver_Precon_jacobi module~solver_solve Solver_Solve module~solver_solve->module~solver_precon_jacobi module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~solver_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Create_Precond_Jacobi Apply_Precond_Jacobi Subroutines public subroutine Create_Precond_Jacobi (N, A, M) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N type( CRS ), intent(in) :: A real(kind=real64), intent(inout) :: M (:) public subroutine Apply_Precond_Jacobi (N, M, r, z) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: N real(kind=real64), intent(in) :: M (:) real(kind=real64), intent(in) :: r (:) real(kind=real64), intent(inout) :: z (:)","tags":"","loc":"module/solver_precon_jacobi.html"},{"title":"Solver_InitCopy – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types module~~solver_initcopy~~UsesGraph module~solver_initcopy Solver_InitCopy iso_fortran_env iso_fortran_env module~solver_initcopy->iso_fortran_env module~types Types module~solver_initcopy->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Init_Copy_Temperature Init_Copy_Pressure Subroutines public subroutine Init_Copy_Temperature (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver public subroutine Init_Copy_Pressure (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/solver_initcopy.html"},{"title":"Solver_Initialize – Freezing Thawing Dynamics Simulation Solver","text":"Uses Allocate Calculate_LatentHeat iso_fortran_env Types module~~solver_initialize~~UsesGraph module~solver_initialize Solver_Initialize module~allocate Allocate module~solver_initialize->module~allocate module~calculate_latentheat Calculate_LatentHeat module~solver_initialize->module~calculate_latentheat iso_fortran_env iso_fortran_env module~solver_initialize->iso_fortran_env module~types Types module~solver_initialize->module~types module~allocate->iso_fortran_env module~allocate->module~types module~error error module~allocate->module~error module~calculate_latentheat->iso_fortran_env module~calculate_latentheat->module~types omp_lib omp_lib module~calculate_latentheat->omp_lib module~types->iso_fortran_env module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Initialize_Solver Subroutines public subroutine Initialize_Solver (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/solver_initialize.html"},{"title":"RootFinding_BinaryFinding – Freezing Thawing Dynamics Simulation Solver","text":"Uses Calculate_LatentHeat ieee_arithmetic iso_fortran_env Types module~~rootfinding_binaryfinding~~UsesGraph module~rootfinding_binaryfinding RootFinding_BinaryFinding module~calculate_latentheat Calculate_LatentHeat module~rootfinding_binaryfinding->module~calculate_latentheat ieee_arithmetic ieee_arithmetic module~rootfinding_binaryfinding->ieee_arithmetic iso_fortran_env iso_fortran_env module~rootfinding_binaryfinding->iso_fortran_env module~types Types module~rootfinding_binaryfinding->module~types module~calculate_latentheat->iso_fortran_env module~calculate_latentheat->module~types omp_lib omp_lib module~calculate_latentheat->omp_lib module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~rootfinding_binaryfinding~~UsedByGraph module~rootfinding_binaryfinding RootFinding_BinaryFinding module~calculate_update Calculate_Update module~calculate_update->module~rootfinding_binaryfinding module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~calculate_update Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Binary_finding Subroutines public subroutine Binary_finding (Solver, ind) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: ind","tags":"","loc":"module/rootfinding_binaryfinding.html"},{"title":"RootFinding_SecantMethod – Freezing Thawing Dynamics Simulation Solver","text":"Uses Calculate_LatentHeat ieee_arithmetic iso_fortran_env Types module~~rootfinding_secantmethod~~UsesGraph module~rootfinding_secantmethod RootFinding_SecantMethod module~calculate_latentheat Calculate_LatentHeat module~rootfinding_secantmethod->module~calculate_latentheat ieee_arithmetic ieee_arithmetic module~rootfinding_secantmethod->ieee_arithmetic iso_fortran_env iso_fortran_env module~rootfinding_secantmethod->iso_fortran_env module~types Types module~rootfinding_secantmethod->module~types module~calculate_latentheat->iso_fortran_env module~calculate_latentheat->module~types omp_lib omp_lib module~calculate_latentheat->omp_lib module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~rootfinding_secantmethod~~UsedByGraph module~rootfinding_secantmethod RootFinding_SecantMethod module~calculate_update Calculate_Update module~calculate_update->module~rootfinding_secantmethod module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~calculate_update Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Secant_method Subroutines public subroutine Secant_method (Solver, ind) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: ind","tags":"","loc":"module/rootfinding_secantmethod.html"},{"title":"Allocate_Structure – Freezing Thawing Dynamics Simulation Solver","text":"Uses Allocate iso_fortran_env Types error module~~allocate_structure~~UsesGraph module~allocate_structure Allocate_Structure module~allocate Allocate module~allocate_structure->module~allocate module~error error module~allocate_structure->module~error iso_fortran_env iso_fortran_env module~allocate_structure->iso_fortran_env module~types Types module~allocate_structure->module~types module~allocate->module~error module~allocate->iso_fortran_env module~allocate->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~allocate_structure~~UsedByGraph module~allocate_structure Allocate_Structure module~matrix_assemble Matrix_Assemble module~matrix_assemble->module~allocate_structure module~main_heat Main_Heat module~main_heat->module~allocate_structure module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~allocate_structure module~condition_fixinitialcondition->module~matrix_assemble module~solver_solve Solver_Solve module~condition_fixinitialcondition->module~solver_solve module~solver_solve->module~allocate_structure Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Allocate_DF Allocate_DP2d Allocate_BCinfo Allocate_Solver Allocate_Structure_Thermal_Type Allocate_Structure_Ice_Type Allocate_Structure_WRF_Type Subroutines public subroutine Allocate_DF (ar_DF, n) Arguments Type Intent Optional Attributes Name type( DF ), intent(inout) :: ar_DF integer(kind=int32), intent(in) :: n public subroutine Allocate_DP2d (ar_DP2d, n) Arguments Type Intent Optional Attributes Name type( DP2d ), intent(inout) :: ar_DP2d integer(kind=int32), intent(in) :: n public subroutine Allocate_BCinfo (BCinfo, nNode, nType, nEdge) Arguments Type Intent Optional Attributes Name type( BoudaryConditionInfo ), intent(inout) :: BCinfo integer(kind=int32), intent(in) :: nNode integer(kind=int32), intent(in) :: nType integer(kind=int32), intent(in), optional :: nEdge public subroutine Allocate_Solver (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver Allocate Geometry2d public subroutine Allocate_Structure_Thermal_Type (Structure_Thermal, Flags) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal type( Type_Region_Flags ), intent(in) :: Flags public subroutine Allocate_Structure_Ice_Type (Structure_Thermal, QiceModelType) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal integer(kind=int32), intent(in) :: QiceModelType public subroutine Allocate_Structure_WRF_Type (Structure_Thermal, WRFModelType) Arguments Type Intent Optional Attributes Name type( Type_Thermal ), intent(inout) :: Structure_Thermal integer(kind=int32), intent(in) :: WRFModelType","tags":"","loc":"module/allocate_structure.html"},{"title":"Allocate – Freezing Thawing Dynamics Simulation Solver","text":"Uses iso_fortran_env Types error module~~allocate~~UsesGraph module~allocate Allocate iso_fortran_env iso_fortran_env module~allocate->iso_fortran_env module~error error module~allocate->module~error module~types Types module~allocate->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~allocate~~UsedByGraph module~allocate Allocate module~matrix_assemble Matrix_Assemble module~matrix_assemble->module~allocate module~allocate_structure Allocate_Structure module~matrix_assemble->module~allocate_structure module~allocate_structure->module~allocate module~inout_output Inout_Output module~inout_output->module~allocate module~main_heat Main_Heat module~main_heat->module~allocate module~main_heat->module~allocate_structure module~solver_initialize Solver_Initialize module~solver_initialize->module~allocate module~matrix_convertcrs Matrix_ConvertCRS module~matrix_convertcrs->module~allocate module~calculate_observation Calculate_Observation module~calculate_observation->module~allocate module~solver_solve Solver_Solve module~solver_solve->module~allocate module~solver_solve->module~allocate_structure module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~allocate module~condition_fixinitialcondition->module~matrix_assemble module~condition_fixinitialcondition->module~allocate_structure module~condition_fixinitialcondition->module~solver_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces Allocate_Vector Allocate_Matrix Allocate_Pointer Subroutines Duplicate_CRS Interfaces public interface Allocate_Vector private subroutine Check_Allocate_rank1_int32(iar, ar_size) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_real64(dar, ar_size) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_logical(lar, ar_size) Arguments Type Intent Optional Attributes Name logical, intent(inout), allocatable :: lar (:) integer(kind=int32), intent(in) :: ar_size private subroutine Check_Allocate_rank1_int32_specify(iar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: iar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last private subroutine Check_Allocate_rank1_real64_specify(dar, ar_first, ar_last) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dar (:) integer(kind=int32), intent(in) :: ar_first integer(kind=int32), intent(in) :: ar_last public interface Allocate_Matrix private subroutine Check_Allocate_rank2_int32(imt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), allocatable :: imt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2 private subroutine Check_Allocate_rank2_real64(dmt, mt_size_1, mt_size_2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), allocatable :: dmt (:,:) integer(kind=int32), intent(in) :: mt_size_1 integer(kind=int32), intent(in) :: mt_size_2 public interface Allocate_Pointer private subroutine Check_Allocate_Pointer_real64(dptr) Arguments Type Intent Optional Attributes Name real(kind=real64), pointer :: dptr private subroutine Check_Allocate_Pointer_int32(iptr) Arguments Type Intent Optional Attributes Name integer(kind=int32), pointer :: iptr Subroutines public subroutine Duplicate_CRS (A, B) Arguments Type Intent Optional Attributes Name type( CRS ), intent(in) :: A type( CRS ), intent(inout) :: B","tags":"","loc":"module/allocate.html"},{"title":"Condition_FixInitialCondition – Freezing Thawing Dynamics Simulation Solver","text":"Uses Allocate Condition_FixBoundaryCondition Solver_Solve Calculate_Update iso_fortran_env Allocate_Structure error Matrix_Assemble Types module~~condition_fixinitialcondition~~UsesGraph module~condition_fixinitialcondition Condition_FixInitialCondition iso_fortran_env iso_fortran_env module~condition_fixinitialcondition->iso_fortran_env module~allocate_structure Allocate_Structure module~condition_fixinitialcondition->module~allocate_structure module~error error module~condition_fixinitialcondition->module~error module~matrix_assemble Matrix_Assemble module~condition_fixinitialcondition->module~matrix_assemble module~condition_fixboundarycondition Condition_FixBoundaryCondition module~condition_fixinitialcondition->module~condition_fixboundarycondition module~allocate Allocate module~condition_fixinitialcondition->module~allocate module~calculate_update Calculate_Update module~condition_fixinitialcondition->module~calculate_update module~solver_solve Solver_Solve module~condition_fixinitialcondition->module~solver_solve module~types Types module~condition_fixinitialcondition->module~types module~allocate_structure->iso_fortran_env module~allocate_structure->module~error module~allocate_structure->module~allocate module~allocate_structure->module~types module~error->iso_fortran_env ieee_arithmetic ieee_arithmetic module~error->ieee_arithmetic module~matrix_assemble->iso_fortran_env module~matrix_assemble->module~allocate_structure module~matrix_assemble->module~error module~matrix_assemble->module~allocate module~matrix_assemble->module~types module~calculate_product Calculate_Product module~matrix_assemble->module~calculate_product module~matrix_findind Matrix_FindInd module~matrix_assemble->module~matrix_findind omp_lib omp_lib module~matrix_assemble->omp_lib module~condition_fixboundarycondition->iso_fortran_env module~condition_fixboundarycondition->module~types module~condition_fixboundarycondition->module~matrix_findind module~allocate->iso_fortran_env module~allocate->module~error module~allocate->module~types module~calculate_update->iso_fortran_env module~calculate_update->module~types module~rootfinding_binaryfinding RootFinding_BinaryFinding module~calculate_update->module~rootfinding_binaryfinding module~rootfinding_secantmethod RootFinding_SecantMethod module~calculate_update->module~rootfinding_secantmethod module~calculate_update->omp_lib module~solver_solve->iso_fortran_env module~solver_solve->module~allocate_structure module~solver_solve->module~error module~solver_solve->module~allocate module~solver_solve->module~types module~solver_solve->module~calculate_product module~solver_precon_jacobi Solver_Precon_jacobi module~solver_solve->module~solver_precon_jacobi module~calculate_blas Calculate_BLAS module~solver_solve->module~calculate_blas module~solver_solve->omp_lib module~types->iso_fortran_env module~rootfinding_binaryfinding->iso_fortran_env module~rootfinding_binaryfinding->module~types module~rootfinding_binaryfinding->ieee_arithmetic module~calculate_latentheat Calculate_LatentHeat module~rootfinding_binaryfinding->module~calculate_latentheat module~calculate_product->iso_fortran_env module~calculate_product->module~types module~calculate_product->omp_lib module~rootfinding_secantmethod->iso_fortran_env module~rootfinding_secantmethod->module~types module~rootfinding_secantmethod->ieee_arithmetic module~rootfinding_secantmethod->module~calculate_latentheat module~solver_precon_jacobi->iso_fortran_env module~solver_precon_jacobi->module~types module~solver_precon_jacobi->omp_lib module~calculate_blas->iso_fortran_env module~calculate_blas->module~types module~calculate_blas->omp_lib module~matrix_findind->iso_fortran_env module~matrix_findind->module~types module~calculate_latentheat->iso_fortran_env module~calculate_latentheat->module~types module~calculate_latentheat->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Fix_InitialCondition Subroutines public subroutine Fix_InitialCondition (Solver) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver","tags":"","loc":"module/condition_fixinitialcondition.html"},{"title":"Condition_FixBoundaryCondition – Freezing Thawing Dynamics Simulation Solver","text":"Uses Matrix_FindInd iso_fortran_env Types module~~condition_fixboundarycondition~~UsesGraph module~condition_fixboundarycondition Condition_FixBoundaryCondition module~matrix_findind Matrix_FindInd module~condition_fixboundarycondition->module~matrix_findind iso_fortran_env iso_fortran_env module~condition_fixboundarycondition->iso_fortran_env module~types Types module~condition_fixboundarycondition->module~types module~matrix_findind->iso_fortran_env module~matrix_findind->module~types module~types->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~condition_fixboundarycondition~~UsedByGraph module~condition_fixboundarycondition Condition_FixBoundaryCondition module~condition_fixinitialcondition Condition_FixInitialCondition module~condition_fixinitialcondition->module~condition_fixboundarycondition Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Fix_BoundaryConditions Subroutines public subroutine Fix_BoundaryConditions (Solver, inTarget) Arguments Type Intent Optional Attributes Name type( SolverInfo ), intent(inout) :: Solver integer(kind=int32), intent(in) :: inTarget","tags":"","loc":"module/condition_fixboundarycondition.html"},{"title":"FindInd.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~findind.f90~~EfferentGraph sourcefile~findind.f90 FindInd.f90 sourcefile~types.f90 Types.f90 sourcefile~findind.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~findind.f90~~AfferentGraph sourcefile~findind.f90 FindInd.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~assemble.f90->sourcefile~findind.f90 sourcefile~fixboundarycondition.f90 FixBoundaryCondition.f90 sourcefile~fixboundarycondition.f90->sourcefile~findind.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~fixboundarycondition.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Matrix_FindInd Source Code FindInd.f90 Source Code module Matrix_FindInd use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types , udmp => undumped , dmp => dumped implicit none private public :: Find_CRS_Index public :: Find_CRS_Indexes contains subroutine Find_CRS_Index ( A , serch_column , serch_index , index ) implicit none type ( CRS ), intent ( in ) :: A integer ( int32 ), intent ( in ) :: serch_column , serch_index integer ( int32 ), intent ( inout ) :: index integer ( int32 ) :: i , start_index , end_index index = 0 ! serch_columnのindex範囲を取得 start_index = A % Ptr ( serch_column - 1 ) end_index = A % Ptr ( serch_column ) - 1 ! 範囲内でserch_indexになる値のインデックスを見つける do i = start_index , end_index if ( A % Ind ( i ) == serch_index - 1 ) then index = i end if end do end subroutine Find_CRS_Index subroutine Find_CRS_Indexes ( lump , A , serch_index1 , serch_index2 , serch_index3 , indexes ) implicit none type ( CRS ), intent ( in ) :: A integer ( int32 ), intent ( in ) :: lump , serch_index1 , serch_index2 , serch_index3 integer ( int32 ), intent ( inout ) :: indexes (:) if ( lump == udmp ) then call Find_CRS_Index ( A , serch_index1 , serch_index1 , indexes ( 1 )) call Find_CRS_Index ( A , serch_index1 , serch_index2 , indexes ( 2 )) call Find_CRS_Index ( A , serch_index1 , serch_index3 , indexes ( 3 )) call Find_CRS_Index ( A , serch_index2 , serch_index1 , indexes ( 4 )) call Find_CRS_Index ( A , serch_index2 , serch_index2 , indexes ( 5 )) call Find_CRS_Index ( A , serch_index2 , serch_index3 , indexes ( 6 )) call Find_CRS_Index ( A , serch_index3 , serch_index1 , indexes ( 7 )) call Find_CRS_Index ( A , serch_index3 , serch_index2 , indexes ( 8 )) call Find_CRS_Index ( A , serch_index3 , serch_index3 , indexes ( 9 )) else if ( lump == dmp ) then call Find_CRS_Index ( A , serch_index1 , serch_index1 , indexes ( 1 )) call Find_CRS_Index ( A , serch_index2 , serch_index2 , indexes ( 2 )) call Find_CRS_Index ( A , serch_index3 , serch_index3 , indexes ( 3 )) end if end subroutine Find_CRS_Indexes end module Matrix_FindInd","tags":"","loc":"sourcefile/findind.f90.html"},{"title":"Assemble.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~assemble.f90~~EfferentGraph sourcefile~assemble.f90 Assemble.f90 sourcefile~types.f90 Types.f90 sourcefile~assemble.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~findind.f90 FindInd.f90 sourcefile~assemble.f90->sourcefile~findind.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~assemble.f90->sourcefile~allocate.f90 sourcefile~error.f90 error.f90 sourcefile~assemble.f90->sourcefile~error.f90 sourcefile~product.f90 Product.f90 sourcefile~assemble.f90->sourcefile~product.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~findind.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~product.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~assemble.f90~~AfferentGraph sourcefile~assemble.f90 Assemble.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Matrix_Assemble Source Code Assemble.f90 Source Code module Matrix_Assemble use , intrinsic :: iso_fortran_env , only : int32 , real64 use omp_lib use :: Types , udmp => undumped , dmp => dumped use :: Allocate use :: Allocate_Structure use :: error use :: Matrix_FindInd use :: Calculate_Product , only : SpMV => Matrix_Vector_Product_CRS implicit none private real ( real64 ), parameter :: D3 = 0.33333333333333333333333333333d0 ! 1/3 real ( real64 ), parameter :: D4 = 0.25000000000000000000000000000d0 ! 1/4 real ( real64 ), parameter :: D12 = 0.08333333333333333333333333333d0 ! 1/12 real ( real64 ), parameter :: D24 = 0.04166666666666666666666666666d0 ! 1/24 type ( CRS ) :: tmpCRS1 , tmpCRS2 real ( real64 ), allocatable :: tmpA (:,:) public :: Init_Assemble public :: Assemble_GM_Heat public :: Assemble_GM_Water public :: Assemble_GM_Heat_IC public :: Assemble_GM_Water_IC contains subroutine Init_Assemble ( A ) implicit none type ( CRS ), intent ( in ) :: A call Duplicate_CRS ( A , tmpCRS1 ) tmpCRS1 % val (:) = 0.0d0 call Duplicate_CRS ( A , tmpCRS2 ) tmpCRS2 % val (:) = 0.0d0 end subroutine Init_Assemble subroutine Set_C ( C , case , p , C1 , C2 ) implicit none type ( DF ), intent ( in ) :: C integer ( int32 ), intent ( in ) :: case , p real ( real64 ), intent ( inout ) :: C1 , C2 if ( case == 1 ) then C1 = C % pre ( p ) C2 = C % old ( p ) else if ( case == 2 ) then C1 = C % div ( p ) C2 = C % old ( p ) else if ( case == 3 ) then C1 = C % div ( p ) C2 = C % div ( p ) else if ( case == 4 ) then C1 = C % div ( p ) C2 = C % old ( p ) end if end subroutine Set_C !* 時間項の要素行列を全体CRS行列に組み込むサブルーチン subroutine Calc_GM_Time_TRM ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , C1 , C2 , C3 , C tmpCRS1 % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = Solver % N % eArea ( iN ) * D12 / Solver % Time % dt C1 = Solver % Heat % Variables % Cp % pre ( p1 ) C2 = Solver % Heat % Variables % Cp % pre ( p2 ) C3 = Solver % Heat % Variables % Cp % pre ( p3 ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) tmpCRS1 % Val ( indexes ( 1 )) = tmpCRS1 % Val ( indexes ( 1 )) + CoeA * C1 * 2.d0 tmpCRS1 % Val ( indexes ( 2 )) = tmpCRS1 % Val ( indexes ( 2 )) + CoeA * C1 tmpCRS1 % Val ( indexes ( 3 )) = tmpCRS1 % Val ( indexes ( 3 )) + CoeA * C1 tmpCRS1 % Val ( indexes ( 4 )) = tmpCRS1 % Val ( indexes ( 4 )) + CoeA * C2 tmpCRS1 % Val ( indexes ( 5 )) = tmpCRS1 % Val ( indexes ( 5 )) + CoeA * C2 * 2.d0 tmpCRS1 % Val ( indexes ( 6 )) = tmpCRS1 % Val ( indexes ( 6 )) + CoeA * C2 tmpCRS1 % Val ( indexes ( 7 )) = tmpCRS1 % Val ( indexes ( 7 )) + CoeA * C3 tmpCRS1 % Val ( indexes ( 8 )) = tmpCRS1 % Val ( indexes ( 8 )) + CoeA * C3 tmpCRS1 % Val ( indexes ( 9 )) = tmpCRS1 % Val ( indexes ( 9 )) + CoeA * C3 * 2.d0 end do end subroutine Calc_GM_Time_TRM subroutine Calc_GM_Time_TRM_F ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , C1 , C2 , C3 , C if (. not . allocated ( tmpA )) call Allocate_Matrix ( tmpA , Solver % N % node , Solver % N % node ) tmpA (:,:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = Solver % N % eArea ( iN ) * D12 / Solver % Time % dt C1 = Solver % Heat % Variables % Cp % pre ( p1 ) C2 = Solver % Heat % Variables % Cp % pre ( p2 ) C3 = Solver % Heat % Variables % Cp % pre ( p3 ) tmpA ( p1 , p1 ) = tmpA ( p1 , p1 ) + CoeA * C1 * 2.d0 tmpA ( p1 , p2 ) = tmpA ( p1 , p2 ) + CoeA * C1 tmpA ( p1 , p3 ) = tmpA ( p1 , p3 ) + CoeA * C1 tmpA ( p2 , p1 ) = tmpA ( p2 , p1 ) + CoeA * C2 tmpA ( p2 , p2 ) = tmpA ( p2 , p2 ) + CoeA * C2 * 2.d0 tmpA ( p2 , p3 ) = tmpA ( p2 , p3 ) + CoeA * C2 tmpA ( p3 , p1 ) = tmpA ( p3 , p1 ) + CoeA * C3 tmpA ( p3 , p2 ) = tmpA ( p3 , p2 ) + CoeA * C3 tmpA ( p3 , p3 ) = tmpA ( p3 , p3 ) + CoeA * C3 * 2.d0 end do end subroutine Calc_GM_Time_TRM_F subroutine Calc_GM_Time_Divide ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ) real ( real64 ) :: CoeA , C11 , C12 , C13 , C21 , C22 , C23 tmpCRS1 % val (:) = 0.0d0 tmpCRS2 % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = Solver % N % eArea ( iN ) * D3 / Solver % Time % dt call Set_C ( Solver % Heat % Variables % Ca , Solver % Heat % Variables % Phase ( p1 ), p1 , C11 , C21 ) call Set_C ( Solver % Heat % Variables % Ca , Solver % Heat % Variables % Phase ( p2 ), p2 , C12 , C22 ) call Set_C ( Solver % Heat % Variables % Ca , Solver % Heat % Variables % Phase ( p3 ), p3 , C13 , C23 ) call Find_CRS_Indexes ( dmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) tmpCRS1 % Val ( indexes ( 1 )) = tmpCRS1 % Val ( indexes ( 1 )) + CoeA * C11 tmpCRS1 % Val ( indexes ( 2 )) = tmpCRS1 % Val ( indexes ( 2 )) + CoeA * C12 tmpCRS1 % Val ( indexes ( 3 )) = tmpCRS1 % Val ( indexes ( 3 )) + CoeA * C13 tmpCRS2 % Val ( indexes ( 1 )) = tmpCRS2 % Val ( indexes ( 1 )) + CoeA * C21 tmpCRS2 % Val ( indexes ( 2 )) = tmpCRS2 % Val ( indexes ( 2 )) + CoeA * C22 tmpCRS2 % Val ( indexes ( 3 )) = tmpCRS2 % Val ( indexes ( 3 )) + CoeA * C23 end do end subroutine Calc_GM_Time_Divide subroutine Calc_GM_Time_Richards ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ) real ( real64 ) :: CoeA , C1 , C2 , C3 tmpCRS1 % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = SOlver % Water % Constants % zeta * Solver % N % eArea ( iN ) * D3 / Solver % Time % dt call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) tmpCRS1 % Val ( indexes ( 1 )) = tmpCRS1 % Val ( indexes ( 1 )) + CoeA tmpCRS1 % Val ( indexes ( 2 )) = tmpCRS1 % Val ( indexes ( 2 )) + CoeA tmpCRS1 % Val ( indexes ( 3 )) = tmpCRS1 % Val ( indexes ( 3 )) + CoeA end do end subroutine Calc_GM_Time_Richards !* 拡散項の要素行列を全体CRS行列に組み込むサブルーチン subroutine Calc_GM_Diffusion_TRM ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , Lm1 , Lm2 , Lm3 Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm1 * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm1 * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm1 * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm2 * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm2 * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm2 * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm3 * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm3 * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm3 * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion_TRM subroutine Calc_GM_Diffusion ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , Lm1 , Lm2 , Lm3 , Lm Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) Lm = ( Lm1 + Lm2 + Lm3 ) * D3 be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion subroutine Calc_GM_Diffusion_Richards ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , K1 , K2 , K3 , K Solver % Water % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) K1 = Solver % Water % Variables % Klh % pre ( p1 ) K2 = Solver % Water % Variables % Klh % pre ( p2 ) K3 = Solver % Water % Variables % Klh % pre ( p3 ) K = ( K1 + K2 + K3 ) * D3 be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Water % LHS_A % Val ( indexes ( 1 )) = Solver % Water % LHS_A % Val ( indexes ( 1 )) + K * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 2 )) = Solver % Water % LHS_A % Val ( indexes ( 2 )) + K * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 3 )) = Solver % Water % LHS_A % Val ( indexes ( 3 )) + K * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 4 )) = Solver % Water % LHS_A % Val ( indexes ( 4 )) + K * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 5 )) = Solver % Water % LHS_A % Val ( indexes ( 5 )) + K * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 6 )) = Solver % Water % LHS_A % Val ( indexes ( 6 )) + K * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 7 )) = Solver % Water % LHS_A % Val ( indexes ( 7 )) + K * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 8 )) = Solver % Water % LHS_A % Val ( indexes ( 8 )) + K * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Water % LHS_A % Val ( indexes ( 9 )) = Solver % Water % LHS_A % Val ( indexes ( 9 )) + K * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion_Richards subroutine Calc_GM_Diffusion_Richards_F ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 real ( real64 ) :: CoeA , be1 , be2 , be3 , ga1 , ga2 , ga3 , K1 , K2 , K3 , K Solver % Water % RA (:,:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) K1 = Solver % Water % Variables % Klh % pre ( p1 ) K2 = Solver % Water % Variables % Klh % pre ( p2 ) K3 = Solver % Water % Variables % Klh % pre ( p3 ) K = ( K1 * K2 * K3 ) ** D3 be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) Solver % Water % RA ( p1 , p1 ) = Solver % Water % RA ( p1 , p1 ) + K * ( be1 * be1 + ga1 * ga1 ) * CoeA Solver % Water % RA ( p1 , p2 ) = Solver % Water % RA ( p1 , p2 ) + K * ( be1 * be2 + ga1 * ga2 ) * CoeA Solver % Water % RA ( p1 , p3 ) = Solver % Water % RA ( p1 , p3 ) + K * ( be1 * be3 + ga1 * ga3 ) * CoeA Solver % Water % RA ( p2 , p1 ) = Solver % Water % RA ( p2 , p1 ) + K * ( be2 * be1 + ga2 * ga1 ) * CoeA Solver % Water % RA ( p2 , p2 ) = Solver % Water % RA ( p2 , p2 ) + K * ( be2 * be2 + ga2 * ga2 ) * CoeA Solver % Water % RA ( p2 , p3 ) = Solver % Water % RA ( p2 , p3 ) + K * ( be2 * be3 + ga2 * ga3 ) * CoeA Solver % Water % RA ( p3 , p1 ) = Solver % Water % RA ( p3 , p1 ) + K * ( be3 * be1 + ga3 * ga1 ) * CoeA Solver % Water % RA ( p3 , p2 ) = Solver % Water % RA ( p3 , p2 ) + K * ( be3 * be2 + ga3 * ga2 ) * CoeA Solver % Water % RA ( p3 , p3 ) = Solver % Water % RA ( p3 , p3 ) + K * ( be3 * be3 + ga3 * ga3 ) * CoeA end do end subroutine Calc_GM_Diffusion_Richards_F !* 拡散・移流項の要素行列を全体CRS行列に組み込むサブルーチン subroutine Calc_GM_Diffusion_Advection_TRM ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: be1 , be2 , be3 , ga1 , ga2 , ga3 real ( real64 ) :: CoeA , Lm1 , Lm2 , Lm3 real ( real64 ) :: CoeB , u1 , u2 , u3 , v1 , v2 , v3 , AD1 , AD2 , AD3 Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) CoeB = Solver % Heat % Constants % HeatCapacity % water / 6.0d0 u1 = Solver % Water % Variables % wFlux % x ( p1 ) u2 = Solver % Water % Variables % wFlux % x ( p2 ) u3 = Solver % Water % Variables % wFlux % x ( p3 ) v1 = Solver % Water % Variables % wFlux % y ( p1 ) v2 = Solver % Water % Variables % wFlux % y ( p2 ) v3 = Solver % Water % Variables % wFlux % y ( p3 ) AD1 = u1 * be1 + v1 * ga1 AD2 = u2 * be2 + v2 * ga2 AD3 = u3 * be3 + v3 * ga3 call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm1 * ( be1 * be1 + ga1 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm1 * ( be1 * be2 + ga1 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm1 * ( be1 * be3 + ga1 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm2 * ( be2 * be1 + ga2 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm2 * ( be2 * be2 + ga2 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm2 * ( be2 * be3 + ga2 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm3 * ( be3 * be1 + ga3 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm3 * ( be3 * be2 + ga3 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm3 * ( be3 * be3 + ga3 * ga3 ) * CoeA & + AD3 * CoeB end do end subroutine Calc_GM_Diffusion_Advection_TRM subroutine Calc_GM_Diffusion_Advection_TRM_F ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: be1 , be2 , be3 , ga1 , ga2 , ga3 real ( real64 ) :: CoeA , Lm1 , Lm2 , Lm3 real ( real64 ) :: CoeB , u1 , u2 , u3 , v1 , v2 , v3 , AD1 , AD2 , AD3 Solver % Heat % RA (:,:) = 0.0d0 ! print*,Solver%Heat%RA(1000,:) ! stop do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) CoeB = Solver % Heat % Constants % HeatCapacity % water / 6.0d0 u1 = Solver % Water % Variables % wFlux % x ( p1 ) u2 = Solver % Water % Variables % wFlux % x ( p2 ) u3 = Solver % Water % Variables % wFlux % x ( p3 ) v1 = Solver % Water % Variables % wFlux % y ( p1 ) v2 = Solver % Water % Variables % wFlux % y ( p2 ) v3 = Solver % Water % Variables % wFlux % y ( p3 ) AD1 = 0.0d0 ! u1 * be1 + v1 * ga1 AD2 = 0.0d0 ! u2 * be2 + v2 * ga2 AD3 = 0.0d0 ! u3 * be3 + v3 * ga3 ! AD1  = u1 * be1 + v1 * ga1 ! AD2  = u2 * be2 + v2 * ga2 ! AD3  = u3 * be3 + v3 * ga3 ! print*,p1,p2,p3 ! if (iN==100) stop ! call Find_CRS_Indexes(udmp, tmpCRS1, p1, p2, p3, indexes(:)) Solver % Heat % RA ( p1 , p1 ) = Solver % Heat % RA ( p1 , p1 ) + Lm1 * ( be1 * be1 + ga1 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % RA ( p1 , p2 ) = Solver % Heat % RA ( p1 , p2 ) + Lm2 * ( be1 * be2 + ga1 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % RA ( p1 , p3 ) = Solver % Heat % RA ( p1 , p3 ) + Lm3 * ( be1 * be3 + ga1 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % RA ( p2 , p1 ) = Solver % Heat % RA ( p2 , p1 ) + Lm1 * ( be2 * be1 + ga2 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % RA ( p2 , p2 ) = Solver % Heat % RA ( p2 , p2 ) + Lm2 * ( be2 * be2 + ga2 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % RA ( p2 , p3 ) = Solver % Heat % RA ( p2 , p3 ) + Lm3 * ( be2 * be3 + ga2 * ga3 ) * CoeA & + AD3 * CoeB Solver % Heat % RA ( p3 , p1 ) = Solver % Heat % RA ( p3 , p1 ) + Lm1 * ( be3 * be1 + ga3 * ga1 ) * CoeA & + AD1 * CoeB Solver % Heat % RA ( p3 , p2 ) = Solver % Heat % RA ( p3 , p2 ) + Lm2 * ( be3 * be2 + ga3 * ga2 ) * CoeA & + AD2 * CoeB Solver % Heat % RA ( p3 , p3 ) = Solver % Heat % RA ( p3 , p1 ) + Lm3 * ( be3 * be3 + ga3 * ga3 ) * CoeA & + AD3 * CoeB end do end subroutine Calc_GM_Diffusion_Advection_TRM_F subroutine Calc_GM_Diffusion_Advection ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , p1 , p2 , p3 integer ( int32 ) :: indexes ( Solver % N % Shcoe ** 2 ) real ( real64 ) :: be1 , be2 , be3 , ga1 , ga2 , ga3 real ( real64 ) :: CoeA , Lm1 , Lm2 , Lm3 , Lm real ( real64 ) :: CoeB , u1 , u2 , u3 , v1 , v2 , v3 Solver % Heat % LHS_A % val (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) be1 = Solver % N % Basis % b ( 1 , iN ) be2 = Solver % N % Basis % b ( 2 , iN ) be3 = Solver % N % Basis % b ( 3 , iN ) ga1 = Solver % N % Basis % c ( 1 , iN ) ga2 = Solver % N % Basis % c ( 2 , iN ) ga3 = Solver % N % Basis % c ( 3 , iN ) CoeA = D4 / Solver % N % eArea ( iN ) Lm1 = Solver % Heat % Variables % lambda % pre ( p1 ) Lm2 = Solver % Heat % Variables % lambda % pre ( p2 ) Lm3 = Solver % Heat % Variables % lambda % pre ( p3 ) Lm = ( Lm1 * Lm2 * Lm3 ) ** D3 ! Lm   = (Lm1 + Lm2 + Lm3) * D3 CoeB = Solver % Heat % Constants % HeatCapacity % water * D24 u1 = Solver % Water % Variables % wFlux % x ( p1 ) u2 = Solver % Water % Variables % wFlux % x ( p2 ) u3 = Solver % Water % Variables % wFlux % x ( p3 ) v1 = Solver % Water % Variables % wFlux % y ( p1 ) v2 = Solver % Water % Variables % wFlux % y ( p2 ) v3 = Solver % Water % Variables % wFlux % y ( p3 ) ! write(*,'(6es14.5)') u1, u2, u3, v1, v2, v3 call Find_CRS_Indexes ( udmp , tmpCRS1 , p1 , p2 , p3 , indexes (:)) Solver % Heat % LHS_A % Val ( indexes ( 1 )) = Solver % Heat % LHS_A % Val ( indexes ( 1 )) + Lm * ( be1 * be1 + ga1 * ga1 ) * CoeA & + (( 2.d0 * u1 + u2 + u3 ) * be1 + ( 2.d0 * v1 + v2 + v3 ) * ga1 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 2 )) = Solver % Heat % LHS_A % Val ( indexes ( 2 )) + Lm * ( be1 * be2 + ga1 * ga2 ) * CoeA & + (( 2.d0 * u1 + u2 + u3 ) * be2 + ( 2.d0 * v1 + v2 + v3 ) * ga2 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 3 )) = Solver % Heat % LHS_A % Val ( indexes ( 3 )) + Lm * ( be1 * be3 + ga1 * ga3 ) * CoeA & + (( 2.d0 * u1 + u2 + u3 ) * be3 + ( 2.d0 * v1 + v2 + v3 ) * ga3 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 4 )) = Solver % Heat % LHS_A % Val ( indexes ( 4 )) + Lm * ( be2 * be1 + ga2 * ga1 ) * CoeA & + (( u1 + 2.d0 * u2 + u3 ) * be1 + ( v1 + 2.d0 * v2 + v3 ) * ga1 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 5 )) = Solver % Heat % LHS_A % Val ( indexes ( 5 )) + Lm * ( be2 * be2 + ga2 * ga2 ) * CoeA & + (( u1 + 2.d0 * u2 + u3 ) * be2 + ( v1 + 2.d0 * v2 + v3 ) * ga2 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 6 )) = Solver % Heat % LHS_A % Val ( indexes ( 6 )) + Lm * ( be2 * be3 + ga2 * ga3 ) * CoeA & + (( u1 + 2.d0 * u2 + u3 ) * be3 + ( v1 + 2.d0 * v2 + v3 ) * ga3 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 7 )) = Solver % Heat % LHS_A % Val ( indexes ( 7 )) + Lm * ( be3 * be1 + ga3 * ga1 ) * CoeA & + (( u1 + u2 + 2.d0 * u3 ) * be1 + ( v1 + v2 + 2.d0 * v3 ) * ga1 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 8 )) = Solver % Heat % LHS_A % Val ( indexes ( 8 )) + Lm * ( be3 * be2 + ga3 * ga2 ) * CoeA & + (( u1 + u2 + 2.d0 * u3 ) * be2 + ( v1 + v2 + 2.d0 * v3 ) * ga2 ) * CoeB Solver % Heat % LHS_A % Val ( indexes ( 9 )) = Solver % Heat % LHS_A % Val ( indexes ( 9 )) + Lm * ( be3 * be3 + ga3 * ga3 ) * CoeA & + (( u1 + u2 + 2.d0 * u3 ) * be3 + ( v1 + v2 + 2.d0 * v3 ) * ga3 ) * CoeB end do ! stop end subroutine Calc_GM_Diffusion_Advection subroutine Assemble_GM_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver if (. not . Solver % isWater ) then if ( Solver % Flags % isTRM ) then call Calc_GM_Time_TRM ( Solver ) call Calc_GM_Diffusion_TRM ( Solver ) call SpMV ( tmpCRS1 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isGCC . or . Solver % Flags % isPower ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) end if else if ( Solver % Flags % isTRM ) then call Calc_GM_Time_TRM ( Solver ) ! call Calc_GM_Time_TRM_F(Solver) call Calc_GM_Diffusion_Advection_TRM ( Solver ) ! call Calc_GM_Diffusion_TRM(Solver) call SpMV ( tmpCRS1 , Solver % T % old (:), Solver % Heat % Rhs (:)) ! print*,Solver%Heat%Rhs(:) ! stop ! Solver%Heat%RA(:,:) = Solver%Heat%RA(:,:) + tmpA(:,:) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isGCC . or . Solver % Flags % isPower ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion_Advection ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) end if end if end subroutine Assemble_GM_Heat subroutine Assemble_GM_Heat_IC ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver ! if (.not. Solver%isWater) then if ( Solver % Flags % isTRM ) then call Calc_GM_Time_TRM ( Solver ) call Calc_GM_Diffusion_TRM ( Solver ) call SpMV ( tmpCRS1 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isGCC ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) else if ( Solver % Flags % isPower ) then call Calc_GM_Time_Divide ( Solver ) call Calc_GM_Diffusion ( Solver ) call SpMV ( tmpCRS2 , Solver % T % old (:), Solver % Heat % Rhs (:)) Solver % Heat % LHS_A % val (:) = Solver % Heat % LHS_A % val (:) + tmpCRS1 % val (:) end if ! end if end subroutine Assemble_GM_Heat_IC subroutine Assemble_GM_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Calc_GM_Time_Richards ( Solver ) ! call Calc_GM_Diffusion_Richards(Solver) call Calc_GM_Diffusion_Richards_F ( Solver ) call SpMV ( tmpCRS1 , Solver % mIce % dif (:), Solver % Water % Rhs (:)) ! print *, Solver%Water%Rhs(:) Solver % Water % Rhs (:) = - 1.0d0 * Solver % Water % Rhs (:) end subroutine Assemble_GM_Water subroutine Assemble_GM_Water_IC ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Calc_GM_Diffusion_Richards_F ( Solver ) Solver % Water % Rhs (:) = 0.0d0 end subroutine Assemble_GM_Water_IC end module Matrix_Assemble","tags":"","loc":"sourcefile/assemble.f90.html"},{"title":"ConvertCRS.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~convertcrs.f90~~EfferentGraph sourcefile~convertcrs.f90 ConvertCRS.f90 sourcefile~types.f90 Types.f90 sourcefile~convertcrs.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~convertcrs.f90->sourcefile~allocate.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~allocate.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Matrix_ConvertCRS Source Code ConvertCRS.f90 Source Code module Matrix_ConvertCRS use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: Allocate implicit none private public Convert_CRS contains subroutine Convert_CRS ( Solver , A ) implicit none type ( SolverInfo ), intent ( in ) :: Solver type ( CRS ), intent ( inout ) :: A ! integer(int32)                  :: i, j, k, l, row_nnz integer ( int32 ) :: iN , iE , iT , irT , iNC , iNNZ , row_nnz integer ( int32 ) :: nElment , nTop , nNode integer ( int32 ), allocatable :: vertex (:), row (:), tmpInd (:) nElment = Solver % N % element nTop = Solver % N % ShCoe nNode = Solver % N % node ! 0オリジンでベクトルを作成 call Allocate_Vector ( A % Ptr , 0 , nNode ) call Allocate_Vector ( row , 0 , nNode - 1 ) call Allocate_Vector ( tmpInd , 0 , 8 * nNode ) call Allocate_Vector ( vertex , nTop ) A % Ptr ( 0 ) = 0 A % nnz = 0 do iN = 1 , nNode row (:) = 0 row_nnz = 0 do iE = 1 , nElment ! iE番目の要素の頂点を取得 get_element_node : & & do iT = 1 , nTop vertex ( iT ) = Solver % N % pElement ( iT , iE ) end do get_element_node ! j番目の要素の頂点のうちいずれかの頂点がiNと一致する場合，ベクトルにインクリメント increament_vector : & & do iT = 1 , nTop if ( vertex ( iT ) == iN ) then do irT = 1 , nTop row ( vertex ( irT ) - 1 ) = row ( vertex ( irT ) - 1 ) + 1 end do exit increament_vector end if end do increament_vector end do ! ベクトルの非ゼロ要素の数をカウントし，CRSの仮ポインタに格納 do iNC = 0 , nNode - 1 if ( row ( iNC ) > 0 ) then tmpInd ( row_nnz + A % nnz ) = iNC row_nnz = row_nnz + 1 end if end do A % nnz = A % nnz + row_nnz A % Ptr ( iN ) = A % nnz end do ! CRS Matrixのメモリ確保 (0オリジン) call Allocate_Vector ( A % Ind , 0 , A % nnz - 1 ) call Allocate_Vector ( A % val , 0 , A % nnz - 1 ) ! CRSの初期化及び値の格納 do iNNZ = 0 , A % nnz - 1 A % val ( iNNZ ) = 0.0d0 A % Ind ( iNNZ ) = tmpInd ( iNNZ ) end do deallocate ( vertex ) deallocate ( row ) deallocate ( tmpInd ) end subroutine Convert_CRS end module Matrix_ConvertCRS","tags":"","loc":"sourcefile/convertcrs.f90.html"},{"title":"Heat.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~heat.f90~~EfferentGraph sourcefile~heat.f90 Heat.f90 sourcefile~types.f90 Types.f90 sourcefile~heat.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~heat.f90->sourcefile~allocate_structure.f90 sourcefile~count.f90 Count.f90 sourcefile~heat.f90->sourcefile~count.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~heat.f90->sourcefile~allocate.f90 sourcefile~hcf.f90 HCF.f90 sourcefile~heat.f90->sourcefile~hcf.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~error.f90 error.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~count.f90->sourcefile~types.f90 sourcefile~count.f90->sourcefile~error.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~hcf.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Main_Heat Source Code Heat.f90 Source Code module Main_Heat use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: Inout_Input use :: allocate use :: Allocate_Structure , only : Allocate_DP2d use :: Calculate_HCF implicit none private integer ( int32 ), parameter :: Calc_Heat = 1 public :: Heat type Heat type ( Geometry_2D ) :: Geometry type ( Boudary_Condition ) :: BC type ( HCF ) :: HCFs ! integer(int32)              :: Num_Elements, Num_Nodes, Num_Shape, Num_Dimention, Num_Shape_Type, Num_Region ! integer(int32), allocatable :: Element(:,:) ! integer(int32), allocatable :: Element_Region(:), COO_Region(:) ! type(DP2d)                  :: Nodes_2D ! real(real64),   allocatable :: Area(:) ! type(Shape)                 :: Shape_Function contains end type Heat interface Heat module procedure Heat_Constructor end interface contains type ( Heat ) function Heat_Constructor ( Structure_Input ) type ( Input ), intent ( in ) :: Structure_Input call Set_Geometory_Infomation ( Heat_Constructor , Structure_Input ) call Set_Boundary_Condition_Infomations ( Heat_Constructor , Structure_Input ) block real ( real64 ) :: array_HCF ( 9 ) array_HCF = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] print * , array_HCF Heat_Constructor % HCFs = HCF ( array_HCF , 5 , 2 ) end block end function Heat_Constructor subroutine Set_Geometory_Infomation ( self , Structure_Input ) type ( Heat ), intent ( inout ) :: self type ( Input ), intent ( in ) :: Structure_Input self % Geometry % Num_Elements = Structure_Input % Input_Get_Elements () self % Geometry % Num_Nodes = Structure_Input % Input_Get_Nodes () self % Geometry % Num_Shape = Structure_Input % Input_Get_Shape () self % Geometry % Num_Dimention = Structure_Input % Input_Get_Dimemsion () self % Geometry % Num_Region = Structure_Input % Input_Get_Region () self % Geometry % Num_Shape_Type = self % Geometry % Num_Shape * self % Geometry % Num_Dimention self % Geometry % Element = Structure_Input % Input_Get_Top () self % Geometry % Element_Region = Structure_Input % Input_Get_Top_Region () self % Geometry % Nodes_2D = Structure_Input % Input_Get_Coordinates () self % Geometry % COO_Region = Structure_Input % Input_Get_Coordinates_Region () end subroutine Set_Geometory_Infomation subroutine Set_Boundary_Condition_Infomations ( self , Structure_Input ) use :: Calculate_Count , only : Count_if implicit none type ( Heat ), intent ( inout ) :: self type ( Input ), intent ( in ) :: Structure_Input integer ( int32 ) :: Count_Heat integer ( int32 ) :: iBC , Counter integer ( int32 ), allocatable :: Work_Node (:), Work_Edge (:, :), Work_Type (:), Work_Value_Info (:, :) real ( real64 ), allocatable :: Work_Value (:) Work_Node = Structure_Input % Input_Get_BC_Node () Work_Type = Structure_Input % Input_Get_BC_Node_Type () Work_Value_Info = Structure_Input % Input_Get_BC_Node_Value_Info () Work_Value = Structure_Input % Input_Get_BC_Node_Value ( Calc_Heat ) self % BC % Dirichlet % Num_Type = Count_if ( Work_Value_Info (:, 2 ), Condition_Heat ) call Allocate_Vector ( self % BC % Dirichlet % Value_Info , self % BC % Dirichlet % Num_Type ) call Allocate_Vector ( self % BC % Dirichlet % value , self % BC % Dirichlet % Num_Type ) Counter = 0 do iBC = 1 , size ( Work_Value_Info (:, 2 )) if ( Condition_Heat ( Work_Value_Info ( iBC , 2 ))) then Counter = Counter + 1 self % BC % Dirichlet % Value_Info ( Counter ) = Work_Value_Info ( iBC , 1 ) self % BC % Dirichlet % value ( Counter ) = Work_Value ( iBC ) end if end do self % BC % Dirichlet % Num_Node = Count_if ( Work_Type (:), Condition_In_BoundaryCondition , self % BC % Dirichlet % Value_Info (:)) call Allocate_Vector ( self % BC % Dirichlet % Node , self % BC % Dirichlet % Num_Node ) call Allocate_Vector ( self % BC % Dirichlet % Node_Type , self % BC % Dirichlet % Num_Node ) Counter = 0 do iBC = 1 , size ( Work_Type ) if ( Condition_In_BoundaryCondition ( Work_Type ( iBC ), self % BC % Dirichlet % Value_Info (:))) then Counter = Counter + 1 self % BC % Dirichlet % Node ( Counter ) = Work_Node ( iBC ) self % BC % Dirichlet % Node_Type ( Counter ) = Work_Type ( iBC ) end if end do if ( allocated ( Work_Node )) deallocate ( Work_Node ) if ( allocated ( Work_Type )) deallocate ( Work_Type ) if ( allocated ( Work_Value_Info )) deallocate ( Work_Value_Info ) if ( allocated ( Work_Value )) deallocate ( Work_Value ) self % BC % Neumann % Edge = Structure_Input % Input_Get_BC_Edge () self % BC % Neumann % Edge_Type = Structure_Input % Input_Get_BC_Edge_Type () end subroutine Set_Boundary_Condition_Infomations logical function Condition_Heat ( num ) implicit none integer ( int32 ), intent ( in ) :: num if ( mod ( num , 8 ) >= 4 ) then Condition_Heat = . true . else Condition_Heat = . false . end if end function Condition_Heat logical function Condition_In_BoundaryCondition ( num , Value_Info ) implicit none integer ( int32 ), intent ( in ) :: num integer ( int32 ), intent ( in ) :: Value_Info (:) ! 配列を引数として受け取る integer :: i logical :: found found = . false . do i = 1 , size ( Value_Info ) if ( num == Value_Info ( i )) then found = . true . exit end if end do Condition_In_BoundaryCondition = found end function Condition_In_BoundaryCondition end module Main_Heat","tags":"","loc":"sourcefile/heat.f90.html"},{"title":"Stdout.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~stdout.f90~~EfferentGraph sourcefile~stdout.f90 Stdout.f90 sourcefile~types.f90 Types.f90 sourcefile~stdout.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Inout_Stdout Source Code Stdout.f90 Source Code module Inout_Stdout use omp_lib use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none private public :: init_omp_config contains subroutine init_omp_config ( Solver ) type ( SolverInfo ), intent ( inout ) :: Solver ! OpenMPの設定 ! call omp_set_dynamic(TRUE) call omp_set_max_active_levels ( 1 ) if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '' if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) 'OpenMP Properties' if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '-------------------------------------' if ( Solver % Flags % isStdOut ) write ( * , '(a,i0)' ) 'Max number of threads           = ' , omp_get_max_threads () if ( Solver % Flags % isStdOut ) write ( * , '(a,i0)' ) 'Number of processors availables = ' , omp_get_num_procs () if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '-------------------------------------' if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) '' end subroutine init_omp_config end module Inout_Stdout","tags":"","loc":"sourcefile/stdout.f90.html"},{"title":"Output.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~output.f90~~EfferentGraph sourcefile~output.f90 Output.f90 sourcefile~setprojectpath.f90 SetProjectPath.f90 sourcefile~output.f90->sourcefile~setprojectpath.f90 sourcefile~types.f90 Types.f90 sourcefile~output.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~output.f90->sourcefile~allocate.f90 sourcefile~error.f90 error.f90 sourcefile~output.f90->sourcefile~error.f90 sourcefile~setprojectpath.f90->sourcefile~error.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Inout_Output Source Code Output.f90 Source Code module Inout_Output use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Inout_SetProjectPath , only : GetProjectPath => Inout_SetProjectPath_GetProjectPath use :: error use :: allocate use :: Inout_Input use :: types implicit none private type :: Output private integer ( int32 ), allocatable :: Output_Observation_Flag (:) character ( 256 ) :: T_FileName , Fr_FileName , TC_FileName , C_FileName , P_FileName , Flux_FileName , K_FileName character ( 256 ) :: dir_Path logical , allocatable :: is_Output (:) logical :: is_Output_Dat , is_Output_VTK contains ! procedure :: Output_All         => Inout_Output_All_vtk procedure :: Output_All => Inout_Output_All procedure :: Output_Observation => Inout_Output_Observation end type Output interface Output module procedure Output_Constructor end interface public :: Output contains type ( Output ) function Output_Constructor ( Inputs ) implicit none type ( Input ), intent ( in ) :: Inputs integer ( int32 ) :: Flag_Size integer ( int32 ), allocatable :: Output_Observation_Flag (:) ! character(256) :: dir_Path integer :: i integer ( int32 ) :: Output_File_Type ! Path settings Output_Constructor % dir_Path = GetProjectPath () Output_File_Type = Inputs % Input_Get_Output_File () if ( Output_File_Type == 1 ) then Output_Constructor % is_Output_Dat = . true . Output_Constructor % is_Output_VTK = . false . else if ( Output_File_Type == 2 ) then Output_Constructor % is_Output_Dat = . false . Output_Constructor % is_Output_VTK = . true . end if Output_Constructor % T_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_T.dat\" Output_Constructor % Fr_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_Fr.dat\" Output_Constructor % TC_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_TC.dat\" Output_Constructor % C_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_C.dat\" Output_Constructor % P_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_P.dat\" Output_Constructor % Flux_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_Flux.dat\" Output_Constructor % K_FileName = trim ( Output_Constructor % dir_Path ) // \"Output/obsf_K.dat\" Output_Observation_Flag = Inputs % Input_Get_Observation_Flag () Flag_Size = size ( Output_Observation_Flag ) call Allocate_Vector ( Output_Constructor % is_Output , Flag_Size ) do i = 1 , Flag_Size call Set_Output_Flag ( Output_Observation_Flag ( i ), Output_Constructor % is_Output ( i )) end do if ( allocated ( Output_Observation_Flag )) deallocate ( Output_Observation_Flag ) end function Output_Constructor subroutine Inout_Output_All ( self , Solver , num ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: num if ( self % is_Output_Dat ) call Inout_Output_All_Dat ( self , Solver , num ) if ( self % is_Output_VTK ) call Inout_Output_All_vtk ( self , Solver , num ) end subroutine Inout_Output_All subroutine Inout_Output_All_Dat ( self , Solver , num ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: num character ( 256 ) :: oName , fmt integer ( int32 ) :: ios , unit_num , iN write ( oName , Solver % fmt_Fileout ) trim ( self % dir_Path ), \"Output/DATFILE/Output_\" , num , \".dat\" open ( newunit = unit_num , file = oName , status = 'replace' , action = 'write' , iostat = ios ) if ( ios /= 0 ) call error_message ( 931 ) select case ( Solver % nAnalysis ) case ( 1 ) ! do iN = 1, Solver%N%node !     write(unit_num, '(es15.7,a,es15.7)') Solver%T%pre(iN), ', ', Solver%T%Si(iN) ! end do case ( 2 ) case ( 3 ) case ( 4 ) fmt = '(2es13.5,2es13.5)' do iN = 1 , Solver % N % node write ( unit_num , fmt ) Solver % N % vCood % x ( iN ), Solver % N % vCood % y ( iN ), Solver % T % pre ( iN ), Solver % Si % pre ( iN ) end do case ( 5 ) case ( 6 ) fmt = '(2es13.5,5es13.5)' do iN = 1 , Solver % N % node write ( unit_num , fmt ) Solver % N % vCood % x ( iN ), Solver % N % vCood % y ( iN ), Solver % T % pre ( iN ), Solver % P % pre ( iN ), Solver % Si % pre ( iN ), Solver % Water % Variables % wFlux % x ( iN ), + Solver % Water % Variables % wFlux % y ( iN ) end do case ( 7 ) end select close ( unit_num ) end subroutine Inout_Output_All_Dat subroutine Inout_Output_Observation ( self , Solver , time ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ), intent ( in ) :: time integer ( int32 ) :: unit_num , ios , iObs , nObs , iS , dim real ( real64 ) :: obsValue ( Solver % Obs % nObs ), obsValue2d ( 2 * Solver % Obs % nObs ) real ( real64 ) :: tmpValue character ( 64 ) :: ofmt nObs = Solver % Obs % nObs if ( Solver % Flags % outOBS ( 1 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % T_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % T_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % T % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % T % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 2 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % Fr_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % Fr_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Si % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Si % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 3 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , 2 * nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % TC_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % TC_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Heat % Variables % Tgrad % x ( Solver % Obs % obsPoint ( iObs )), Solver % Heat % Variables % Tgrad % y ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + ( Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Heat % Variables % Tgrad % x ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs )))) ** 2 ! tmpValue = tmpValue + sqrt((Solver%Obs%vAreaObs(iS, iObs) * Solver%Heat%Variables%Tgrad%x(Solver%N%pElement(iS, Solver%Obs%nAreaObs(iObs))))**2+(Solver%Obs%vAreaObs(iS, iObs) * Solver%Heat%Variables%Tgrad%y(Solver%N%pElement(iS, Solver%Obs%nAreaObs(iObs))))**2) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 4 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % C_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % C_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Flags % isTRM ) then if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Heat % Variables % Cp % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Heat % Variables % Cp % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if else if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Heat % Variables % Ca % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Heat % Variables % Ca % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 5 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % P_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % P_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % P % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % P % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 6 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , 2 * nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % Flux_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % Flux_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Water % Variables % wFlux % x ( Solver % Obs % obsPoint ( iObs )), Solver % Water % Variables % wFlux % y ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs do dim = 1 , 2 if ( dim == 1 ) then tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Water % Variables % wFlux % x ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do else do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Water % Variables % wFlux % y ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do end if obsValue ( 2 * ( iObs - 1 ) + dim ) = tmpValue end do end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , 2 * nObs ) end if close ( unit_num ) end if if ( Solver % Flags % outOBS ( 7 )) then write ( ofmt , '(a, i0, a)' ) '(es15.7,' , nObs , 'es16.8)' if ( time == 0.0d0 ) then open ( newunit = unit_num , file = self % K_FileName , status = 'replace' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) else open ( newunit = unit_num , file = self % K_FileName , status = 'old' , action = 'write' , form = 'formatted' , position = 'append' , iostat = ios ) end if if ( Solver % Obs % nObsType == 1 ) then write ( unit_num , ofmt ) time , ( Solver % Water % Variables % Klh % pre ( Solver % Obs % obsPoint ( iObs )), iObs = 1 , nObs ) else if ( Solver % Obs % nObsType == 2 ) then do iObs = 1 , nObs tmpValue = 0.0d0 do iS = 1 , Solver % N % Shcoe tmpValue = tmpValue + Solver % Obs % vAreaObs ( iS , iObs ) * Solver % Water % Variables % Klh % pre ( Solver % N % pElement ( iS , Solver % Obs % nAreaObs ( iObs ))) end do obsValue ( iObs ) = tmpValue end do write ( unit_num , ofmt ) time , ( obsValue ( iObs ), iObs = 1 , nObs ) end if close ( unit_num ) end if end subroutine Inout_Output_Observation ! subroutine Output_time(ar_secsum, ttime, dxmin, dt, tmax, nSType, nLFType) !     implicit none !     real(real64), intent(in) :: ar_secsum(:), ttime, dxmin, dt, tmax !     integer(int32), intent(in) :: nSType, nLFType !     integer(int32) :: ios, tdata(8) !     character(len=100) :: oPath, oName !     character(len=12) :: real_clock(3) !     character(len=5) :: SType, LFType !     call date_and_time(real_clock(1), real_clock(2), real_clock(3), tdata) !     if (nSType == 1) then !     SType = \"LU\" !     else if (nSType == 2) then !     SType = \"GE\" !     else if (nSType == 3) then !     SType = \"CG\" !     else !     SType= \"ELSE\" !     end if !     if (nLFType == 1) then !     LFType = \"TRM\" !     else if (nLFType == 2) then !     LFType = \"ASBM\" !     else !     LFType = \"ELSE\" !     end if !     call get_path(oPath) !     ! write(oName, '(a,f6.4,a,f4.1,a,f3.1,5a)') trim(oPath) // 'Output/TIME/' // 'Time_', dxmin, 'm_', dt, 's_', tmax/86400, 'day_',& !     ! & trim(SType),'_', trim(LFType), '.dat' !     ! print*, trim(oName) !     oName = trim(oPath) // 'Output/TIME/time.dat' !     open(100, file = oName, status='replace', action=\"write\", iostat=ios) !     if (ios /= 0) call error_message(931) !     write(100,'(a,i4.4,a,i2.2,a,i2.2,a,i2.2,a,i2.2,a,i2.2)') 'Date : ', tdata(1), '/', tdata(2), '/', tdata(3), '   Time : ',& !     & tdata(5), ':', tdata(6), ':', tdata(7) !     write(100,'(a)') '--------------------------------------------------' !     write(100,'(a,f6.4,a)') 'Minimum Distance  : ', dxmin, 'm' !     write(100,'(a,f6.2,a)') 'Initial time step : ', dt, 's' !     write(100,'(a,i0,a)')   'Termination time  : ', nint(tmax), 's' !     write(100,'(a)') '--------------------------------------------------' !     write(100,'(a,f13.5,a)') 'Total time      :', ttime, 's' !     write(100,'(a,f13.5,a)') 'Assemble Section:', ar_secsum(1), 's' !     write(100,'(a,f13.5,a)') 'Matrix Calculate:', ar_secsum(2), 's' !     write(100,'(a,f13.5,a)') 'Solve linear Eq.:', ar_secsum(3), 's' !     write(100,'(a,f13.5,a)') 'Latent Heat Clac:', ar_secsum(4), 's' !     write(100,'(a)', advance='no') '--------------------------------------------------' !     close(100) !     return ! end subroutine Output_time subroutine Inout_Output_All_vtk ( self , Solver , num ) implicit none class ( Output ) :: self type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: num character ( 256 ) :: oName , fmt integer ( int32 ) :: ios , unit_num , iN real ( real64 ) :: wFlux_all ( 3 , Solver % N % node ) write ( oName , Solver % fmt_Fileout ) trim ( self % dir_Path ), \"Output/DATFILE/Output_\" , num , \".vtk\" open ( newunit = unit_num , file = oName , status = 'replace' , action = 'write' , iostat = ios ) if ( ios /= 0 ) call error_message ( 931 ) write ( unit_num , '(a)' ) \"# vtk DataFile Version 2.0\" write ( unit_num , '(a)' ) \"Analysis ASCII VTK file\" write ( unit_num , '(a)' ) \"ASCII\" write ( unit_num , '(a)' ) \"DATASET UNSTRUCTURED_GRID\" write ( unit_num , '(a,i0,a)' ) \"POINTS \" , Solver % N % node , \" double\" do iN = 1 , Solver % N % node write ( unit_num , '(3f18.13)' ) Solver % N % vCood % x ( iN ), Solver % N % vCood % y ( iN ), 0 end do write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a,i0,a,i0,a)' ) \"CELLS \" , Solver % N % element , \" \" , Solver % N % element * 4 do iN = 1 , Solver % N % element write ( unit_num , '(i0,a,i0,a,i0,a,i0)' ) Solver % N % ShCoe , \" \" , Solver % N % pElement ( 1 , iN ) - 1 , \" \" , Solver % N % pElement ( 2 , iN ) - 1 , \" \" , Solver % N % pElement ( 3 , iN ) - 1 end do write ( unit_num , '(a,i0,a)' ) \"CELL_TYPES \" , Solver % N % element do iN = 1 , Solver % N % element write ( unit_num , '(i0)' ) 5 end do select case ( Solver % nAnalysis ) case ( 1 ) ! do iN = 1, Solver%N%node !     write(unit_num, '(es15.7,a,es15.7)') Solver%T%pre(iN), ', ', Solver%T%Si(iN) ! end do case ( 2 ) case ( 3 ) case ( 4 ) write ( unit_num , '(a, i0)' ) \"POINT_DATA \" , Solver % N % node write ( unit_num , '(a)' ) \"SCALARS Temperature double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % T % pre (:) write ( unit_num , '(a)' ) \"SCALARS Pressure double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % P % pre (:) write ( unit_num , '(a)' ) \"SCALARS Si double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % Si % pre (:) case ( 6 ) wFlux_all ( 1 , :) = Solver % Water % Variables % wFlux % x (:) wFlux_all ( 2 , :) = Solver % Water % Variables % wFlux % y (:) wFlux_all ( 3 , :) = 0.0d0 write ( unit_num , '(a, i0)' ) \"POINT_DATA \" , Solver % N % node write ( unit_num , '(a)' ) \"SCALARS Temperature double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % T % pre (:) write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a)' ) \"SCALARS Pressure double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % P % pre (:) write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a)' ) \"SCALARS Si double 1\" write ( unit_num , '(a)' ) \"LOOKUP_TABLE default\" write ( unit_num , '(es13.5)' ) Solver % Si % pre (:) write ( unit_num , '(a)' ) \"\" write ( unit_num , '(a)' ) \"VECTORS WaterFlux double\" write ( unit_num , '(3es13.5)' ) wFlux_all case ( 7 ) end select close ( unit_num ) end subroutine Inout_Output_All_vtk ! subroutine Measure_Time(nsec, ar_sec, ar_secsum) !     implicit none !     integer(int32), intent(in) :: nsec !     real(real64), intent(inout) :: ar_sec(:), ar_secsum(:) !     ar_sec(nsec+1) = omp_get_wtime() !     ar_secsum(nsec) = ar_secsum(nsec) + ar_sec(nsec+1) - ar_sec(nsec) !     return ! end subroutine Measure_Time subroutine Set_Output_Flag ( iValue , inFlag ) implicit none integer ( int32 ), intent ( in ) :: iValue logical , intent ( inout ) :: inFlag if ( iValue == 1 ) then inFlag = . true . else inFlag = . false . end if end subroutine Set_Output_Flag end module Inout_Output","tags":"","loc":"sourcefile/output.f90.html"},{"title":"SetProjectPath.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~setprojectpath.f90~~EfferentGraph sourcefile~setprojectpath.f90 SetProjectPath.f90 sourcefile~error.f90 error.f90 sourcefile~setprojectpath.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~setprojectpath.f90~~AfferentGraph sourcefile~setprojectpath.f90 SetProjectPath.f90 sourcefile~output.f90 Output.f90 sourcefile~output.f90->sourcefile~setprojectpath.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Inout_SetProjectPath Source Code SetProjectPath.f90 Source Code module Inout_SetProjectPath use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: error implicit none private character ( 256 ) :: ProjectPath logical :: isSetProjectPath = . false . public :: Inout_SetProjectPath_GetProjectPath contains subroutine Inout_SetProjectPath_SetProjectPath implicit none character ( 64 ), parameter :: dName = \"ProjectPath.dir\" integer ( int32 ) :: access , status , len_path , unit_num integer :: i status = access ( dName , \"r\" ) if ( status /= 0 ) call error_message ( 901 , opt_file_name = dName ) open ( newunit = unit_num , file = dName , iostat = status , status = \"old\" ) if ( status /= 0 ) call error_message ( 902 , opt_file_name = dName ) read ( unit_num , '(a)' ) ProjectPath close ( unit_num ) len_path = len_trim ( ProjectPath ) ProjectPath = trim ( adjustl ( ProjectPath )) ! For windows, replace \"\\\\\" with \"/\" i = index ( ProjectPath , \"\\\\\" ) do while ( i > 0 ) ProjectPath ( i : i + 1 ) = \"/\" if ( i + 2 <= len_path ) then ProjectPath ( i + 1 :) = ProjectPath ( i + 2 :) // \" \" end if len_path = len_path - 1 i = index ( ProjectPath , \"\\\\\" ) end do ! For UNIX, replace \"\\\" with \"/\" i = index ( ProjectPath , \"\\\") do while (i > 0) ProjectPath(i:i) = \" / \" len_path = len_trim(ProjectPath) i = index(ProjectPath, \" \\ \") end do ! Add \" / \" to end to path if (len_path > 0 .and. ProjectPath(len_path:len_path) /= \" / \") then ProjectPath = trim(adjustl(ProjectPath))//\" / \" end if isSetProjectPath = . true . end subroutine Inout_SetProjectPath_SetProjectPath character ( 256 ) function Inout_SetProjectPath_GetProjectPath () implicit none if (. not . isSetProjectPath ) call Inout_SetProjectPath_SetProjectPath Inout_SetProjectPath_GetProjectPath = ProjectPath end function Inout_SetProjectPath_GetProjectPath end module Inout_SetProjectPath","tags":"","loc":"sourcefile/setprojectpath.f90.html"},{"title":"Area.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~area.f90~~EfferentGraph sourcefile~area.f90 Area.f90 sourcefile~types.f90 Types.f90 sourcefile~area.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~area.f90->sourcefile~error.f90 sourcefile~points.f90 Points.f90 sourcefile~area.f90->sourcefile~points.f90 sourcefile~points.f90->sourcefile~types.f90 sourcefile~points.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_Area Source Code Area.f90 Source Code module Calculate_Area use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: error use :: Calculate_Points , only : Set_Point implicit none interface Calc_Area procedure :: Calc_Area_31 end interface contains subroutine Calc_Area_31 ( Geometry ) implicit none type ( Geometry2d ), intent ( inout ) :: Geometry type ( Vector2d ) :: p1 , p2 , p3 integer ( int32 ) :: elem do elem = 1 , Geometry % element call set_point ( Geometry , elem , p1 , p2 , p3 ) if ( elem < 1 . or . elem > Geometry % element ) then call error_message ( 932 ) else Geometry % eArea ( elem ) = abs (( p2 % x - p1 % x ) * ( p3 % y - p1 % y ) - ( p2 % y - p1 % y ) * ( p3 % x - p1 % x )) / 2.d0 end if end do end subroutine Calc_Area_31 end module Calculate_Area","tags":"","loc":"sourcefile/area.f90.html"},{"title":"Points.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~points.f90~~EfferentGraph sourcefile~points.f90 Points.f90 sourcefile~types.f90 Types.f90 sourcefile~points.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~points.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~points.f90~~AfferentGraph sourcefile~points.f90 Points.f90 sourcefile~area.f90 Area.f90 sourcefile~area.f90->sourcefile~points.f90 sourcefile~observation.f90 Observation.f90 sourcefile~observation.f90->sourcefile~points.f90 sourcefile~shape.f90 Shape.f90 sourcefile~shape.f90->sourcefile~points.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_Points Source Code Points.f90 Source Code module Calculate_Points use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: error implicit none private interface Set_Point procedure :: Set_Point_31 end interface public :: Set_Point contains subroutine Set_Point_31 ( Geometry , triangle_index , p1 , p2 , p3 ) implicit none type ( Geometry2d ), intent ( in ) :: Geometry integer ( int32 ), intent ( in ) :: triangle_index type ( Vector2d ), intent ( inout ) :: p1 , p2 , p3 p1 % x = Geometry % vCood % x ( Geometry % pElement ( 1 , triangle_index )) p2 % x = Geometry % vCood % x ( Geometry % pElement ( 2 , triangle_index )) p3 % x = Geometry % vCood % x ( Geometry % pElement ( 3 , triangle_index )) p1 % y = Geometry % vCood % y ( Geometry % pElement ( 1 , triangle_index )) p2 % y = Geometry % vCood % y ( Geometry % pElement ( 2 , triangle_index )) p3 % y = Geometry % vCood % y ( Geometry % pElement ( 3 , triangle_index )) if ( p1 % x == p2 % x . and . p1 % y == p2 % y . or . & & p1 % x == p3 % x . and . p1 % y == p3 % y . or . & & p2 % x == p3 % x . and . p2 % y == p3 % y ) then call error_message ( 928 ) end if end subroutine Set_Point_31 end module Calculate_Points","tags":"","loc":"sourcefile/points.f90.html"},{"title":"HCF.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~hcf.f90~~EfferentGraph sourcefile~hcf.f90 HCF.f90 sourcefile~types.f90 Types.f90 sourcefile~hcf.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~hcf.f90~~AfferentGraph sourcefile~hcf.f90 HCF.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~hcf.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_HCF Source Code HCF.f90 Source Code module Calculate_HCF use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none type , extends ( HCF_Parameters ) :: HCF private procedure ( Calculation_HCF ), pointer , nopass :: Calculate_HCF => null () procedure ( Calculation_HCF_mu ), pointer , nopass :: Calculate_HCF_mu => null () contains procedure :: Calculate_Kflh => Calculate_Ks end type HCF interface HCF module procedure HCF_Constructor end interface abstract interface function Calculation_HCF ( Instance_HCF , h ) result ( kr ) use , intrinsic :: iso_fortran_env , only : real64 import :: HCF implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr end function Calculation_HCF end interface abstract interface function Calculation_HCF_mu ( T ) result ( mu ) use , intrinsic :: iso_fortran_env , only : real64 import :: HCF implicit none real ( real64 ), intent ( in ) :: T real ( real64 ) :: mu end function Calculation_HCF_mu end interface contains type ( HCF ) function HCF_Constructor ( in_HCF_Parameters , HCF_Model_id , Kflh_Model_id ) implicit none real ( real64 ), intent ( in ) :: in_HCF_Parameters (:) integer ( int32 ), intent ( in ) :: HCF_Model_id , Kflh_Model_id real ( real64 ), parameter :: Tcrit = 1 5.0d0 select case ( HCF_Model_id ) case ( 1 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % Ks = in_HCF_Parameters ( 5 ) HCF_Constructor % l = in_HCF_Parameters ( 6 ) HCF_Constructor % Calculate_HCF => Calculate_HCF_BC case ( 2 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % Ks = in_HCF_Parameters ( 5 ) HCF_Constructor % l = in_HCF_Parameters ( 6 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % Calculate_HCF => Calculate_HCF_VG case ( 3 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % Ks = in_HCF_Parameters ( 5 ) HCF_Constructor % l = in_HCF_Parameters ( 6 ) HCF_Constructor % Calculate_HCF => Calculate_HCF_KO case ( 4 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % hcrit = in_HCF_Parameters ( 5 ) HCF_Constructor % Ks = in_HCF_Parameters ( 6 ) HCF_Constructor % l = in_HCF_Parameters ( 7 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % Calculate_HCF => Calculate_HCF_MVG case ( 5 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % alpha2 = in_HCF_Parameters ( 5 ) HCF_Constructor % n2 = in_HCF_Parameters ( 6 ) HCF_Constructor % w1 = in_HCF_Parameters ( 7 ) HCF_Constructor % Ks = in_HCF_Parameters ( 8 ) HCF_Constructor % l = in_HCF_Parameters ( 9 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % m2 = 1.0d0 - 1.0d0 / HCF_Constructor % n2 HCF_Constructor % w2 = 1.0d0 - HCF_Constructor % w1 HCF_Constructor % Calculate_HCF => Calculate_HCF_Durner case ( 6 ) HCF_Constructor % thetaS = in_HCF_Parameters ( 1 ) HCF_Constructor % thetaR = in_HCF_Parameters ( 2 ) HCF_Constructor % alpha1 = in_HCF_Parameters ( 3 ) HCF_Constructor % n1 = in_HCF_Parameters ( 4 ) HCF_Constructor % n2 = in_HCF_Parameters ( 5 ) HCF_Constructor % w1 = in_HCF_Parameters ( 6 ) HCF_Constructor % Ks = in_HCF_Parameters ( 7 ) HCF_Constructor % l = in_HCF_Parameters ( 8 ) HCF_Constructor % m1 = 1.0d0 - 1.0d0 / HCF_Constructor % n1 HCF_Constructor % m2 = 1.0d0 - 1.0d0 / HCF_Constructor % n2 HCF_Constructor % w2 = 1.0d0 - HCF_Constructor % w1 HCF_Constructor % Calculate_HCF => Calculate_HCF_DVGCH end select select case ( Kflh_Model_id ) case ( 3 , 5 ) HCF_Constructor % Calculate_HCF_mu => Calc_HCF_mu_Exponential HCF_Constructor % kzero = HCF_Constructor % Ks / HCF_Constructor % Calculate_HCF_mu ( Tcrit ) case ( 6 , 7 ) HCF_Constructor % Calculate_HCF_mu => Calc_HCF_mu_Exponential_Supercooled HCF_Constructor % kzero = HCF_Constructor % Ks / HCF_Constructor % Calculate_HCF_mu ( Tcrit ) end select end function HCF_Constructor function Calculate_Ks ( Instance_HCF , h ) result ( kr ) implicit none class ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr ! select case (Instance_HCF%Ks) ! case (1) !     kr = Calculate_HCF_BC(Instance_HCF, h) ! case (2) !     kr = Calculate_HCF_VG(Instance_HCF, h) ! case (3) !     kr = Calculate_HCF_KO(Instance_HCF, h) ! case (4) !     kr = Calculate_HCF_MVG(Instance_HCF, h) ! case (5) !     kr = Calculate_HCF_Durner(Instance_HCF, h) ! case (6) !     kr = Calculate_HCF_DVGCH(Instance_HCF, h) ! end select kr = 1.0d0 end function Calculate_Ks function Calculate_HCF_BC ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw if ( h < - 1.0d0 / Instance_HCF % alpha1 ) then Sw = abs ( Instance_HCF % alpha1 * h ) ** ( - Instance_HCF % n1 ) else Sw = 1.0d0 end if kr = Sw ** ( 2.0d0 / ( Instance_HCF % n1 + Instance_HCF % l + 2.0d0 )) end function Calculate_HCF_BC function Calculate_HCF_VG ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw if ( h < 0 ) then Sw = ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) else Sw = 1.0d0 end if kr = Sw ** Instance_HCF % l * ( 1.0d0 - ( 1.0d0 - Sw ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) ** 2.0d0 end function Calculate_HCF_VG function Calculate_HCF_KO ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw if ( h < 0 ) then Sw = 0.5d0 * erfc ( log ( h / Instance_HCF % alpha1 ) / ( Instance_HCF % n1 * sqrt ( 2.0d0 ))) kr = Sw ** 0.5d0 * ( 0.5d0 * erfc ( log ( h / Instance_HCF % alpha1 ) / ( Instance_HCF % n1 * sqrt ( 2.0d0 )) + Instance_HCF % n1 / sqrt ( 2.0d0 ))) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_KO function Calculate_HCF_MVG ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw , thetaM thetaM = Instance_HCF % thetaR + ( Instance_HCF % thetaS - Instance_HCF % thetaR ) * ( 1.0d0 + abs ( Instance_HCF % alpha1 * Instance_HCF % hcrit ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) if ( h < Instance_HCF % hcrit ) then Sw = ( Instance_HCF % thetaS - Instance_HCF % thetaR ) / ( thetaM - Instance_HCF % thetaR ) * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) kr = Sw ** Instance_HCF % l * (( 1.0d0 - ( 1.0d0 - Sw ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) / ( 1.0d0 - ( 1.0d0 - 1.0d0 ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 )) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_MVG function Calculate_HCF_Durner ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw1 , Sw2 if ( h < 0 ) then Sw1 = Instance_HCF % w1 * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) Sw2 = Instance_HCF % w2 * ( 1.0d0 + abs ( Instance_HCF % alpha2 * h ) ** Instance_HCF % n2 ) ** ( - Instance_HCF % m2 ) kr = ( Instance_HCF % w1 * Sw1 + Instance_HCF % w2 * Sw2 ) ** Instance_HCF % l & * ( Instance_HCF % w1 * Instance_HCF % alpha1 * ( 1.0d0 - ( 1.0d0 - Sw1 ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) & + Instance_HCF % w2 * Instance_HCF % alpha2 * ( 1.0d0 - ( 1.0d0 - Sw2 ** ( 1.0d0 / Instance_HCF % m2 )) ** Instance_HCF % m2 )) ** 2.0d0 & / ( Instance_HCF % w1 * Instance_HCF % alpha1 + Instance_HCF % w2 * Instance_HCF % alpha2 ) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_Durner function Calculate_HCF_DVGCH ( Instance_HCF , h ) result ( kr ) implicit none type ( HCF ), intent ( in ) :: Instance_HCF real ( real64 ), intent ( in ) :: h real ( real64 ) :: kr real ( real64 ) :: Sw1 , Sw2 if ( h < 0 ) then Sw1 = Instance_HCF % w1 * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n1 ) ** ( - Instance_HCF % m1 ) Sw2 = Instance_HCF % w2 * ( 1.0d0 + abs ( Instance_HCF % alpha1 * h ) ** Instance_HCF % n2 ) ** ( - Instance_HCF % m2 ) kr = ( Instance_HCF % w1 * Sw1 + Instance_HCF % w2 * Sw2 ) ** Instance_HCF % l & * ( Instance_HCF % w1 * Instance_HCF % alpha1 * ( 1.0d0 - ( 1.0d0 - Sw1 ** ( 1.0d0 / Instance_HCF % m1 )) ** Instance_HCF % m1 ) & + Instance_HCF % w2 * Instance_HCF % alpha1 * ( 1.0d0 - ( 1.0d0 - Sw2 ** ( 1.0d0 / Instance_HCF % m2 )) ** Instance_HCF % m2 )) ** 2.0d0 & / ( Instance_HCF % w1 * Instance_HCF % alpha1 + Instance_HCF % w2 * Instance_HCF % alpha2 ) ** 2.0d0 else kr = 1.0d0 end if end function Calculate_HCF_DVGCH function Calc_HCF_mu_Exponential ( T ) result ( mu ) implicit none real ( real64 ), intent ( in ) :: T real ( real64 ) :: mu mu = 2.1d-6 * exp ( 180 8.5d0 / ( T + 27 3.15d0 )) end function Calc_HCF_mu_Exponential function Calc_HCF_mu_Exponential_Supercooled ( T ) result ( mu ) implicit none real ( real64 ), intent ( in ) :: T real ( real64 ) :: mu mu = 1.3788d-4 * (( 27 3.15d0 + T ) / 22 5.66d0 - 1.0d0 ) ** ( - 1.6438 ) end function Calc_HCF_mu_Exponential_Supercooled end module Calculate_HCF","tags":"","loc":"sourcefile/hcf.f90.html"},{"title":"Product.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~product.f90~~EfferentGraph sourcefile~product.f90 Product.f90 sourcefile~types.f90 Types.f90 sourcefile~product.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~product.f90~~AfferentGraph sourcefile~product.f90 Product.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~assemble.f90->sourcefile~product.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~product.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_Product Source Code Product.f90 Source Code module Calculate_Product use omp_lib use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none private public :: Matrix_Vector_Product_CRS contains !* 行列ベクトル積を計算するサブルーチン subroutine Matrix_Vector_Product_CRS ( A , x , y ) implicit none type ( CRS ), intent ( in ) :: A real ( real64 ), intent ( in ) :: x (:) real ( real64 ), intent ( inout ) :: y (:) real ( real64 ) :: vtemp integer ( int32 ) :: i , j , is , ie integer ( int32 ) :: matrix_size matrix_size = size ( A % ptr ) - 1 y (:) = 0.0d0 !$omp parallel do private(vtemp, i, j, is, ie) do i = 1 , matrix_size vtemp = 0.0d0 is = A % ptr ( i - 1 ) ie = A % ptr ( i ) - 1 do j = is , ie vtemp = vtemp + A % val ( j ) * x ( A % ind ( j ) + 1 ) end do y ( i ) = vtemp end do !$omp end parallel do end subroutine Matrix_Vector_Product_CRS end module Calculate_Product","tags":"","loc":"sourcefile/product.f90.html"},{"title":"WRF.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~wrf.f90~~EfferentGraph sourcefile~wrf.f90 WRF.f90 sourcefile~types.f90 Types.f90 sourcefile~wrf.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_WRF Source Code WRF.f90 Source Code module Calculate_WRF use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none contains function Calculate_WRF_BC ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_BC ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < - 1.0d0 / structure_WRF % alpha1 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * ( structure_WRF % alpha1 / h ) ** structure_WRF % n1 else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_BC function Calculate_WRF_Derivative_BC ( structure_WRF , h ) result ( Cw ) type ( Type_WRF_BC ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: Cw if ( h < - 1.0d0 / structure_WRF % alpha1 ) then Cw = ( structure_WRF % thetaS - structure_WRF % thetaR ) * structure_WRF % n1 * ( structure_WRF % alpha1 / h ) ** ( structure_WRF % n1 + 1.0d0 ) / structure_WRF % alpha1 else Cw = 0.0d0 end if end function Calculate_WRF_Derivative_BC function Calculate_WRF_VG ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_VG ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * ( 1.0d0 + ( - structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_VG function Calculate_WRF_KO ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_KO ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * 0.5d0 * erfc ( log ( h / structure_WRF % alpha1 ) / ( structure_WRF % n1 * sqrt ( 2.0d0 ))) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_KO function Calculate_WRF_MVG ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_MVG ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < structure_WRF % hcrit ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_MVG function Calculate_WRF_Durner ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_Durner ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * & ( structure_WRF % w1 * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) & + structure_WRF % w2 * ( 1.0d0 + abs ( structure_WRF % alpha2 * h ) ** structure_WRF % n2 ) ** ( - structure_WRF % m2 )) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_Durner function Calculate_WRF_DVGCH ( structure_WRF , h ) result ( thetaW ) type ( Type_WRF_DVGCH ), intent ( in ) :: structure_WRF real ( real64 ), intent ( in ) :: h real ( real64 ) :: thetaW if ( h < 0 ) then thetaW = structure_WRF % thetaR + ( structure_WRF % thetaS - structure_WRF % thetaR ) * & ( structure_WRF % w1 * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n1 ) ** ( - structure_WRF % m1 ) & + structure_WRF % w2 * ( 1.0d0 + abs ( structure_WRF % alpha1 * h ) ** structure_WRF % n2 ) ** ( - structure_WRF % m2 )) else thetaW = structure_WRF % thetaS end if end function Calculate_WRF_DVGCH end module Calculate_WRF","tags":"","loc":"sourcefile/wrf.f90.html"},{"title":"Update.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~update.f90~~EfferentGraph sourcefile~update.f90 Update.f90 sourcefile~types.f90 Types.f90 sourcefile~update.f90->sourcefile~types.f90 sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~update.f90->sourcefile~secantmethod.f90 sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~update.f90->sourcefile~binaryfinding.f90 sourcefile~secantmethod.f90->sourcefile~types.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~secantmethod.f90->sourcefile~latentheat.f90 sourcefile~binaryfinding.f90->sourcefile~types.f90 sourcefile~binaryfinding.f90->sourcefile~latentheat.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~update.f90~~AfferentGraph sourcefile~update.f90 Update.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_Update Source Code Update.f90 Source Code module Calculate_Update use , intrinsic :: iso_fortran_env , only : int32 , real64 use omp_lib use :: Types , g => GravityAcceleration use :: RootFinding_SecantMethod , only : Secant_method use :: RootFinding_BinaryFinding , only : Binary_finding implicit none private real ( real64 ), parameter :: threshold = 1.0d-20 real ( real64 ), parameter :: TtoK = 27 3.15d0 integer ( int32 ), parameter :: Linear = 1 , pTransition = 2 , NonLinear = 3 , nTransition = 4 public :: Update_Parameters_Heat public :: Update_Parameters_Water public :: Update_theta public :: Update_Si public :: Update_Phase_Revise public :: Update_Gradient contains subroutine Update_Parameters_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Update_theta ( Solver ) call Update_Variables_Geometric ( Solver % Heat % Variables % lambda % pre (:), Solver % Heat % Constants % ThermalConductivity , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) call Update_Variables_Arithmetic ( Solver % Heat % Variables % rho % pre (:), Solver % Heat % Constants % Density , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) call Update_Variables_Arithmetic ( Solver % Heat % Variables % Cp % pre (:), Solver % Heat % Constants % HeatCapacity , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) call Update_Variables_Arithmetic ( Solver % Heat % Variables % Cs % pre (:), Solver % Heat % Constants % SpecificHeat , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) if ( Solver % Flags % isGCC ) then call Update_Cpa_GCC ( Solver ) else if ( Solver % Flags % isPower ) then call Update_Cpa_Power ( Solver ) end if if ( Solver % Flags % isGCC . or . Solver % Flags % isPower ) then call Update_Phase ( Solver ) call Update_Cadiv ( Solver ) end if if ( Solver % isWater ) then call Update_Gradient ( Solver , Solver % P % pre (:), Solver % Water % Variables % hGrad ) call Update_Flux ( Solver % Water % Variables % wFlux , Solver % Water % Variables % Klh % pre (:), Solver % Water % Variables % hGrad ) call Update_Gradient ( Solver , Solver % T % pre (:), Solver % Heat % Variables % TGrad ) ! print*,Solver%Heat%Constants%HeatCapacity%water ! print*,Solver%Water%Variables%wFlux%x(1:30)*Solver%T%pre(1:30)*Solver%Heat%Constants%HeatCapacity%water ! stop call Update_Heat_Flux ( Solver % Heat % Variables % TFlux , Solver % Heat % Variables % lambda % pre (:), Solver % Heat % Variables % TGrad , Solver % Heat % Constants % HeatCapacity % water , Solver % Water % Variables % wFlux , Solver % T % pre ) end if end subroutine Update_Parameters_Heat subroutine Update_Parameters_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver call Update_Variables_Log ( Solver % Water % Variables % Klh % pre (:), Solver % Water % Constants % HydraulicConductivity , Solver % Si % pre , Solver % Heat % Constants % Porosity , Solver % Flags ) end subroutine Update_Parameters_Water subroutine Update_theta ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN real ( real64 ) :: Porosity Porosity = Solver % Heat % Constants % Porosity do iN = 1 , Solver % N % node Solver % mwater % pre ( iN ) = Porosity * ( 1 - Solver % Si % pre ( iN )) ! Water content is limited to the range of threshold to Porosity if ( Solver % mwater % pre ( iN ) < Porosity * threshold ) then Solver % mwater % pre ( iN ) = Porosity * threshold else if ( Solver % mwater % pre ( iN ) > Porosity ) then Solver % mwater % pre ( iN ) = Porosity end if ! Ice content is limited to the range of threshold to Porosity Solver % mIce % pre ( iN ) = Porosity * Solver % Si % pre ( iN ) Solver % mIce % dif ( iN ) = Solver % mIce % pre ( iN ) - Solver % mIce % old ( iN ) if ( Solver % mIce % dif ( iN ) > Porosity ) then Solver % mIce % dif ( iN ) = Porosity else if ( Solver % mIce % dif ( iN ) < - Porosity ) then Solver % mIce % dif ( iN ) = - Porosity end if end do end subroutine Update_theta subroutine Update_Variables_Arithmetic ( Targets , Const , Si , Porosity , Flags ) implicit none real ( real64 ), intent ( inout ) :: Targets (:) type ( Phases ), intent ( in ) :: Const real ( real64 ), intent ( in ) :: Si (:) real ( real64 ), intent ( in ) :: Porosity type ( Flag ), intent ( in ) :: Flags real ( real64 ) :: unfrozen , frozen integer ( int32 ) :: iN , nTarget nTarget = size ( Targets ) unfrozen = Const % soil * ( 1.0d0 - Porosity ) + Const % water * Porosity frozen = Const % soil * ( 1.0d0 - Porosity ) + Const % ice * Porosity if ( Flags % isTRM . and . Flags % isSwitchTRM ) then do iN = 1 , nTarget if ( Si ( iN ) == 1.0d0 ) Targets ( iN ) = frozen end do else do iN = 1 , nTarget Targets ( iN ) = Si ( iN ) * frozen + ( 1.0d0 - Si ( iN )) * unfrozen end do end if end subroutine Update_Variables_Arithmetic subroutine Update_Variables_Geometric ( Targets , Const , Si , Porosity , Flags ) implicit none real ( real64 ), intent ( inout ) :: Targets (:) type ( Phases ), intent ( in ) :: Const real ( real64 ), intent ( in ) :: Si (:) real ( real64 ), intent ( in ) :: Porosity type ( Flag ), intent ( in ) :: Flags real ( real64 ) :: unfrozen , frozen , rtWI integer ( int32 ) :: iN , nTarget nTarget = size ( Targets ) unfrozen = Const % soil ** ( 1.0d0 - Porosity ) * Const % water ** Porosity frozen = Const % soil ** ( 1.0d0 - Porosity ) * Const % ice ** Porosity rtWI = Const % ice / Const % water if ( Flags % isTRM . and . Flags % isSwitchTRM ) then do iN = 1 , nTarget if ( Si ( iN ) == 1.0d0 ) Targets ( iN ) = frozen end do else do iN = 1 , nTarget Targets ( iN ) = unfrozen * rtWI ** ( Porosity * Si ( iN )) end do end if end subroutine Update_Variables_Geometric subroutine Update_Variables_Log ( Targets , Const , Si , Porosity , Flags ) implicit none real ( real64 ), intent ( inout ) :: Targets (:) type ( Phases ), intent ( in ) :: Const real ( real64 ), intent ( in ) :: Si (:) real ( real64 ), intent ( in ) :: Porosity type ( Flag ), intent ( in ) :: Flags real ( real64 ) :: k integer ( int32 ) :: iN , nTarget nTarget = size ( Targets ) k = log10 ( Const % ice / Const % soil ) ! if (Flags%isTRM .and. Flags%isSwitchTRM) then !     do iN = 1, nTarget ! \t\tif (Si(iN) == 1.0d0) Targets(iN) = Const%soil !     end do ! else do iN = 1 , nTarget Targets ( iN ) = Const % soil * 10 ** ( k * Si ( iN )) end do ! end if end subroutine Update_Variables_Log subroutine Update_Cpa_GCC ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ) :: Qs , Qr , alpha , n , m , Tf , Lf , Dice , Cp real ( real64 ) :: A , B , C , T integer ( int32 ) :: iN Qs = Solver % Heat % Latent % GCC % thetaS Qr = Solver % Heat % Latent % GCC % thetaR alpha = Solver % Heat % Latent % GCC % alpha n = Solver % Heat % Latent % GCC % n m = Solver % Heat % Latent % GCC % m Tf = Solver % Heat % Latent % GCC % Tf Lf = Solver % Heat % Latent % Lf Dice = Solver % Heat % Latent % rhoI A = Qs - Qr B = alpha * Lf / g do iN = 1 , Solver % N % node T = Solver % T % pre ( iN ) Cp = Solver % Heat % Variables % Cp % pre ( iN ) if ( T < Tf ) then C = ( T + TtoK ) / ( Tf + TtoK ) Solver % Heat % Variables % Ca % pre ( iN ) = Cp - Lf * Dice * ( A * B ** 2 * n * m * log ( C ) * abs ( B * log ( C )) ** ( n - 2.d0 )) & / (( T + TtoK ) * ( 1.d0 + abs ( B * log ( C )) ** n ) ** ( m + 1.d0 )) else Solver % Heat % Variables % Ca % pre ( iN ) = Cp end if end do end subroutine Update_Cpa_GCC subroutine Update_Cpa_Power ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ) :: Lf , Dice , phi , Tf , a , Cp , T integer ( int32 ) :: iN Lf = Solver % Heat % Latent % Lf Dice = Solver % Heat % Latent % rhoI phi = Solver % Heat % Latent % Power % phi Tf = Solver % Heat % Latent % Power % Tf a = Solver % Heat % Latent % Power % a do iN = 1 , Solver % N % node T = Solver % T % pre ( iN ) Cp = Solver % Heat % Variables % Cp % pre ( iN ) if ( T < Tf ) then Solver % Heat % Variables % Ca % pre ( iN ) = Cp - Lf * Dice * phi * a * ( 1.0d0 - T + Tf ) ** ( a - 1.0d0 ) else Solver % Heat % Variables % Ca % pre ( iN ) = Cp end if end do end subroutine Update_Cpa_Power subroutine Update_Phase ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN real ( real64 ) :: Tp , To do iN = 1 , Solver % N % node Tp = Solver % T % pre ( iN ) To = Solver % T % old ( iN ) if ( Tp >= 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = Linear else if ( Tp < 0.0d0 . and . To < 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = NonLinear else if ( Tp < 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = pTransition else Solver % Heat % Variables % Phase ( iN ) = nTransition end if end do end subroutine Update_Phase subroutine Update_Phase_Revise ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN real ( real64 ) :: Tp , To do iN = 1 , Solver % N % node Tp = Solver % T % pre ( iN ) To = Solver % T % old ( iN ) if ( Tp >= 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = Linear else if ( Tp < 0.0d0 . and . To < 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = NonLinear else if ( Tp < 0.0d0 . and . To >= 0.0d0 ) then Solver % Heat % Variables % Phase ( iN ) = pTransition ! call Secant_method(Solver, iN) call Binary_finding ( Solver , iN ) else Solver % Heat % Variables % Phase ( iN ) = nTransition end if end do end subroutine Update_Phase_Revise subroutine Update_Cadiv ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN do iN = 1 , Solver % N % node if ( Solver % Heat % Variables % Phase ( iN ) == Linear ) then Solver % Heat % Variables % Ca % div ( iN ) = Solver % Heat % Variables % Ca % pre ( iN ) else if ( Solver % Heat % Variables % Phase ( iN ) == pTransition ) then if ( Solver % Flags % isGCC ) then Solver % Heat % Variables % Ca % div ( iN ) = ( Solver % Heat % Variables % Ca % pre ( iN ) * Solver % Heat % Latent % GCC % Ca_max ) ** 0.5d0 else if ( Solver % Flags % isPower ) then Solver % Heat % Variables % Ca % div ( iN ) = ( Solver % Heat % Variables % Ca % pre ( iN ) * Solver % Heat % Latent % Power % Ca_max ) ** 0.5d0 end if else if ( Solver % Heat % Variables % Phase ( iN ) == NonLinear ) then Solver % Heat % Variables % Ca % div ( iN ) = ( Solver % Heat % Variables % Ca % pre ( iN ) * Solver % Heat % Variables % Ca % old ( iN )) ** 0.5d0 end if end do end subroutine Update_Cadiv subroutine Update_Si ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ) :: A , B , C real ( real64 ) :: Qs , Qr , alpha , n , m , Lf , Dice , Tf integer ( int32 ) :: iN if ( Solver % Flags % isGCC ) then Qs = Solver % Heat % Latent % GCC % thetaS Qr = Solver % Heat % Latent % GCC % thetaR alpha = Solver % Heat % Latent % GCC % alpha n = Solver % Heat % Latent % GCC % n m = Solver % Heat % Latent % GCC % m Lf = Solver % Heat % Latent % Lf Dice = Solver % Heat % Latent % rhoI Tf = Solver % Heat % Latent % GCC % Tf A = Qs - Qr B = alpha * Lf / g do iN = 1 , Solver % N % node C = ( Solver % T % pre ( iN ) + TtoK ) / ( Tf + TtoK ) if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = ( A * ( 1.0d0 - ( 1.0d0 + abs ( B * log ( C )) ** n ) ** ( - m ))) / Qs else Solver % Si % pre ( iN ) = 0.0d0 end if end do else if ( Solver % Flags % isPower ) then Tf = Solver % Heat % Latent % Power % Tf alpha = Solver % Heat % Latent % Power % a do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = 1.0d0 - ( 1.0d0 - Solver % T % pre ( iN ) + Tf ) ** alpha else Solver % Si % pre ( iN ) = 0.0d0 end if end do end if end subroutine Update_Si subroutine Update_Gradient ( Solver , ar , Grad ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ), intent ( in ) :: ar (:) type ( DP2d ), intent ( inout ) :: Grad integer ( int32 ) :: counter ( SOlver % N % node ) integer ( int32 ) :: iN , p1 , p2 , p3 real ( real64 ) :: gx , gy counter (:) = 0 Grad % x (:) = 0.0d0 Grad % y (:) = 0.0d0 do iN = 1 , Solver % N % element p1 = Solver % N % pElement ( 1 , iN ) p2 = Solver % N % pElement ( 2 , iN ) p3 = Solver % N % pElement ( 3 , iN ) gx = ( Solver % N % Basis % b ( 1 , iN ) * ar ( p1 ) + Solver % N % Basis % b ( 2 , iN ) * ar ( p2 ) + Solver % N % Basis % b ( 3 , iN ) * ar ( p3 )) / ( 2.0d0 * Solver % N % eArea ( iN )) gy = ( Solver % N % Basis % c ( 1 , iN ) * ar ( p1 ) + Solver % N % Basis % c ( 2 , iN ) * ar ( p2 ) + Solver % N % Basis % c ( 3 , iN ) * ar ( p3 )) / ( 2.0d0 * Solver % N % eArea ( iN )) Grad % x ( p1 ) = Grad % x ( p1 ) + gx Grad % y ( p1 ) = Grad % y ( p1 ) + gy Grad % x ( p2 ) = Grad % x ( p2 ) + gx Grad % y ( p2 ) = Grad % y ( p2 ) + gy Grad % x ( p3 ) = Grad % x ( p3 ) + gx Grad % y ( p3 ) = Grad % y ( p3 ) + gy counter ( p1 ) = counter ( p1 ) + 1 counter ( p2 ) = counter ( p2 ) + 1 counter ( p3 ) = counter ( p3 ) + 1 end do Grad % x (:) = Grad % x (:) / counter (:) Grad % y (:) = Grad % y (:) / counter (:) end subroutine Update_Gradient subroutine Update_Flux ( Flux , C , Grad ) implicit none type ( DP2d ), intent ( inout ) :: Flux type ( DP2d ), intent ( in ) :: Grad real ( real64 ), intent ( in ) :: C (:) Flux % x (:) = - C (:) * Grad % x (:) Flux % y (:) = - C (:) * Grad % y (:) end subroutine Update_Flux subroutine Update_Heat_Flux ( TFlux , C , TGrad , Cw , Qw , T ) implicit none type ( DP2d ), intent ( inout ) :: TFlux type ( DP2d ), intent ( in ) :: TGrad real ( real64 ), intent ( in ) :: C (:) real ( real64 ), intent ( in ) :: Cw type ( DP2d ), intent ( in ) :: Qw real ( real64 ), intent ( in ) :: T (:) TFlux % x (:) = - C (:) * TGrad % x (:) TFlux % y (:) = - C (:) * TGrad % y (:) ! print*, TFlux%x(:) ! stop end subroutine Update_Heat_Flux end module Calculate_Update","tags":"","loc":"sourcefile/update.f90.html"},{"title":"Count.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~count.f90~~EfferentGraph sourcefile~count.f90 Count.f90 sourcefile~types.f90 Types.f90 sourcefile~count.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~count.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~count.f90~~AfferentGraph sourcefile~count.f90 Count.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~count.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_Count Source Code Count.f90 Source Code module Calculate_Count use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: error implicit none interface Count_if procedure :: Count_if_int32 procedure :: Count_if_int32_Array end interface contains function Count_if_int32 ( array , Condition ) result ( count ) implicit none interface logical function Condition ( x ) integer , intent ( in ) :: x end function Condition end interface integer , intent ( in ) :: array (:) ! 入力配列 integer :: count ! 条件を満たす要素の個数 integer :: i count = 0 do i = 1 , size ( array ) if ( Condition ( array ( i ))) count = count + 1 end do end function Count_if_int32 function Count_if_int32_Array ( array , condition , condition_array ) result ( count ) implicit none interface logical function Condition ( x , condition_array ) integer , intent ( in ) :: x integer , intent ( in ) :: condition_array (:) end function Condition end interface integer , intent ( in ) :: array (:) ! 入力配列 integer , intent ( in ) :: condition_array (:) ! 条件配列 integer :: count ! 条件を満たす要素の個数 integer :: i count = 0 do i = 1 , size ( array ) if ( Condition ( array ( i ), condition_array )) count = count + 1 end do end function Count_if_int32_Array end module Calculate_Count","tags":"","loc":"sourcefile/count.f90.html"},{"title":"TRM.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~trm.f90~~EfferentGraph sourcefile~trm.f90 TRM.f90 sourcefile~types.f90 Types.f90 sourcefile~trm.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_TRM Source Code TRM.f90 Source Code module Calculate_TRM use , intrinsic :: iso_fortran_env , only : int32 , real64 use omp_lib use types implicit none private public :: TRMethod contains subroutine TRMethod ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver real ( real64 ), parameter :: vTf = 0.0d0 real ( real64 ) :: Fr_tmp real ( real64 ) :: C , TRM_BTM , tmpSi integer ( int32 ) :: iN , vector_size if ( Solver % Flags % isSwitchOnceTRM ) then TRM_BTM = 1.0d0 / Solver % Heat % Constants % Density % water * Solver % Heat % Constants % Porosity * Solver % Heat % Constants % LatentHeat ! $omp parallel do private(iN, C, tmpSi) do iN = 1 , Solver % N % node C = Solver % Heat % Variables % rho % pre ( iN ) * Solver % Heat % Variables % Cs % pre ( iN ) * TRM_BTM tmpSi = Solver % Si % old ( iN ) + C * ( vTf - Solver % T % new ( iN )) if ( tmpSi <= 0.0d0 . and . Solver % Si % old ( iN ) == 0.0d0 ) then Solver % Si % new ( iN ) = 0.0d0 else if ( tmpSi >= 1.0d0 . and . Solver % Si % old ( iN ) == 1.0d0 ) then Solver % Si % new ( iN ) = 1.0d0 else if ( 0.0d0 < tmpSi . and . tmpSi < 1.0d0 . and . Solver % Si % old ( iN ) <= 1.0d0 ) then Solver % T % new ( iN ) = vTf Solver % Si % new ( iN ) = tmpSi else if ( 0.0d0 < Solver % Si % old ( iN ) . and . Solver % Si % old ( iN ) < 1.0d0 . and . tmpSi >= 1.0d0 ) then Solver % T % new ( iN ) = vTf + ( 1.0d0 - tmpSi ) / C Solver % Si % new ( iN ) = 1.0d0 end if end do ! $omp end parallel do else ! $omp parallel do private(iN, C, tmpSi, TRM_BTM) ! print*,Solver%Heat%Variables%Cs%pre(:) ! stop do iN = 1 , Solver % N % node TRM_BTM = Solver % Heat % Constants % Density % water * Solver % Heat % Constants % LatentHeat C = Solver % Heat % Variables % rho % pre ( iN ) * Solver % Heat % Variables % Cs % pre ( iN ) / ( Solver % mWater % pre ( iN ) * TRM_BTM ) tmpSi = Solver % Si % old ( iN ) + C * ( vTf - Solver % T % new ( iN )) if ( tmpSi <= 0.0d0 . and . Solver % Si % old ( iN ) == 0.0d0 ) then Solver % Si % new ( iN ) = 0.0d0 else if ( tmpSi >= 1.0d0 . and . Solver % Si % old ( iN ) == 1.0d0 ) then Solver % Si % new ( iN ) = 1.0d0 else if ( 0.0d0 < tmpSi . and . tmpSi < 1.0d0 . and . Solver % Si % old ( iN ) <= 1.0d0 ) then Solver % T % new ( iN ) = vTf Solver % Si % new ( iN ) = tmpSi else if ( 0.0d0 < Solver % Si % old ( iN ) . and . Solver % Si % old ( iN ) < 1.0d0 . and . tmpSi >= 1.0d0 ) then Solver % T % new ( iN ) = vTf + ( 1.0d0 - tmpSi ) / C Solver % Si % new ( iN ) = 1.0d0 end if end do ! $omp end parallel do end if ! stop ! do iN = 250,260 ! \tprint*,Solver%Si%new(iN), Solver%T%new(iN) ! end do end subroutine TRMethod end module Calculate_TRM","tags":"","loc":"sourcefile/trm.f90.html"},{"title":"Observation.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~observation.f90~~EfferentGraph sourcefile~observation.f90 Observation.f90 sourcefile~types.f90 Types.f90 sourcefile~observation.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~observation.f90->sourcefile~allocate.f90 sourcefile~points.f90 Points.f90 sourcefile~observation.f90->sourcefile~points.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~points.f90->sourcefile~types.f90 sourcefile~points.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_Observation Source Code Observation.f90 Source Code module Calculate_Observation use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: Allocate use :: Calculate_Points , only : Set_Point implicit none private interface Set_Obs_COO procedure :: Set_Obs_COO_31 end interface public :: Set_Obs_COO contains subroutine Set_Obs_COO_31 ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver type ( Vector2d ) :: p1 , p2 , p3 integer ( int32 ) :: iE , iObs , iS real ( real64 ) :: x , y , s call Allocate_Vector ( Solver % Obs % nAreaObs , Solver % Obs % nObs ) call Allocate_Matrix ( Solver % Obs % vAreaObs , Solver % N % ShCoe , Solver % Obs % nObs ) do iObs = 1 , Solver % Obs % nObs x = Solver % Obs % obsCOO % x ( iObs ) y = Solver % Obs % obsCOO % y ( iObs ) do iE = 1 , Solver % N % Element call Set_Point ( Solver % N , iE , p1 , p2 , p3 ) if ( is_in_triangle ( x , y , p1 , p2 , p3 )) then s = Solver % N % eArea ( iE ) do iS = 1 , Solver % N % ShCoe Solver % Obs % vAreaObs ( iS , iObs ) = ( Solver % N % Basis % a ( iS , iE ) + Solver % N % Basis % b ( iS , iE ) * x & & + Solver % N % Basis % c ( iS , iE ) * y ) / ( 2.0d0 * s ) end do Solver % Obs % nAreaObs ( iObs ) = iE exit end if end do end do end subroutine Set_Obs_COO_31 logical function is_in_triangle ( x , y , p1 , p2 , p3 ) implicit none type ( Vector2d ), intent ( in ) :: p1 , p2 , p3 real ( real64 ), intent ( in ) :: x , y is_in_triangle = . false . if ( 0.0d0 <= ( p2 % y - p3 % y ) * ( x - p3 % x ) + ( p3 % x - p2 % x ) * ( y - p3 % y ) . and . & & 0.0d0 <= ( p3 % y - p1 % y ) * ( x - p1 % x ) + ( p1 % x - p3 % x ) * ( y - p1 % y ) . and . & & 0.0d0 <= ( p1 % y - p2 % y ) * ( x - p2 % x ) + ( p2 % x - p1 % x ) * ( y - p2 % y )) then is_in_triangle = . true . end if end function is_in_triangle end module Calculate_Observation","tags":"","loc":"sourcefile/observation.f90.html"},{"title":"LatentHeat.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~latentheat.f90~~EfferentGraph sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~types.f90 Types.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~latentheat.f90~~AfferentGraph sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~secantmethod.f90->sourcefile~latentheat.f90 sourcefile~initialize.f90 Initialize.f90 sourcefile~initialize.f90->sourcefile~latentheat.f90 sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~binaryfinding.f90->sourcefile~latentheat.f90 sourcefile~update.f90 Update.f90 sourcefile~update.f90->sourcefile~secantmethod.f90 sourcefile~update.f90->sourcefile~binaryfinding.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_LatentHeat Source Code LatentHeat.f90 Source Code module Calculate_LatentHeat use , intrinsic :: iso_fortran_env , only : int32 , real64 use omp_lib use :: Types , g => GravityAcceleration implicit none private real ( real64 ), parameter :: TtoK = 27 3.15d0 public :: Calc_LatentHeatTerm public :: LatentHeatTreatment public :: Find_Ca_max contains function Calc_LatentHeatTerm ( T , Tnew , Latent ) result ( res ) implicit none real ( real64 ) :: res real ( real64 ), intent ( in ) :: T , Tnew type ( LatentHeatTreatment ), intent ( in ) :: Latent ! 20: GCC, 30: Power if ( Latent % useModel == 20 ) then res = Latent % Cp_unf * ( T - Tnew ) - Latent % Lf * Latent % rhoI * ( Latent % GCC % thetaS - Latent % GCC % thetaR ) & * ( 1.0d0 - ( 1.0d0 + abs ( Latent % GCC % alpha * Latent % Lf * log (( TtoK + T ) / TtoK ) / g ) ** Latent % GCC % n ) ** ( - Latent % GCC % m )) else if ( Latent % useModel == 30 ) then res = Latent % Cp_unf * ( T - Tnew ) / ( Latent % Lf * Latent % rhoI * Latent % Power % phi ) & + ( 1.0d0 - T + Latent % Power % Tf ) ** Latent % Power % a - 1.0d0 end if end function Calc_LatentHeatTerm function Calc_Ca_GCC ( Heat , T ) result ( Ca ) implicit none type ( HeatFields ), intent ( in ) :: Heat real ( real64 ), intent ( in ) :: T real ( real64 ) :: Ca real ( real64 ) :: Cp , Si , A , B , C real ( real64 ) :: Qs , Qr , alpha , n , m , Lf , Dice , Tf Qs = Heat % Latent % GCC % thetaS Qr = Heat % Latent % GCC % thetaR alpha = Heat % Latent % GCC % alpha n = Heat % Latent % GCC % n m = Heat % Latent % GCC % m Lf = Heat % Latent % Lf Dice = Heat % Latent % rhoI Tf = Heat % Latent % GCC % Tf A = Qs - Qr B = alpha * Lf / g C = ( T + TtoK ) / ( Tf + TtoK ) if ( T < Tf ) then Si = ( A * ( 1.0d0 - ( 1.0d0 + abs ( B * log ( C )) ** n ) ** ( - m ))) / Qs else Si = 0.0d0 end if Cp = Heat % Constants % HeatCapacity % soil * ( 1.0d0 - Heat % Constants % Porosity ) & + Heat % Constants % HeatCapacity % water * Heat % Constants % Porosity * ( 1.0d0 - Si ) & + Heat % Constants % HeatCapacity % ice * Heat % Constants % Porosity * Si if ( T < Tf ) then Ca = Cp - Lf * Dice * ( A * B ** 2 * n * m * log ( C ) * abs ( B * log ( C )) ** ( n - 2.d0 )) & / (( T + TtoK ) * ( 1.d0 + abs ( B * log ( C )) ** n ) ** ( m + 1.d0 )) else Ca = Cp end if end function Calc_Ca_GCC subroutine Find_Ca_max ( Heat ) implicit none type ( HeatFields ), intent ( inout ) :: Heat real ( real64 ) :: x0 , x1 , x2 , x3 , f1 , f2 , tau real ( real64 ), parameter :: epsilon = 1.0d-15 if ( Heat % Latent % useModel == 20 ) then tau = ( sqrt ( 5.d0 ) - 1.d0 ) / 2.d0 ! 黄金比 x0 = 0.0d0 x3 = - 1.0d0 x1 = x0 + ( 1.d0 - tau ) * ( x3 - x0 ) x2 = x0 + tau * ( x3 - x0 ) f1 = Calc_Ca_GCC ( Heat , x1 ) f2 = Calc_Ca_GCC ( Heat , x2 ) do while ( abs ( x3 - x0 ) > epsilon ) if ( f2 > f1 ) then x0 = x1 x1 = x2 x2 = x0 + tau * ( x3 - x0 ) f1 = f2 f2 = Calc_Ca_GCC ( Heat , x2 ) else x3 = x2 x2 = x1 x1 = x0 + ( 1.d0 - tau ) * ( x3 - x0 ) f2 = f1 f1 = Calc_Ca_GCC ( Heat , x1 ) end if end do Heat % Latent % GCC % Ca_max = Calc_Ca_GCC ( Heat , ( x1 + x2 ) / 2.d0 ) else if ( Heat % Latent % useModel == 30 ) then Heat % Latent % Power % Ca_max = Heat % Latent % Cp_unf - Heat % Latent % Lf * Heat % Latent % rhoI * Heat % Latent % Power % phi * Heat % Latent % Power % a end if end subroutine Find_Ca_max end module Calculate_LatentHeat","tags":"","loc":"sourcefile/latentheat.f90.html"},{"title":"GCC.f90 – Freezing Thawing Dynamics Simulation Solver","text":"Contents Modules Calculate_GCC Source Code GCC.f90 Source Code module Calculate_GCC use , intrinsic :: iso_fortran_env , only : int32 , real64 implicit none private real ( real64 ), parameter :: g = 9.80665d0 real ( real64 ), parameter :: TtoK = 27 3.15d0 public :: Calculate_GCC_NonSegregation public :: Calculate_GCC_Segregation public :: Set_Calculate_GCC_Segregation interface Calculate_GCC_NonSegregation module procedure Calculate_GCC_NonSegregation_kPa module procedure Calculate_GCC_NonSegregation_m end interface Calculate_GCC_NonSegregation interface Calculate_GCC_NonSegregation_Derivative module procedure Calculate_GCC_NonSegregation_Derivative_kPa module procedure Calculate_GCC_NonSegregation_Derivative_m end interface Calculate_GCC_NonSegregation_Derivative abstract interface function Calculate_GCC_Segregation_interface ( T , Pw , Tf , Lf , rhoW , rhoI ) result ( Suction ) use , intrinsic :: iso_fortran_env , only : real64 implicit none real ( real64 ), intent ( in ) :: T , Pw , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction end function Calculate_GCC_Segregation_interface end interface procedure ( Calculate_GCC_Segregation_interface ), pointer :: Calculate_GCC_Segregation => null () procedure ( Calculate_GCC_Segregation_interface ), pointer :: Calculate_GCC_Segregation_Derivative => null () contains function Calculate_GCC_NonSegregation_kPa ( T , Tf , Lf , rhoW ) result ( Suction_kPa ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf , rhoW real ( real64 ) :: Suction_kPa if ( T <= Tf ) then Suction_kPa = - Lf * rhoW * log (( T + TtoK ) / ( Tf + TtoK )) else Suction_kPa = 0.0d0 end if end function Calculate_GCC_NonSegregation_kPa function Calculate_GCC_NonSegregation_m ( T , Tf , Lf ) result ( Suction_m ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf real ( real64 ) :: Suction_m if ( T <= Tf ) then Suction_m = - Lf * log (( T + TtoK ) / ( Tf + TtoK )) / g else Suction_m = 0.0d0 end if end function Calculate_GCC_NonSegregation_m function Calculate_GCC_NonSegregation_Derivative_kPa ( T , Tf , Lf , rhoW ) result ( Suction_kPa_Derivative ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf , rhoW real ( real64 ) :: Suction_kPa_Derivative if ( T <= Tf ) then Suction_kPa_Derivative = - Lf * rhoW / ( T + TtoK ) else Suction_kPa_Derivative = 0.0d0 end if end function Calculate_GCC_NonSegregation_Derivative_kPa function Calculate_GCC_NonSegregation_Derivative_m ( T , Tf , Lf ) result ( Suction_m ) implicit none real ( real64 ), intent ( in ) :: T , Tf , Lf real ( real64 ) :: Suction_m if ( T <= Tf ) then Suction_m = - Lf / (( T + TtoK ) * g ) else Suction_m = 0.0d0 end if end function Calculate_GCC_NonSegregation_Derivative_m subroutine Set_Calculate_GCC_Segregation ( Segregation_type ) implicit none integer ( int32 ), intent ( in ) :: Segregation_type if ( associated ( Calculate_GCC_Segregation )) nullify ( Calculate_GCC_Segregation ) if ( associated ( Calculate_GCC_Segregation_Derivative )) nullify ( Calculate_GCC_Segregation_Derivative ) select case ( Segregation_type ) case ( 1 ) Calculate_GCC_Segregation => Calculate_GCC_Segregation_kPa Calculate_GCC_Segregation_Derivative => Calculate_GCC_Segregation_Derivative_kPa case ( 2 ) Calculate_GCC_Segregation => Calculate_GCC_Segregation_m Calculate_GCC_Segregation_Derivative => Calculate_GCC_Segregation_Derivative_m end select end subroutine Set_Calculate_GCC_Segregation function Calculate_GCC_Segregation_kPa ( T , Pw_kPa , Tf , Lf , rhoW , rhoI ) result ( Suction_kPa ) implicit none real ( real64 ), intent ( in ) :: T , Pw_kPa , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_kPa if ( T <= Tf ) then Suction_kPa = ( rhoI / rhoW - 1.0d0 ) * Pw_kPa - Lf * rhoI * log (( T + TtoK ) / ( Tf + TtoK )) else Suction_kPa = 0.0d0 end if end function Calculate_GCC_Segregation_kPa function Calculate_GCC_Segregation_m ( T , Pw_m , Tf , Lf , rhoW , rhoI ) result ( Suction_m ) implicit none real ( real64 ), intent ( in ) :: T , Pw_m , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_m if ( T <= Tf ) then Suction_m = (( rhoI / rhoW - 1.0d0 ) * Pw_m - Lf * rhoI * log (( T + TtoK ) / ( Tf + TtoK ))) / ( rhoW * g ) else Suction_m = 0.0d0 end if end function Calculate_GCC_Segregation_m function Calculate_GCC_Segregation_Derivative_kPa ( T , Pw_kPa , Tf , Lf , rhoW , rhoI ) result ( Suction_kPa_Derivative ) implicit none real ( real64 ), intent ( in ) :: T , Pw_kPa , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_kPa_Derivative if ( T <= Tf ) then Suction_kPa_Derivative = - Lf * rhoW / ( T + TtoK ) else Suction_kPa_Derivative = 0.0d0 end if end function Calculate_GCC_Segregation_Derivative_kPa function Calculate_GCC_Segregation_Derivative_m ( T , Pw_m , Tf , Lf , rhoW , rhoI ) result ( Suction_m_Derivative ) implicit none real ( real64 ), intent ( in ) :: T , Pw_m , Tf , Lf , rhoW , rhoI real ( real64 ) :: Suction_m_Derivative if ( T <= Tf ) then Suction_m_Derivative = - Lf / (( T + TtoK ) * g ) else Suction_m_Derivative = 0.0d0 end if end function Calculate_GCC_Segregation_Derivative_m end module Calculate_GCC","tags":"","loc":"sourcefile/gcc.f90.html"},{"title":"Shape.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~shape.f90~~EfferentGraph sourcefile~shape.f90 Shape.f90 sourcefile~types.f90 Types.f90 sourcefile~shape.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~shape.f90->sourcefile~error.f90 sourcefile~points.f90 Points.f90 sourcefile~shape.f90->sourcefile~points.f90 sourcefile~points.f90->sourcefile~types.f90 sourcefile~points.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_Shape Source Code Shape.f90 Source Code module Calculate_Shape use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: error use :: Calculate_Points , only : Set_Point implicit none interface Calc_Shape procedure :: Calc_Shape_31 end interface contains subroutine Calc_Shape_31 ( Geometry ) implicit none type ( Geometry2d ), intent ( inout ) :: Geometry type ( Vector2d ) :: p1 , p2 , p3 integer ( int32 ) :: iE do iE = 1 , Geometry % Element call set_point ( Geometry , iE , p1 , p2 , p3 ) if ( iE < 1 . or . iE > Geometry % Element ) then call error_message ( 932 ) else Geometry % Basis % a ( 1 , iE ) = p2 % x * p3 % y - p3 % x * p2 % y Geometry % Basis % a ( 2 , iE ) = p3 % x * p1 % y - p1 % x * p3 % y Geometry % Basis % a ( 3 , iE ) = p1 % x * p2 % y - p2 % x * p1 % y Geometry % Basis % b ( 1 , iE ) = p2 % y - p3 % y Geometry % Basis % b ( 2 , iE ) = p3 % y - p1 % y Geometry % Basis % b ( 3 , iE ) = p1 % y - p2 % y Geometry % Basis % c ( 1 , iE ) = p3 % x - p2 % x Geometry % Basis % c ( 2 , iE ) = p1 % x - p3 % x Geometry % Basis % c ( 3 , iE ) = p2 % x - p1 % x end if end do end subroutine Calc_Shape_31 end module Calculate_Shape","tags":"","loc":"sourcefile/shape.f90.html"},{"title":"BLAS.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~blas.f90~~EfferentGraph sourcefile~blas.f90 BLAS.f90 sourcefile~types.f90 Types.f90 sourcefile~blas.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~blas.f90~~AfferentGraph sourcefile~blas.f90 BLAS.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~blas.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Calculate_BLAS Source Code BLAS.f90 Source Code module Calculate_BLAS use omp_lib use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none private public :: norm_2 public :: ddots contains function norm_2 ( N , x ) result ( norm ) implicit none integer ( int32 ), intent ( in ) :: N real ( real64 ), intent ( in ) :: x (:) real ( real64 ) :: norm integer ( int32 ) :: iN , ithread , nthreads real ( real64 ), allocatable :: partial_sums (:) ! nthreads = omp_get_max_threads() ! allocate(partial_sums(nthreads)) ! partial_sums = 0.0d0 norm = 0.0d0 ! $omp parallel private(iN, ithread) ! ithread = omp_get_thread_num() + 1 ! $omp do do iN = 1 , N norm = norm + x ( iN ) ** 2 end do ! $omp end do ! $omp end parallel ! メモリ解放 deallocate ( partial_sums ) end function norm_2 function ddots ( N , x , y ) result ( dot ) implicit none integer ( int32 ), intent ( in ) :: N real ( real64 ), intent ( in ) :: x (:), y (:) real ( real64 ) :: dot integer ( int32 ) :: iN , ithread , nthreads real ( real64 ), allocatable :: partial_sums (:) ! nthreads = omp_get_max_threads() ! allocate(partial_sums(nthreads)) ! partial_sums = 0.0d0 dot = 0.0d0 ! $omp parallel private(iN, ithread) ! ithread = omp_get_thread_num() + 1 ! $omp do do iN = 1 , N dot = dot + x ( iN ) * y ( iN ) end do ! $omp end do ! $omp end parallel ! dot = sum(partial_sums) end function ddots end module Calculate_BLAS","tags":"","loc":"sourcefile/blas.f90.html"},{"title":"Types.f90 – Freezing Thawing Dynamics Simulation Solver","text":"Files dependent on this one sourcefile~~types.f90~~AfferentGraph sourcefile~types.f90 Types.f90 sourcefile~update.f90 Update.f90 sourcefile~update.f90->sourcefile~types.f90 sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~update.f90->sourcefile~binaryfinding.f90 sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~update.f90->sourcefile~secantmethod.f90 sourcefile~observation.f90 Observation.f90 sourcefile~observation.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~observation.f90->sourcefile~allocate.f90 sourcefile~points.f90 Points.f90 sourcefile~observation.f90->sourcefile~points.f90 sourcefile~initcopy.f90 InitCopy.f90 sourcefile~initcopy.f90->sourcefile~types.f90 sourcefile~area.f90 Area.f90 sourcefile~area.f90->sourcefile~types.f90 sourcefile~area.f90->sourcefile~points.f90 sourcefile~findind.f90 FindInd.f90 sourcefile~findind.f90->sourcefile~types.f90 sourcefile~wrf.f90 WRF.f90 sourcefile~wrf.f90->sourcefile~types.f90 sourcefile~binaryfinding.f90->sourcefile~types.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~binaryfinding.f90->sourcefile~latentheat.f90 sourcefile~convertcrs.f90 ConvertCRS.f90 sourcefile~convertcrs.f90->sourcefile~types.f90 sourcefile~convertcrs.f90->sourcefile~allocate.f90 sourcefile~output.f90 Output.f90 sourcefile~output.f90->sourcefile~types.f90 sourcefile~output.f90->sourcefile~allocate.f90 sourcefile~latentheat.f90->sourcefile~types.f90 sourcefile~trm.f90 TRM.f90 sourcefile~trm.f90->sourcefile~types.f90 sourcefile~fixboundarycondition.f90 FixBoundaryCondition.f90 sourcefile~fixboundarycondition.f90->sourcefile~types.f90 sourcefile~fixboundarycondition.f90->sourcefile~findind.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~hcf.f90 HCF.f90 sourcefile~hcf.f90->sourcefile~types.f90 sourcefile~secantmethod.f90->sourcefile~types.f90 sourcefile~secantmethod.f90->sourcefile~latentheat.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~types.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 sourcefile~fixinitialcondition.f90->sourcefile~fixboundarycondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate_structure.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~solve.f90 Solve.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~shape.f90 Shape.f90 sourcefile~shape.f90->sourcefile~types.f90 sourcefile~shape.f90->sourcefile~points.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~types.f90 sourcefile~heat.f90->sourcefile~allocate.f90 sourcefile~heat.f90->sourcefile~hcf.f90 sourcefile~heat.f90->sourcefile~allocate_structure.f90 sourcefile~count.f90 Count.f90 sourcefile~heat.f90->sourcefile~count.f90 sourcefile~initialize.f90 Initialize.f90 sourcefile~initialize.f90->sourcefile~types.f90 sourcefile~initialize.f90->sourcefile~latentheat.f90 sourcefile~initialize.f90->sourcefile~allocate.f90 sourcefile~count.f90->sourcefile~types.f90 sourcefile~stdout.f90 Stdout.f90 sourcefile~stdout.f90->sourcefile~types.f90 sourcefile~blas.f90 BLAS.f90 sourcefile~blas.f90->sourcefile~types.f90 sourcefile~precon_jacobi.f90 Precon_jacobi.f90 sourcefile~precon_jacobi.f90->sourcefile~types.f90 sourcefile~assemble.f90->sourcefile~types.f90 sourcefile~assemble.f90->sourcefile~findind.f90 sourcefile~assemble.f90->sourcefile~allocate.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~product.f90 Product.f90 sourcefile~assemble.f90->sourcefile~product.f90 sourcefile~product.f90->sourcefile~types.f90 sourcefile~points.f90->sourcefile~types.f90 sourcefile~solve.f90->sourcefile~types.f90 sourcefile~solve.f90->sourcefile~allocate.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~solve.f90->sourcefile~blas.f90 sourcefile~solve.f90->sourcefile~precon_jacobi.f90 sourcefile~solve.f90->sourcefile~product.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Types Source Code Types.f90 Source Code module Types use , intrinsic :: iso_fortran_env , only : int32 , real64 implicit none public #ifdef _MPI include 'mpif.h' #endif integer ( int32 ), parameter :: Temperature = 1 , Pressure = 2 , Stress = 3 integer ( int32 ), parameter :: Linear = 1 , pTransition = 2 , NonLinear = 3 , nTransition = 4 real ( real64 ), parameter :: GravityAcceleration = 9.80655d0 integer ( int32 ), parameter :: undumped = 0 , dumped = 1 type :: VC sequence real ( real64 ) :: x , y end type VC type :: Vector2D sequence real ( real64 ) :: x , y end type Vector2D type :: Vector3D sequence real ( real64 ) :: x , y , z end type Vector3D type :: DP2d sequence real ( real64 ), allocatable :: x (:), y (:) end type DP2d type :: DP3d sequence real ( real64 ), allocatable :: x (:), y (:), z (:) end type DP3d type :: INT2d sequence integer ( int32 ), allocatable :: x (:), y (:) end type INT2d type :: INT3d sequence integer ( int32 ), allocatable :: x (:), y (:), z (:) end type INT3d type :: PH sequence real ( real64 ) :: soil , water , ice end type PH type :: Phases sequence real ( real64 ) :: soil , water , ice end type Phases type :: Shape sequence real ( real64 ), allocatable :: a (:, :), b (:, :), c (:, :), d (:, :) end type Shape type :: BoudaryConditionInfo integer ( int32 ), allocatable :: Node (:) ! <= BC.in integer ( int32 ), allocatable :: TypeKey (:) ! <= BC.in integer ( int32 ), allocatable :: type (:) ! <= BCtype.in real ( real64 ), allocatable :: value (:) ! <= BCtype.in type ( INT2d ) :: Edges integer ( int32 ), allocatable :: EdgesDirection (:) real ( real64 ), allocatable :: EdgesDistance (:) end type BoudaryConditionInfo type :: BoudaryCondition type ( BoudaryConditionInfo ) :: Heat , Water , Stress integer ( int32 ) :: numNode , numType , numEdges end type BoudaryCondition type :: Boudary_Condition_Dirichlet integer ( int32 ) :: Num_Node , Num_Type integer ( int32 ), allocatable :: Node (:), Node_Type (:), Value_Info (:) real ( real64 ), allocatable :: value (:) end type Boudary_Condition_Dirichlet type :: Boudary_Condition_Neumann integer ( int32 ) :: Num_Edge , Num_Edge_Type , Num_Type integer ( int32 ), allocatable :: Edge (:, :), Edge_Type (:), Value_Info (:) real ( real64 ), allocatable :: value (:), Heat_Transfer (:) end type Boudary_Condition_Neumann type :: Boudary_Condition type ( Boudary_Condition_Dirichlet ) :: Dirichlet type ( Boudary_Condition_Neumann ) :: Neumann end type Boudary_Condition type :: InitialConditionInfo integer ( int32 ) :: type real ( real64 ) :: value logical :: isSet end type InitialConditionInfo type :: InitialCondition type ( InitialConditionInfo ) :: Heat , Water , Stress end type InitialCondition #ifdef _MPI type :: MPIInfo integer ( int32 ) :: size , rank end type MPIInfo #endif type :: Basic_params integer ( int32 ) :: Element integer ( int32 ) :: Node integer ( int32 ) :: Shape integer ( int32 ) :: Dim integer ( int32 ) :: Region character (:), allocatable :: Calculation_timeUnit character (:), allocatable :: Input_timeUnit character (:), allocatable :: Output_timeUnit character (:), allocatable :: Interval_timeUnit integer ( int32 ) :: Calculation_step integer ( int32 ) :: CalculationPeriod integer ( int32 ) :: Interval logical :: isDisplayPrompt character (:), allocatable :: FileOutput end type Basic_params type :: Base_Density end type Base_Density type , extends ( Base_Density ) :: Type_Density_3Phase real ( real64 ) :: Soil , Water , Ice end type Type_Density_3Phase type , extends ( Base_Density ) :: Type_Density_2Phase real ( real64 ) :: Phase1 , Phase2 end type Type_Density_2Phase type , extends ( Base_Density ) :: Type_Density_1Phase real ( real64 ) :: Phase1 end type Type_Density_1Phase type :: Base_SpecificHeat end type Base_SpecificHeat type , extends ( Base_SpecificHeat ) :: Type_SpecificHeat_3Phase real ( real64 ) :: Soil , Water , Ice end type Type_SpecificHeat_3Phase type , extends ( Base_SpecificHeat ) :: Type_SpecificHeat_2Phase real ( real64 ) :: Phase1 , Phase2 end type Type_SpecificHeat_2Phase type , extends ( Base_SpecificHeat ) :: Type_SpecificHeat_1Phase real ( real64 ) :: Phase1 end type Type_SpecificHeat_1Phase type :: Base_ThermalConductivity end type Base_ThermalConductivity type , extends ( Base_ThermalConductivity ) :: Type_ThermalConductivity_3Phase real ( real64 ) :: Soil , Water , Ice end type Type_ThermalConductivity_3Phase type , extends ( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_2D type ( Vector2D ) :: dispersity end type Type_ThermalConductivity_3Phase_Dispersity_2D type , extends ( Type_ThermalConductivity_3Phase ) :: Type_ThermalConductivity_3Phase_Dispersity_3D type ( Vector3D ) :: dispersity end type Type_ThermalConductivity_3Phase_Dispersity_3D type , extends ( Base_ThermalConductivity ) :: Type_ThermalConductivity_2Phase real ( real64 ) :: Phase1 , Phase2 end type Type_ThermalConductivity_2Phase type , extends ( Base_ThermalConductivity ) :: Type_ThermalConductivity_1Phase real ( real64 ) :: Phase1 end type Type_ThermalConductivity_1Phase type :: Base_Ice real ( real64 ) :: LatentHeat end type Base_Ice type , extends ( Base_Ice ) :: Type_Ice_TRM real ( real64 ) :: Tf end type Type_Ice_TRM type , extends ( Base_Ice ) :: Type_Ice_GCC real ( real64 ) :: Tf integer ( int32 ) :: ModelType class ( Base_WRF ), allocatable :: WRF end type Type_Ice_GCC type , extends ( Base_Ice ) :: Type_Ice_EXP real ( real64 ) :: Tf , a end type Type_Ice_EXP type :: Type_Thermal class ( Base_Density ), allocatable :: Density class ( Base_SpecificHeat ), allocatable :: SpecificHeat class ( Base_ThermalConductivity ), allocatable :: ThermalConductivity real ( real64 ) :: Porosity class ( Base_Ice ), allocatable :: Ice end type Type_Thermal type :: Base_Hydraulic logical :: useImpedance class ( Base_Impedance ), allocatable :: Impedance integer ( int32 ) :: useKTDynamics class ( Base_KTDynamics ), allocatable :: KTDynamics logical :: useHCF class ( Base_HCF ), allocatable :: HCF real ( real64 ) :: Ks end type Base_Hydraulic type Base_Impedance end type Base_Impedance type , extends ( Base_Impedance ) :: Type_Impedance real ( real64 ) :: Omega end type Type_Impedance type :: Base_KTDynamics end type Base_KTDynamics type , extends ( Base_KTDynamics ) :: Type_KTDynamics real ( real64 ) :: kzero end type Type_KTDynamics type :: Type_Region_Flags logical :: isHeat , isWater , isStress logical :: is1Phase , is2Phase , is3Phase logical :: isCompression , isFrostHeavePressure , isDispersity logical :: isFrozen end type Type_Region_Flags type :: Type_Region integer ( int32 ) :: CalculationType integer ( int32 ) :: Modelnumber type ( Type_Thermal ) :: Thermal type ( Type_Region_Flags ) :: Flags end type Type_Region type :: DF real ( real64 ), allocatable :: new (:), old (:), pre (:), dif (:), div (:), tmp (:) end type DF type :: Flag logical :: isTRM , isGCC , isPower , isSwitchTRM , isSwitchOnceTRM logical :: isStdOut , isOutputAll , isOutput , isPrintLisMem logical , allocatable :: outOBS (:) end type Flag type :: CRS integer ( int32 ) :: nnz integer ( int32 ), allocatable :: Ptr (:), Ind (:) real ( real64 ), allocatable :: Val (:) end type CRS type :: Lis integer ( int32 ) :: TSolver , TOption , PSolver , POption , Maxiter real ( real64 ) :: Tol logical :: isOMP end type Lis type :: Observation2d integer ( int32 ) :: nObs , nObsType ! 1: Nodes integer ( int32 ), allocatable :: obsPoint (:) ! 2: Coordinate type ( DP2d ) :: obsCOO integer ( int32 ), allocatable :: nAreaObs (:) real ( real64 ), allocatable :: vAreaObs (:, :) end type Observation2d type :: HeatVariables type ( DF ) :: Cs , Cp , lambda , rho , Ca type ( DP2d ) :: Tgrad , TFlux integer ( int32 ), allocatable :: Phase (:) end type HeatVariables type HeatConstants type ( Phases ) :: Density , ThermalConductivity , SpecificHeat , HeatCapacity type ( Vector2d ) :: dispersity real ( real64 ) :: Porosity , LatentHeat end type HeatConstants type PowerModel real ( real64 ) :: phi , Tf , a real ( real64 ) :: Ca_max end type PowerModel type :: GCCModel real ( real64 ) :: thetaS , thetaR , alpha , n , m real ( real64 ) :: Tf real ( real64 ) :: Ca_max end type GCCModel type :: WRF_Parameters ! w1, w2は先に計算しておく real ( real64 ) :: thetaS , thetaR , alpha1 , alpha2 , n1 , n2 , m1 , m2 , hcrit , w1 , w2 end type WRF_Parameters type :: Base_WRF real ( real64 ) :: thetaS , thetaR end type Base_WRF type , extends ( Base_WRF ) :: Type_WRF_BC real ( real64 ) :: alpha1 , n1 end type Type_WRF_BC type , extends ( Base_WRF ) :: Type_WRF_VG real ( real64 ) :: alpha1 , n1 , m1 end type Type_WRF_VG type , extends ( Base_WRF ) :: Type_WRF_KO real ( real64 ) :: alpha1 , n1 end type Type_WRF_KO type , extends ( Base_WRF ) :: Type_WRF_MVG real ( real64 ) :: alpha1 , n1 , m1 , hcrit end type Type_WRF_MVG type , extends ( Base_WRF ) :: Type_WRF_Durner real ( real64 ) :: alpha1 , n1 , m1 , alpha2 , n2 , m2 , w1 , w2 end type Type_WRF_Durner type , extends ( Base_WRF ) :: Type_WRF_DVGCH real ( real64 ) :: alpha1 , n1 , m1 , n2 , m2 , w1 , w2 end type Type_WRF_DVGCH type :: HCF_Parameters real ( real64 ) :: thetaS , thetaR , alpha1 , alpha2 , n1 , n2 , m1 , m2 , hcrit , w1 , w2 real ( real64 ) :: Ks , kzero , l , Omega end type HCF_Parameters type :: Base_HCF real ( real64 ) :: thetaS , thetaR end type Base_HCF type , extends ( Base_HCF ) :: Type_HCF_BC real ( real64 ) :: alpha1 , n1 end type Type_HCF_BC type :: LatentHeatTreatment integer ( int32 ) :: useModel ! 20: GCC, 30: Power real ( real64 ) :: Lf , rhoI real ( real64 ) :: Cp_unf type ( GCCModel ) :: GCC type ( PowerModel ) :: Power end type LatentHeatTreatment type :: HeatFields type ( HeatVariables ) :: Variables type ( HeatConstants ) :: Constants type ( LatentHeatTreatment ) :: Latent type ( CRS ) :: LHS_A real ( real64 ), allocatable :: RA (:, :) real ( real64 ), allocatable :: Rhs (:) end type HeatFields type WaterVariables type ( DF ) :: Klh type ( DP2d ) :: wFlux , hGrad end type WaterVariables type WaterConstants type ( Phases ) :: HydraulicConductivity real ( real64 ) :: zeta end type WaterConstants type :: WaterFields type ( WaterVariables ) :: Variables type ( WaterConstants ) :: Constants type ( CRS ) :: LHS_A real ( real64 ), allocatable :: RA (:, :) real ( real64 ), allocatable :: Rhs (:) end type WaterFields type :: Geometry2d integer ( int32 ) :: element , node , shape , dim , ShCoe integer ( int32 ), allocatable :: pElement (:, :) type ( DP2d ) :: vCood real ( real64 ), allocatable :: eArea (:) type ( Shape ) :: Basis end type Geometry2d type :: Geometry_2D integer ( int32 ) :: Num_Elements , Num_Nodes , Num_Shape , Num_Dimention , Num_Shape_Type , Num_Region integer ( int32 ), allocatable :: Element (:, :) integer ( int32 ), allocatable :: Element_Region (:), COO_Region (:) type ( DP2d ) :: Nodes_2D real ( real64 ), allocatable :: Area (:) type ( Shape ) :: Shape_Function end type Geometry_2D type :: TimeInfo character ( 3 ) :: tUnit ! tUnit <- nmk 1: Second, 2: Minute, 3: Hour, 4: Day, 5: Month, 6: Year ! n : Calculation time unit, m: dt unit, k: output interval time unit real ( real64 ) :: cTime , cdt , cinterval real ( real64 ) :: ts , te , max_dt , min_dt , tconv real ( real64 ), pointer :: tst , dt , odt end type TimeInfo type :: Iteration integer ( int32 ) :: itermax , iNLmax , iNI integer ( int32 ), pointer :: iter , titer , iNL integer ( int32 ) :: digits_itermax end type Iteration type :: SolverInfo type ( Geometry2d ) :: N logical :: isHeat , isWater , isStress integer ( int32 ) :: nAnalysis , nFrTreat , nTimeDisc , isStdOut , outputFile type ( TimeInfo ) :: Time type ( Iteration ) :: Iter type ( Observation2d ) :: Obs type ( HeatFields ) :: Heat type ( WaterFields ) :: Water type ( BoudaryCondition ) :: BC type ( InitialCondition ) :: IC type ( DF ) :: mWater , mIce type ( DF ) :: T , P type ( DF ) :: Si , Sw type ( Lis ) :: Lis type ( Flag ) :: Flags character ( 64 ) :: fmt_Stdout , fmt_Fileout #ifdef _MPI type ( MPIInfo ) :: MPI #endif end type SolverInfo end module Types","tags":"","loc":"sourcefile/types.f90.html"},{"title":"Solve.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~solve.f90~~EfferentGraph sourcefile~solve.f90 Solve.f90 sourcefile~types.f90 Types.f90 sourcefile~solve.f90->sourcefile~types.f90 sourcefile~precon_jacobi.f90 Precon_jacobi.f90 sourcefile~solve.f90->sourcefile~precon_jacobi.f90 sourcefile~blas.f90 BLAS.f90 sourcefile~solve.f90->sourcefile~blas.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~solve.f90->sourcefile~allocate.f90 sourcefile~product.f90 Product.f90 sourcefile~solve.f90->sourcefile~product.f90 sourcefile~error.f90 error.f90 sourcefile~solve.f90->sourcefile~error.f90 sourcefile~precon_jacobi.f90->sourcefile~types.f90 sourcefile~blas.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~product.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~solve.f90~~AfferentGraph sourcefile~solve.f90 Solve.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Solver_Solve Source Code Solve.f90 Source Code module Solver_Solve use omp_lib use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: Allocate use :: Allocate_Structure use :: Solver_Precon_jacobi use :: Calculate_Product , only : SpMV => Matrix_Vector_Product_CRS use :: error use :: Calculate_BLAS , only : norm => norm_2 , dot => ddots implicit none private type ( CRS ) :: CRS_A real ( real64 ), allocatable , target :: work (:,:) ! Iterative Linear Solver type :: ILS private type ( CRS ) :: CRS_A real ( real64 ), dimension (:), pointer :: M , p , phat , s , shat , r , r0 , t , v , x , b contains procedure :: BiCGStab => Solver_BiCGStab procedure :: Chkerr => Solver_Check_Error final :: ILS_Destructor end type ILS interface ILS module procedure Solve_Initialize_BiCGStab end interface ! Direct Linear Solver type :: DLS private integer ( int32 ) :: N contains procedure :: LU => Solver_LU end type interface DLS module procedure Solve_Initialize_LU end interface public :: ILS public :: DLS contains type ( ILS ) function Solve_Initialize_BiCGStab ( Solver , MCRS ) implicit none type ( SolverInfo ), intent ( in ) :: Solver type ( CRS ), intent ( in ) :: MCRS call Allocate_Matrix ( work , Solver % N % node , 11 ) Solve_Initialize_BiCGStab % M => work (:, 1 ) Solve_Initialize_BiCGStab % p => work (:, 2 ) Solve_Initialize_BiCGStab % phat => work (:, 3 ) Solve_Initialize_BiCGStab % s => work (:, 4 ) Solve_Initialize_BiCGStab % shat => work (:, 5 ) Solve_Initialize_BiCGStab % r => work (:, 6 ) Solve_Initialize_BiCGStab % r0 => work (:, 7 ) Solve_Initialize_BiCGStab % t => work (:, 8 ) Solve_Initialize_BiCGStab % v => work (:, 9 ) Solve_Initialize_BiCGStab % x => work (:, 10 ) Solve_Initialize_BiCGStab % b => work (:, 11 ) call Duplicate_CRS ( MCRS , Solve_Initialize_BiCGStab % CRS_A ) end function Solve_Initialize_BiCGStab subroutine Solver_BiCGStab ( self , Solver , BiCG_A , BiCG_b , BiCG_x , status ) implicit none class ( ILS ) :: self type ( SolverInfo ), intent ( inout ) :: Solver type ( CRS ), intent ( in ) :: BiCG_A real ( real64 ), intent ( in ) :: BiCG_b (:) real ( real64 ), intent ( inout ) :: BiCG_x (:) integer ( int32 ), intent ( inout ) :: status real ( real64 ) :: rho , rho_old , alpha , beta , omega real ( real64 ) :: tol , resid real ( real64 ) :: ddot , dnrm2 integer ( int32 ) :: maxiter , iter , N , iN ! 1:Initialize N = Solver % N % node tol = 1.0d-12 maxiter = N * 100 maxiter = 50000 self % CRS_A % Val (:) = BiCG_A % Val (:) self % b (:) = BiCG_b (:) rho = 1.0d0 rho_old = 1.0d0 alpha = 1.0d0 beta = 1.0d0 omega = 1.0d0 do iN = 1 , N self % p ( iN ) = 0.0d0 self % s ( iN ) = 0.0d0 self % phat ( iN ) = 0.0d0 self % shat ( iN ) = 0.0d0 end do ! 2: Set an initial value x0 self % x (:) = 0.0d0 ! 3: r0 = b-Ax0 call SpMV ( self % CRS_A , self % x , self % r ) do iN = 1 , N self % r ( iN ) = self % b ( iN ) - self % r ( iN ) end do ! 4: Create preconditioned matrix call Create_Precond_Jacobi ( N , self % CRS_A , self % M ) ! 5: &#94;r0 = r0, (r*0, r0)!=0 self % r0 (:) = self % r (:) do iter = 1 , maxiter , 1 ! 7: (&#94;r0, rk) rho = dot ( N , self % r , self % r0 ) ! rho = ddot(N, self%r, 1, self%r0, 1) ! 8: rho check if ( rho == 0.0d0 ) then status = 0 BiCG_x (:) = self % x (:) return end if if ( iter == 1 ) then ! 10: p0 = r0 self % p (:) = self % r (:) else ! 12: beta = (rho / rho_old) * (alpha_k / omega_k) beta = ( rho / rho_old ) * ( alpha / omega ) ! 13: p_k = r_k + beta_k(p_(k-1) - omega_k * Av) do iN = 1 , N self % p ( iN ) = self % r ( iN ) + beta * ( self % p ( iN ) - omega * self % v ( iN )) end do end if ! 15: phat = M&#94;-1 * p call Apply_Precond_Jacobi ( N , self % M , self % p , self % phat ) ! 16: v = A * phat call SpMV ( self % CRS_A , self % phat , self % v ) ! 17: alpha_k = rho / (&#94;r0, v) alpha = rho / dot ( N , self % r0 , self % v ) ! alpha = rho / ddot(N, self%r0, 1, self%v, 1) ! 18: s = r_k - alpha_k * v do iN = 1 , N self % s ( iN ) = self % r ( iN ) - alpha * self % v ( iN ) end do ! 19: shat = M&#94;-1 * s call Apply_Precond_Jacobi ( N , self % M , self % s , self % shat ) ! 20: t = A * shat call SpMV ( self % CRS_A , self % shat , self % t ) ! 21: omega_k = (t,s)/(t,t) omega = dot ( N , self % t , self % s ) / dot ( N , self % t , self % t ) ! omega = ddot(N, self%t, 1, self%s, 1) / ddot(N, self%t, 1, self%t, 1) ! 22: omega breakdown check if ( omega == 0.0d0 ) then status = - 1 return end if do iN = 1 , N ! 23: x(i) = x(i-1) + alpha * M&#94;-1 p(i-1) + omega * M&#94;-1 s(i) self % x ( iN ) = self % x ( iN ) + alpha * self % phat ( iN ) + omega * self % shat ( iN ) end do do iN = 1 , N ! 24: r(i) = s(i-1) - omega * AM&#94;-1 s(i-1) self % r ( iN ) = self % s ( iN ) - omega * self % t ( iN ) end do ! 25: ||r_k+1||_2 ! resid = dnrm2(N, self%r(:), 1) resid = norm ( N , self % r (:)) if ( resid < tol ) then status = 0 BiCG_x (:) = self % x (:) return end if rho_old = rho end do status = - 2 end subroutine Solver_BiCGStab subroutine Solver_Check_Error ( self , ierr , time ) implicit none class ( ILS ) :: self integer ( int32 ), intent ( in ) :: ierr real ( real64 ), intent ( in ) :: time if ( ierr /= 0 ) then if ( ierr == - 1 ) then write ( * , '(a,es13.4,a)' ), \"BiCGStab:\" , time , \" Day: Temperature solver occures BREAKDOWN.\" else if ( ierr == - 2 ) then write ( * , '(a,es13.4,a)' ), \"BiCGStab:\" , time , \" Day: Temperature solver occures MAXITER.\" end if stop end if end subroutine Solver_Check_Error subroutine ILS_Destructor ( self ) implicit none type ( ILS ) :: self ! ポインタコンポーネントをnullify nullify ( self % M ) nullify ( self % p ) nullify ( self % phat ) nullify ( self % s ) nullify ( self % shat ) nullify ( self % r ) nullify ( self % r0 ) nullify ( self % t ) nullify ( self % v ) nullify ( self % x ) nullify ( self % b ) ! CRS_Aのリソースを解放 if ( allocated ( self % CRS_A % Val )) deallocate ( self % CRS_A % Val ) if ( allocated ( self % CRS_A % Ind )) deallocate ( self % CRS_A % Ind ) if ( allocated ( self % CRS_A % Ptr )) deallocate ( self % CRS_A % Ptr ) end subroutine ILS_Destructor type ( DLS ) function Solve_Initialize_LU ( Solver ) implicit none type ( SolverInfo ) :: Solver Solve_Initialize_LU % N = Solver % N % node end function Solve_Initialize_LU subroutine Solver_LU ( self , LU_A , LU_b , LU_x ) implicit none class ( DLS ) :: self real ( real64 ), intent ( inout ) :: LU_A (:,:), LU_b (:), LU_x (:) ! integer(int32), intent(in)    :: n integer ( int32 ) :: ipiv ( self % N ), info !* LU decomposition call Dgetrf ( self % N , self % N , LU_A , self % N , ipiv , info ) if ( info /= 0 ) call error_message ( 942 ) !* solve linear equation call Dgetrs ( 'N' , self % N , 1 , LU_A , self % N , ipiv , LU_b , self % N , info ) if ( info /= 0 ) call error_message ( 943 ) LU_x (:) = LU_b (:) end subroutine Solver_LU end module Solver_Solve","tags":"","loc":"sourcefile/solve.f90.html"},{"title":"error.f90 – Freezing Thawing Dynamics Simulation Solver","text":"Files dependent on this one sourcefile~~error.f90~~AfferentGraph sourcefile~error.f90 error.f90 sourcefile~setprojectpath.f90 SetProjectPath.f90 sourcefile~setprojectpath.f90->sourcefile~error.f90 sourcefile~output.f90 Output.f90 sourcefile~output.f90->sourcefile~error.f90 sourcefile~output.f90->sourcefile~setprojectpath.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~output.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~shape.f90 Shape.f90 sourcefile~shape.f90->sourcefile~error.f90 sourcefile~points.f90 Points.f90 sourcefile~shape.f90->sourcefile~points.f90 sourcefile~count.f90 Count.f90 sourcefile~count.f90->sourcefile~error.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~assemble.f90->sourcefile~error.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~assemble.f90->sourcefile~allocate.f90 sourcefile~area.f90 Area.f90 sourcefile~area.f90->sourcefile~error.f90 sourcefile~area.f90->sourcefile~points.f90 sourcefile~points.f90->sourcefile~error.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~error.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~solve.f90->sourcefile~allocate.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~error.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate_structure.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~allocate_structure.f90 sourcefile~heat.f90->sourcefile~count.f90 sourcefile~heat.f90->sourcefile~allocate.f90 sourcefile~observation.f90 Observation.f90 sourcefile~observation.f90->sourcefile~allocate.f90 sourcefile~observation.f90->sourcefile~points.f90 sourcefile~initialize.f90 Initialize.f90 sourcefile~initialize.f90->sourcefile~allocate.f90 sourcefile~convertcrs.f90 ConvertCRS.f90 sourcefile~convertcrs.f90->sourcefile~allocate.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules error Source Code error.f90 Source Code module error use , intrinsic :: iso_fortran_env , only : int32 , real64 use , intrinsic :: ieee_arithmetic , only : ieee_is_nan implicit none private public :: error_message public :: has_nan public :: value_in_range interface has_nan procedure :: has_nan_real64_scalar procedure :: has_nan_real64_rank1 procedure :: has_nan_real64_rank2 end interface interface value_in_range procedure :: value_in_range_int32 procedure :: value_in_range_real64 end interface contains !* Check whether the array has NaN or not logical function has_nan_real64_scalar ( scalar ) implicit none real ( real64 ), intent ( in ) :: scalar has_nan_real64_scalar = ieee_is_nan ( scalar ) end function has_nan_real64_scalar logical function has_nan_real64_rank1 ( array ) implicit none real ( real64 ), intent ( in ) :: array (:) has_nan_real64_rank1 = any ( ieee_is_nan ( array )) end function has_nan_real64_rank1 logical function has_nan_real64_rank2 ( array ) implicit none real ( real64 ), intent ( in ) :: array (:, :) has_nan_real64_rank2 = any ( ieee_is_nan ( array )) end function has_nan_real64_rank2 subroutine error_message ( err_number , myrank , opt , opt_file_name , copt1 , copt2 ) implicit none integer ( int32 ), intent ( in ) :: err_number real ( real64 ), optional , intent ( in ) :: opt integer ( int32 ), optional , intent ( in ) :: myrank character ( 256 ) :: msg character ( * ), optional , intent ( in ) :: opt_file_name , copt1 , copt2 integer ( int32 ) :: ierr if ( err_number == 901 ) then write ( msg , '(3a)' ) \"Error: Does not exit file '\" , trim ( adjustl ( opt_file_name )), \"'.\" else if ( err_number == 902 ) then write ( msg , '(3a)' ) \"Error: Can not open file '\" , trim ( adjustl ( opt_file_name )), \"'.\" else if ( err_number == 903 ) then write ( msg , '(3a)' ) \"Error: Selected \" , trim ( adjustl ( copt1 )), \" number is invalid.\" else if ( err_number == 904 ) then msg = \"Error: Opening file 'coordinate.in'\" else if ( err_number == 905 ) then msg = \"Error: Opening file 'top.in'\" else if ( err_number == 906 ) then msg = \"Error: Opening file 'coordinate.in'\" else if ( err_number == 911 ) then msg = \"Error: The number of elements must be positive.\" else if ( err_number == 912 ) then msg = \"Error: The number of nodal must be positive.\" else if ( err_number == 913 ) then msg = \"Error: The number of shape must be positive.\" else if ( err_number == 914 ) then msg = \"Error: The number of dimention must be positive.\" else if ( err_number == 915 ) then msg = \"Error: Dirichlet boundary conditions for water transport must be positive.\" else if ( err_number == 916 ) then msg = \"Error: Dirichlet boundary conditions for heat transport must be positive.\" else if ( err_number == 917 ) then msg = \"Error: The value of porosity must be positive.\" else if ( err_number == 918 ) then msg = \"Error: The value of density must be positive.\" else if ( err_number == 919 ) then msg = \"Error: The value of hydrulic conductivity must be positive.\" else if ( err_number == 920 ) then msg = \"Error: The value of thermal conductivity must be positive.\" else if ( err_number == 921 ) then msg = \"Error: The value of specific heat must be positive.\" else if ( err_number == 922 ) then msg = \"Error: The value of latent heat must be positive.\" else if ( err_number == 923 ) then msg = \"Error: The number of concering time information must be positive.\" else if ( err_number == 924 ) then msg = \"Error: The initial and coolant temperature are same.\" else if ( err_number == 928 ) then msg = \"Error: Two or more points are the same.\" else if ( err_number == 929 ) then msg = \"Error: The number of array elements must be positive.\" else if ( err_number == 930 ) then msg = \"Error: The number of matrix elements must be positive.\" else if ( err_number == 931 ) then msg = \"Error: opening output file\" else if ( err_number == 932 ) then msg = \"Error: Invalid element index\" else if ( err_number == 933 ) then msg = \"Error: Solver type is not selected.\" else if ( err_number == 934 ) then msg = \"Error: Freezing calculation is not selected.\" else if ( err_number == 941 ) then msg = \"Error: The solution to the simultaneous linear equations could not be found.\" else if ( err_number == 942 ) then msg = \"Error: LU decomposition could not be successed.\" else if ( err_number == 943 ) then msg = \"Error: The inverse matrix could not be found.\" else if ( err_number == 944 ) then msg = \"Error: The target result is too high.\" else if ( err_number == 945 ) then msg = \"Error: The target result is too low.\" else if ( err_number == 946 ) then msg = \"Error: The solution has been diverged.\" else if ( err_number == 951 ) then write ( msg , '(a)' ) \"Error: The number of vector elements must be positive.\" else if ( err_number == 952 ) then write ( msg , '(a)' ) \"Error: The number of matrix elements must be positive.\" else if ( err_number == 953 ) then write ( msg , '(a)' ) \"Error: Vector has already allocated.\" else if ( err_number == 954 ) then write ( msg , '(a)' ) \"Error: Matrix has already allocated.\" else if ( err_number == 955 ) then write ( msg , '(a)' ) \"Error: Pointer has already allocated.\" else msg = \"Error: Unknown error\" end if #ifdef _MPI if ( myrank == 0 ) then call MPI_Finalize ( ierr ) #endif write ( * , '(a)' ) msg stop #ifdef _MPI end if #endif end subroutine error_message function value_in_range_int32 ( value , min , max ) result ( in_range ) implicit none integer ( int32 ), intent ( in ) :: value , min , max logical :: in_range in_range = . true . if ( value < min . or . value > max ) then in_range = . false . end if end function value_in_range_int32 function value_in_range_real64 ( value , min , max ) result ( in_range ) implicit none real ( real64 ), intent ( in ) :: value , min , max logical :: in_range in_range = . true . if ( value < min . or . value > max ) then in_range = . false . end if end function value_in_range_real64 end module error","tags":"","loc":"sourcefile/error.f90.html"},{"title":"Precon_jacobi.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~precon_jacobi.f90~~EfferentGraph sourcefile~precon_jacobi.f90 Precon_jacobi.f90 sourcefile~types.f90 Types.f90 sourcefile~precon_jacobi.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~precon_jacobi.f90~~AfferentGraph sourcefile~precon_jacobi.f90 Precon_jacobi.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~precon_jacobi.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Solver_Precon_jacobi Source Code Precon_jacobi.f90 Source Code module Solver_Precon_jacobi use omp_lib use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none public :: Create_Precond_Jacobi public :: Apply_Precond_Jacobi contains subroutine Create_Precond_Jacobi ( N , A , M ) implicit none integer ( int32 ), intent ( in ) :: N type ( CRS ), intent ( in ) :: A real ( real64 ), intent ( inout ) :: M (:) integer ( int32 ) :: i , j M (:) = 0.0d0 !$omp parallel do private(i, j) do i = 1 , N do j = A % Ptr ( i - 1 ), A % Ptr ( i ) - 1 if (( i - 1 ) == A % Ind ( j )) then M ( i ) = 1.0d0 / A % Val ( j ) end if end do end do !$omp end parallel do end subroutine Create_Precond_Jacobi subroutine Apply_Precond_Jacobi ( N , M , r , z ) implicit none integer ( int32 ), intent ( in ) :: N real ( real64 ), intent ( in ) :: M (:) real ( real64 ), intent ( in ) :: r (:) real ( real64 ), intent ( inout ) :: z (:) integer ( int32 ) :: i ! $omp parallel do private(i) do i = 1 , N z ( i ) = M ( i ) * r ( i ) end do ! $omp end parallel do end subroutine Apply_Precond_Jacobi end module Solver_Precon_jacobi","tags":"","loc":"sourcefile/precon_jacobi.f90.html"},{"title":"InitCopy.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~initcopy.f90~~EfferentGraph sourcefile~initcopy.f90 InitCopy.f90 sourcefile~types.f90 Types.f90 sourcefile~initcopy.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Solver_InitCopy Source Code InitCopy.f90 Source Code module Solver_InitCopy use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types implicit none private public :: Init_Copy_Temperature public :: Init_Copy_Pressure contains subroutine Init_Copy_Temperature ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver Solver % T % old (:) = Solver % T % pre (:) Solver % Si % old (:) = Solver % Si % pre (:) Solver % mWater % old (:) = Solver % mWater % pre (:) Solver % mIce % old (:) = Solver % mIce % pre (:) Solver % Heat % Variables % Ca % old (:) = Solver % Heat % Variables % Ca % pre (:) end subroutine Init_Copy_Temperature subroutine Init_Copy_Pressure ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver Solver % P % old (:) = Solver % P % pre (:) Solver % Water % Variables % Klh % old (:) = Solver % Water % Variables % Klh % pre (:) end subroutine Init_Copy_Pressure end module Solver_InitCopy","tags":"","loc":"sourcefile/initcopy.f90.html"},{"title":"Initialize.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~initialize.f90~~EfferentGraph sourcefile~initialize.f90 Initialize.f90 sourcefile~types.f90 Types.f90 sourcefile~initialize.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~initialize.f90->sourcefile~allocate.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~initialize.f90->sourcefile~latentheat.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~error.f90 error.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Solver_Initialize Source Code Initialize.f90 Source Code module Solver_Initialize use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types use :: Allocate use :: Calculate_LatentHeat , only : Find_Ca_max implicit none private public :: Initialize_Solver contains subroutine Initialize_Solver ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: i call Allocate_Pointer ( Solver % Time % tst ) call Allocate_Pointer ( Solver % Time % dt ) call Allocate_Pointer ( Solver % Time % odt ) ! Time settings converting to seconds Solver % Time % ts = 0.0d0 Solver % Time % tst = 0.0d0 Solver % Time % te = Solver % Time % cTime * Convert_TimeUnit ( Solver % Time , 1 ) Solver % Time % dt = Solver % Time % cdt * Convert_TimeUnit ( Solver % Time , 2 ) Solver % Time % odt = Solver % Time % dt Solver % Time % max_dt = 1.0d-8 Solver % Time % min_dt = 30 0.0d0 Solver % Time % tconv = 1.0d0 / Convert_TimeUnit ( Solver % Time , 1 ) call Allocate_Pointer ( Solver % Iter % iter ) call Allocate_Pointer ( Solver % Iter % titer ) call Allocate_Pointer ( Solver % Iter % iNL ) ! Iteration settings Solver % Iter % iter = 1 Solver % Iter % itermax = nint ( Solver % Time % te / Solver % Time % cinterval ) Solver % Iter % titer = 1 Solver % Iter % iNL = 1 Solver % Iter % iNLmax = 50 Solver % Iter % iNI = 1 Solver % Iter % digits_itermax = int ( log10 ( dble ( Solver % Iter % itermax ))) + 1 ! Output format settings write ( Solver % fmt_Stdout , '(a,i0,a,i0,a)' ), & '(a,i' , Solver % Iter % digits_itermax , ',a,i' , Solver % Iter % digits_itermax , ',a,f9.4,a,f11.4,a)' write ( Solver % fmt_Fileout , '(a,i0,a,i0,a)' ), & '(2a,i' , Solver % Iter % digits_itermax , '.' , Solver % Iter % digits_itermax , ',a)' Solver % Heat % Latent % Cp_unf = Solver % Heat % Constants % HeatCapacity % soil * ( 1.0d0 - Solver % Heat % Constants % Porosity ) & + Solver % Heat % Constants % HeatCapacity % water * Solver % Heat % Constants % Porosity ! Find the maximum value of Ca call Find_Ca_max ( Solver % Heat ) if ( Solver % BC % numEdges > 0 ) then do i = 1 , Solver % BC % numEdges ! print*,(Solver%N%vCood%x(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%x(Solver%BC%Heat%Edges%x(i))),(Solver%N%vCood%y(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%y(Solver%BC%Heat%Edges%x(i))) Solver % BC % Heat % EdgesDistance ( i ) = sqrt (( Solver % N % vCood % x ( Solver % BC % Heat % Edges % y ( i )) - Solver % N % vCood % x ( Solver % BC % Heat % Edges % x ( i ))) ** 2.0d0 + ( Solver % N % vCood % y ( Solver % BC % Heat % Edges % y ( i )) - Solver % N % vCood % y ( Solver % BC % Heat % Edges % x ( i ))) ** 2.0d0 ) end do end if end subroutine Initialize_Solver function Convert_TimeUnit ( Time , num ) result ( conv_time ) implicit none type ( TimeInfo ), intent ( in ) :: Time integer ( int32 ), intent ( in ) :: num real ( real64 ) :: conv_time if ( Time % tUnit ( num : num ) == \"1\" ) then conv_time = 1.0d0 else if ( Time % tUnit ( num : num ) == \"2\" ) then conv_time = 6 0.d0 else if ( Time % tUnit ( num : num ) == \"3\" ) then conv_time = 6 0.d0 * 6 0.d0 else if ( Time % tUnit ( num : num ) == \"4\" ) then conv_time = 6 0.d0 * 6 0.d0 * 2 4.0d0 else if ( Time % tUnit ( num : num ) == \"5\" ) then conv_time = 6 0.d0 * 6 0.d0 * 2 4.0d0 * 3 0.d0 else if ( Time % tUnit ( num : num ) == \"6\" ) then conv_time = 6 0.d0 * 6 0.d0 * 2 4.0d0 * 36 5.0d0 end if end function Convert_TimeUnit end module Solver_Initialize","tags":"","loc":"sourcefile/initialize.f90.html"},{"title":"BinaryFinding.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~binaryfinding.f90~~EfferentGraph sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~types.f90 Types.f90 sourcefile~binaryfinding.f90->sourcefile~types.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~binaryfinding.f90->sourcefile~latentheat.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~binaryfinding.f90~~AfferentGraph sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~update.f90 Update.f90 sourcefile~update.f90->sourcefile~binaryfinding.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules RootFinding_BinaryFinding Source Code BinaryFinding.f90 Source Code module RootFinding_BinaryFinding use , intrinsic :: iso_fortran_env , only : real64 , int32 use , intrinsic :: IEEE_ARITHMETIC , only : ieee_is_nan use :: Types use :: Calculate_LatentHeat , only : Calc_LatentHeatTerm implicit none private real ( real64 ), parameter :: eps = 1.0d-10 integer ( int32 ), parameter :: max_iter = 100 public :: Binary_finding contains subroutine Binary_finding ( Solver , ind ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: ind real ( real64 ) :: Tnew real ( real64 ) :: x0 , x1 , x2 , f0 , f1 , err integer ( int32 ) :: i x0 = 0.0d0 x1 = Solver % T % new ( ind ) Tnew = Solver % T % new ( ind ) do i = 1 , max_iter f0 = Calc_LatentHeatTerm ( x0 , Tnew , Solver % Heat % Latent ) f1 = Calc_LatentHeatTerm ( x1 , Tnew , Solver % Heat % Latent ) if ( f0 * f1 > 0.0d0 ) then write ( * , \"(a)\" ), \"Binary_finding_Power: f0 * f1 > 0\" stop end if x2 = ( x0 + x1 ) / 2.0d0 if ( f0 * Calc_LatentHeatTerm ( x2 , Tnew , Solver % Heat % Latent ) < 0.0d0 ) then x1 = x2 else x0 = x2 end if if ( abs ( x1 - x0 ) < eps ) exit end do if ( i >= max_iter ) then if ( Solver % Flags % isGCC ) then write ( * , \"(a)\" ), \"Binary_finding_GCC: iteration limit exceeded\" else if ( Solver % Flags % isPower ) then write ( * , \"(a)\" ), \"Binary_finding_Power: iteration limit exceeded\" end if stop end if Solver % T % new ( ind ) = x2 end subroutine Binary_finding end module RootFinding_BinaryFinding","tags":"","loc":"sourcefile/binaryfinding.f90.html"},{"title":"SecantMethod.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~secantmethod.f90~~EfferentGraph sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~types.f90 Types.f90 sourcefile~secantmethod.f90->sourcefile~types.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~secantmethod.f90->sourcefile~latentheat.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~secantmethod.f90~~AfferentGraph sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~update.f90 Update.f90 sourcefile~update.f90->sourcefile~secantmethod.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules RootFinding_SecantMethod Source Code SecantMethod.f90 Source Code module RootFinding_SecantMethod use , intrinsic :: iso_fortran_env , only : real64 , int32 use , intrinsic :: IEEE_ARITHMETIC , only : ieee_is_nan use :: Types use :: Calculate_LatentHeat , only : Calc_LatentHeatTerm implicit none private real ( real64 ), parameter :: eps = 1.0d-10 integer ( int32 ), parameter :: max_iter = 100 public :: Secant_method contains subroutine Secant_method ( Solver , ind ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: ind real ( real64 ) :: Tnew real ( real64 ) :: x0 , x1 , x2 , f0 , f1 , err integer ( int32 ) :: i x0 = 0.0d0 x1 = Solver % T % new ( ind ) Tnew = Solver % T % new ( ind ) do i = 1 , max_iter f0 = Calc_LatentHeatTerm ( x0 , Tnew , Solver % Heat % Latent ) f1 = Calc_LatentHeatTerm ( x1 , Tnew , Solver % Heat % Latent ) if ( abs ( f1 - f0 ) < epsilon ( 1.0d0 )) then stop else err = f1 * ( x1 - x0 ) / ( f1 - f0 ) x2 = x1 - err if ( abs ( err ) < eps ) exit x0 = x1 x1 = x2 end if end do if ( i >= max_iter ) then if ( Solver % Flags % isGCC ) then write ( * , \"(a)\" ), \"Secant_method_GCC: iteration limit exceeded\" else if ( Solver % Flags % isPower ) then write ( * , \"(a)\" ), \"Secant_method_Power: iteration limit exceeded\" end if stop end if if ( ieee_is_nan ( x2 )) x2 = 0.0d0 Solver % T % new ( ind ) = x2 end subroutine Secant_method end module RootFinding_SecantMethod","tags":"","loc":"sourcefile/secantmethod.f90.html"},{"title":"Allocate_Structure.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~allocate_structure.f90~~EfferentGraph sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~error.f90 error.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~types.f90 Types.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~allocate.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~allocate_structure.f90~~AfferentGraph sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate_structure.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~allocate_structure.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Allocate_Structure Source Code Allocate_Structure.f90 Source Code module Allocate_Structure use :: error use :: Types use :: allocate use , intrinsic :: iso_fortran_env , only : int32 , real64 implicit none private public :: Allocate_DF public :: Allocate_DP2d public :: Allocate_BCinfo public :: Allocate_Solver public :: Allocate_Structure_Thermal_Type public :: Allocate_Structure_Ice_Type public :: Allocate_Structure_WRF_Type contains subroutine Allocate_DF ( ar_DF , n ) implicit none type ( DF ), intent ( inout ) :: ar_DF integer ( int32 ), intent ( in ) :: n call Allocate_Vector ( ar_DF % old , n ) call Allocate_Vector ( ar_DF % pre , n ) call Allocate_Vector ( ar_DF % new , n ) call Allocate_Vector ( ar_DF % dif , n ) call Allocate_Vector ( ar_DF % div , n ) call Allocate_Vector ( ar_DF % tmp , n ) end subroutine Allocate_DF subroutine Allocate_DP2d ( ar_DP2d , n ) implicit none type ( DP2d ), intent ( inout ) :: ar_DP2d integer ( int32 ), intent ( in ) :: n call Allocate_Vector ( ar_DP2d % x , n ) call Allocate_Vector ( ar_DP2d % y , n ) end subroutine Allocate_DP2d subroutine Allocate_INT2d ( ar_INT2d , n ) implicit none type ( INT2d ), intent ( inout ) :: ar_INT2d integer ( int32 ), intent ( in ) :: n call Allocate_Vector ( ar_INT2d % x , n ) call Allocate_Vector ( ar_INT2d % y , n ) end subroutine Allocate_INT2d subroutine Allocate_BCinfo ( BCinfo , nNode , nType , nEdge ) implicit none type ( BoudaryConditionInfo ), intent ( inout ) :: BCinfo integer ( int32 ), intent ( in ) :: nNode , nType integer ( int32 ), intent ( in ), optional :: nEdge call Allocate_Vector ( BCinfo % Node , nNode ) call Allocate_Vector ( BCinfo % TypeKey , nNode ) call Allocate_Vector ( BCinfo % type , nType ) call Allocate_Vector ( BCinfo % value , nType ) if ( present ( nEdge )) then ! print*, nEdge call Allocate_INT2d ( BCinfo % Edges , nEdge ) call Allocate_Vector ( BCinfo % EdgesDirection , nEdge ) call Allocate_Vector ( BCinfo % EdgesDistance , nEdge ) end if end subroutine Allocate_BCinfo subroutine Allocate_Solver ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver !* Allocate Geometry2d call Allocate_Matrix ( Solver % N % pElement , Solver % N % shape , Solver % N % element ) call Allocate_Vector ( Solver % N % vCood % x , Solver % N % node ) call Allocate_Vector ( Solver % N % vCood % y , Solver % N % node ) call Allocate_Vector ( Solver % N % eArea , Solver % N % element ) call Allocate_Matrix ( Solver % N % Basis % a , Solver % N % ShCoe , Solver % N % element ) call Allocate_Matrix ( Solver % N % Basis % b , Solver % N % ShCoe , Solver % N % element ) call Allocate_Matrix ( Solver % N % Basis % c , Solver % N % ShCoe , Solver % N % element ) if ( Solver % N % ShCoe == 4 ) call Allocate_Matrix ( Solver % N % Basis % d , Solver % N % ShCoe , Solver % N % element ) call Allocate_Vector ( Solver % mWater % old , Solver % N % node ) call Allocate_Vector ( Solver % mWater % pre , Solver % N % node ) call Allocate_Vector ( Solver % mIce % old , Solver % N % node ) call Allocate_Vector ( Solver % mIce % pre , Solver % N % node ) call Allocate_Vector ( Solver % mIce % dif , Solver % N % node ) call Allocate_DF ( Solver % Si , Solver % N % node ) if ( Solver % isHeat ) then call Allocate_DF ( Solver % Heat % Variables % Cs , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % Cp , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % lambda , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % rho , Solver % N % node ) call Allocate_DF ( Solver % Heat % Variables % Ca , Solver % N % node ) call Allocate_DF ( Solver % T , Solver % N % node ) call Allocate_Vector ( Solver % Heat % Rhs , Solver % N % node ) call Allocate_Vector ( Solver % Heat % Variables % Phase , Solver % N % node ) call Allocate_Matrix ( Solver % Heat % RA , Solver % N % node , Solver % N % node ) call Allocate_DP2d ( Solver % Heat % Variables % Tgrad , Solver % N % node ) call Allocate_DP2d ( Solver % Heat % Variables % TFlux , Solver % N % node ) end if if ( Solver % isWater ) then call Allocate_DF ( Solver % Water % Variables % Klh , Solver % N % node ) call Allocate_DP2d ( Solver % Water % Variables % wFlux , Solver % N % node ) call Allocate_DP2d ( Solver % Water % Variables % hGrad , Solver % N % node ) call Allocate_DF ( Solver % P , Solver % N % node ) call Allocate_Vector ( Solver % Water % Rhs , Solver % N % node ) call Allocate_Matrix ( Solver % Water % RA , Solver % N % node , Solver % N % node ) end if end subroutine Allocate_Solver subroutine Allocate_Structure_Thermal_Type ( Structure_Thermal , Flags ) implicit none type ( Type_Thermal ), intent ( inout ) :: Structure_Thermal type ( Type_Region_Flags ), intent ( in ) :: Flags if ( allocated ( Structure_Thermal % Density )) deallocate ( Structure_Thermal % Density ) if ( allocated ( Structure_Thermal % SpecificHeat )) deallocate ( Structure_Thermal % SpecificHeat ) if ( allocated ( Structure_Thermal % ThermalConductivity )) deallocate ( Structure_Thermal % ThermalConductivity ) if ( Flags % is1Phase ) then allocate ( Type_Density_1Phase :: Structure_Thermal % Density ) allocate ( Type_SpecificHeat_1Phase :: Structure_Thermal % SpecificHeat ) allocate ( Type_ThermalConductivity_1Phase :: Structure_Thermal % ThermalConductivity ) else if ( Flags % is2Phase ) then allocate ( Type_Density_2Phase :: Structure_Thermal % Density ) allocate ( Type_SpecificHeat_2Phase :: Structure_Thermal % SpecificHeat ) allocate ( Type_ThermalConductivity_2Phase :: Structure_Thermal % ThermalConductivity ) else if ( Flags % is3Phase ) then allocate ( Type_Density_3Phase :: Structure_Thermal % Density ) allocate ( Type_SpecificHeat_3Phase :: Structure_Thermal % SpecificHeat ) if ( Flags % isDispersity ) then allocate ( Type_ThermalConductivity_3Phase_Dispersity_2D :: Structure_Thermal % ThermalConductivity ) ! allocate (Type_ThermalConductivity_3Phase_Dispersity_3D :: Structure_Thermal%ThermalConductivity) else allocate ( Type_ThermalConductivity_3Phase :: Structure_Thermal % ThermalConductivity ) end if end if end subroutine Allocate_Structure_Thermal_Type subroutine Allocate_Structure_Ice_Type ( Structure_Thermal , QiceModelType ) implicit none type ( Type_Thermal ), intent ( inout ) :: Structure_Thermal integer ( int32 ), intent ( in ) :: QiceModelType if ( allocated ( Structure_Thermal % Ice )) deallocate ( Structure_Thermal % Ice ) if ( QiceModelType == 1 ) then allocate ( Type_Ice_TRM :: Structure_Thermal % Ice ) else if ( QiceModelType == 2 ) then allocate ( Type_Ice_GCC :: Structure_Thermal % Ice ) else if ( QiceModelType == 3 ) then allocate ( Type_Ice_EXP :: Structure_Thermal % Ice ) end if end subroutine Allocate_Structure_Ice_Type subroutine Allocate_Structure_WRF_Type ( Structure_Thermal , WRFModelType ) implicit none type ( Type_Thermal ), intent ( inout ) :: Structure_Thermal integer ( int32 ), intent ( in ) :: WRFModelType ! Iceが割り当て済みかチェック if (. not . allocated ( Structure_Thermal % Ice )) then print * , \"Error: Ice structure is not allocated.\" return end if select type ( Ice => Structure_Thermal % Ice ) type is ( Type_Ice_GCC ) if ( WRFModelType == 1 ) then allocate ( Type_WRF_BC :: Ice % WRF ) else if ( WRFModelType == 2 ) then allocate ( Type_WRF_VG :: Ice % WRF ) else if ( WRFModelType == 3 ) then allocate ( Type_WRF_KO :: Ice % WRF ) else if ( WRFModelType == 4 ) then allocate ( Type_WRF_MVG :: Ice % WRF ) else if ( WRFModelType == 5 ) then allocate ( Type_WRF_Durner :: Ice % WRF ) else if ( WRFModelType == 6 ) then allocate ( Type_WRF_DVGCH :: Ice % WRF ) else print * , \"Error: WRFModelType is not defined.\" end if end select end subroutine Allocate_Structure_WRF_Type end module Allocate_Structure","tags":"","loc":"sourcefile/allocate_structure.f90.html"},{"title":"Allocate.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~allocate.f90~~EfferentGraph sourcefile~allocate.f90 Allocate.f90 sourcefile~error.f90 error.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~types.f90 Types.f90 sourcefile~allocate.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~allocate.f90~~AfferentGraph sourcefile~allocate.f90 Allocate.f90 sourcefile~output.f90 Output.f90 sourcefile~output.f90->sourcefile~allocate.f90 sourcefile~observation.f90 Observation.f90 sourcefile~observation.f90->sourcefile~allocate.f90 sourcefile~convertcrs.f90 ConvertCRS.f90 sourcefile~convertcrs.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~assemble.f90->sourcefile~allocate.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~heat.f90 Heat.f90 sourcefile~heat.f90->sourcefile~allocate.f90 sourcefile~heat.f90->sourcefile~allocate_structure.f90 sourcefile~solve.f90 Solve.f90 sourcefile~solve.f90->sourcefile~allocate.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~initialize.f90 Initialize.f90 sourcefile~initialize.f90->sourcefile~allocate.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate_structure.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Allocate Source Code Allocate.f90 Source Code module Allocate use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: error use :: Types implicit none private interface Allocate_Vector procedure :: Check_Allocate_rank1_int32 procedure :: Check_Allocate_rank1_real64 procedure :: Check_Allocate_rank1_logical procedure :: Check_Allocate_rank1_int32_specify procedure :: Check_Allocate_rank1_real64_specify end interface interface Allocate_Matrix procedure :: Check_Allocate_rank2_int32 procedure :: Check_Allocate_rank2_real64 end interface interface Allocate_Pointer procedure :: Check_Allocate_Pointer_real64 procedure :: Check_Allocate_Pointer_int32 end interface public :: Allocate_Vector public :: Allocate_Matrix public :: Allocate_Pointer public :: Duplicate_CRS contains subroutine Check_Allocate_rank1_int32 ( iar , ar_size ) implicit none integer ( int32 ), intent ( in ) :: ar_size integer ( int32 ), intent ( inout ), allocatable :: iar (:) if ( ar_size <= 0 ) call error_message ( 951 ) if (. not . allocated ( iar )) then allocate ( iar ( ar_size )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_int32 subroutine Check_Allocate_rank1_real64 ( dar , ar_size ) implicit none integer ( int32 ), intent ( in ) :: ar_size real ( real64 ), intent ( inout ), allocatable :: dar (:) if ( ar_size <= 0 ) call error_message ( 951 ) if (. not . allocated ( dar )) then allocate ( dar ( ar_size )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_real64 subroutine Check_Allocate_rank1_logical ( lar , ar_size ) implicit none integer ( int32 ), intent ( in ) :: ar_size logical , intent ( inout ), allocatable :: lar (:) if ( ar_size <= 0 ) call error_message ( 951 ) if (. not . allocated ( lar )) then allocate ( lar ( ar_size )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_logical subroutine Check_Allocate_rank1_int32_specify ( iar , ar_first , ar_last ) implicit none integer ( int32 ), intent ( in ) :: ar_first , ar_last integer ( int32 ), intent ( inout ), allocatable :: iar (:) if (. not . allocated ( iar )) then allocate ( iar ( ar_first : ar_last )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_int32_specify subroutine Check_Allocate_rank1_real64_specify ( dar , ar_first , ar_last ) implicit none integer ( int32 ), intent ( in ) :: ar_first , ar_last real ( real64 ), intent ( inout ), allocatable :: dar (:) if (. not . allocated ( dar )) then allocate ( dar ( ar_first : ar_last )) else call error_message ( 953 ) end if end subroutine Check_Allocate_rank1_real64_specify subroutine Check_Allocate_rank2_int32 ( imt , mt_size_1 , mt_size_2 ) implicit none integer ( int32 ), intent ( in ) :: mt_size_1 , mt_size_2 integer ( int32 ), intent ( inout ), allocatable :: imt (:,:) if ( mt_size_1 <= 0 . or . mt_size_2 <= 0 ) call error_message ( 952 ) if (. not . allocated ( imt )) then allocate ( imt ( mt_size_1 , mt_size_2 )) else call error_message ( 954 ) end if end subroutine Check_Allocate_rank2_int32 subroutine Check_Allocate_rank2_real64 ( dmt , mt_size_1 , mt_size_2 ) implicit none integer ( int32 ), intent ( in ) :: mt_size_1 , mt_size_2 real ( real64 ), intent ( inout ), allocatable :: dmt (:,:) if ( mt_size_1 <= 0 . or . mt_size_2 <= 0 ) call error_message ( 952 ) if (. not . allocated ( dmt )) then allocate ( dmt ( mt_size_1 , mt_size_2 )) else call error_message ( 954 ) end if end subroutine Check_Allocate_rank2_real64 subroutine Check_Allocate_Pointer_int32 ( iptr ) implicit none integer ( int32 ), pointer :: iptr if (. not . associated ( iptr )) then allocate ( iptr ) else call error_message ( 955 ) end if end subroutine Check_Allocate_Pointer_int32 subroutine Check_Allocate_Pointer_real64 ( dptr ) implicit none real ( real64 ), pointer :: dptr if (. not . associated ( dptr )) then allocate ( dptr ) else call error_message ( 955 ) end if end subroutine Check_Allocate_Pointer_real64 subroutine Duplicate_CRS ( A , B ) implicit none type ( CRS ), intent ( in ) :: A type ( CRS ), intent ( inout ) :: B B % nnz = A % nnz if (. not . allocated ( B % Ptr )) then allocate ( B % Ptr , source = A % Ptr ) else ! call error_message(951) end if if (. not . allocated ( B % Ind )) then allocate ( B % Ind , source = A % Ind ) else ! call error_message(951) end if if (. not . allocated ( B % val )) then allocate ( B % val , source = A % Val ) else ! call error_message(951) end if B % val = 0.0d0 end subroutine Duplicate_CRS end module Allocate","tags":"","loc":"sourcefile/allocate.f90.html"},{"title":"FixInitialCondition.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~fixinitialcondition.f90~~EfferentGraph sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~types.f90 Types.f90 sourcefile~fixinitialcondition.f90->sourcefile~types.f90 sourcefile~update.f90 Update.f90 sourcefile~fixinitialcondition.f90->sourcefile~update.f90 sourcefile~fixboundarycondition.f90 FixBoundaryCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~fixboundarycondition.f90 sourcefile~allocate_structure.f90 Allocate_Structure.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate_structure.f90 sourcefile~allocate.f90 Allocate.f90 sourcefile~fixinitialcondition.f90->sourcefile~allocate.f90 sourcefile~error.f90 error.f90 sourcefile~fixinitialcondition.f90->sourcefile~error.f90 sourcefile~assemble.f90 Assemble.f90 sourcefile~fixinitialcondition.f90->sourcefile~assemble.f90 sourcefile~solve.f90 Solve.f90 sourcefile~fixinitialcondition.f90->sourcefile~solve.f90 sourcefile~update.f90->sourcefile~types.f90 sourcefile~secantmethod.f90 SecantMethod.f90 sourcefile~update.f90->sourcefile~secantmethod.f90 sourcefile~binaryfinding.f90 BinaryFinding.f90 sourcefile~update.f90->sourcefile~binaryfinding.f90 sourcefile~fixboundarycondition.f90->sourcefile~types.f90 sourcefile~findind.f90 FindInd.f90 sourcefile~fixboundarycondition.f90->sourcefile~findind.f90 sourcefile~allocate_structure.f90->sourcefile~types.f90 sourcefile~allocate_structure.f90->sourcefile~allocate.f90 sourcefile~allocate_structure.f90->sourcefile~error.f90 sourcefile~allocate.f90->sourcefile~types.f90 sourcefile~allocate.f90->sourcefile~error.f90 sourcefile~assemble.f90->sourcefile~types.f90 sourcefile~assemble.f90->sourcefile~allocate_structure.f90 sourcefile~assemble.f90->sourcefile~allocate.f90 sourcefile~assemble.f90->sourcefile~error.f90 sourcefile~assemble.f90->sourcefile~findind.f90 sourcefile~product.f90 Product.f90 sourcefile~assemble.f90->sourcefile~product.f90 sourcefile~solve.f90->sourcefile~types.f90 sourcefile~solve.f90->sourcefile~allocate_structure.f90 sourcefile~solve.f90->sourcefile~allocate.f90 sourcefile~solve.f90->sourcefile~error.f90 sourcefile~precon_jacobi.f90 Precon_jacobi.f90 sourcefile~solve.f90->sourcefile~precon_jacobi.f90 sourcefile~blas.f90 BLAS.f90 sourcefile~solve.f90->sourcefile~blas.f90 sourcefile~solve.f90->sourcefile~product.f90 sourcefile~precon_jacobi.f90->sourcefile~types.f90 sourcefile~blas.f90->sourcefile~types.f90 sourcefile~secantmethod.f90->sourcefile~types.f90 sourcefile~latentheat.f90 LatentHeat.f90 sourcefile~secantmethod.f90->sourcefile~latentheat.f90 sourcefile~findind.f90->sourcefile~types.f90 sourcefile~binaryfinding.f90->sourcefile~types.f90 sourcefile~binaryfinding.f90->sourcefile~latentheat.f90 sourcefile~product.f90->sourcefile~types.f90 sourcefile~latentheat.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Condition_FixInitialCondition Source Code FixInitialCondition.f90 Source Code module Condition_FixInitialCondition use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types , g => GravityAcceleration use :: Allocate , only : Duplicate_CRS use :: Allocate_Structure use :: error use :: Calculate_Update use :: Condition_FixBoundaryCondition use :: Matrix_Assemble , only : Assemble_GM_Heat_IC , Assemble_GM_Water_IC use :: Solver_Solve implicit none private public :: Fix_InitialCondition contains subroutine Fix_InitialCondition ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver if ( Solver % isHeat ) then if ( Solver % IC % Heat % type == 1 ) then call Fix_InitialCondtion_Constant_Heat ( Solver ) else if ( Solver % IC % Heat % type == 2 ) then call Fix_InitialCondition_Gradient_Heat ( Solver ) Solver % IC % Heat % isSet = . false . end if if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) \"Set initial value of Temperature.\" end if if ( Solver % isWater ) then if ( Solver % IC % Water % type == 1 ) then call Fix_InitialCondtion_Constant_Water ( Solver ) else if ( Solver % IC % Water % type == 2 ) then call Fix_InitialCondition_Gradient_Water ( Solver ) Solver % IC % Water % isSet = . false . end if if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) \"Set initial value of Pressure.\" end if if ( Solver % isStress ) then ! To be implemented ! if (Solver%IC%Stress%type == 1) then !     call Fix_InitialCondtion_Constant(Solver) ! else if (Solver%IC%Stress%type == 2) then !     call Fix_InitialCondition_Gradient(Solver) ! end if ! if (Solver%Flags%isStdOut) write(*,'(a)') \"Set initial value of Stress.\" end if call Fix_InitialCondition_FreezingRate ( Solver ) end subroutine Fix_InitialCondition subroutine Fix_InitialCondtion_Constant_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , iBC integer ( int32 ) :: ntBC , nBC do iN = 1 , Solver % N % node Solver % T % pre ( iN ) = Solver % IC % Heat % Value end do ! 初期温度場への境界条件の設定 do iBC = 1 , Solver % BC % numNode ntBC = Solver % BC % Heat % Type ( Solver % BC % Heat % TypeKey ( iBC )) if ( 10 <= ntBC . and . ntBC <= 19 ) then Solver % T % pre ( Solver % BC % Heat % Node ( iBC )) = Solver % BC % Heat % Value ( Solver % BC % Heat % TypeKey ( iBC )) end if end do end subroutine Fix_InitialCondtion_Constant_Heat subroutine Fix_InitialCondtion_Constant_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , iBC integer ( int32 ) :: ntBC , nBC do iN = 1 , Solver % N % node Solver % P % pre ( iN ) = Solver % IC % Water % Value end do ! 初期圧力場への境界条件の設定 do iBC = 1 , Solver % BC % numNode ntBC = Solver % BC % Water % Type ( Solver % BC % Water % TypeKey ( iBC )) if ( 20 <= ntBC . and . ntBC <= 29 ) then Solver % P % pre ( Solver % BC % Water % Node ( iBC )) = Solver % BC % Water % Value ( Solver % BC % Water % TypeKey ( iBC )) end if end do end subroutine Fix_InitialCondtion_Constant_Water subroutine Fix_InitialCondition_Gradient_Heat ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver type ( ILS ), allocatable :: ILEQ integer ( int32 ) :: ierr ILEQ = ILS ( Solver , Solver % Heat % LHS_A ) call Update_Parameters_Heat ( Solver ) call Assemble_GM_Heat_IC ( Solver ) call Fix_BoundaryConditions ( Solver , Temperature ) call ILEQ % BiCGStab ( Solver , Solver % Heat % LHS_A , Solver % Heat % Rhs , Solver % T % pre , ierr ) call ILEQ % Chkerr ( ierr , 0.0d0 ) deallocate ( ILEQ ) end subroutine Fix_InitialCondition_Gradient_Heat subroutine Fix_InitialCondition_Gradient_Water ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver type ( DLS ) :: DLEQ Solver % Si % old (:) = Solver % Si % pre (:) Solver % Si % pre (:) = 0.0d0 call Update_Parameters_Water ( Solver ) Solver % Si % pre (:) = Solver % Si % old (:) call Assemble_GM_Water_IC ( Solver ) call Fix_BoundaryConditions ( Solver , Pressure ) DLEQ = DLS ( Solver ) call DLEQ % LU ( Solver % Water % RA , Solver % Water % Rhs , Solver % P % pre ) end subroutine Fix_InitialCondition_Gradient_Water subroutine Fix_InitialCondition_FreezingRate ( Solver ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ) :: iN , iBC real ( real64 ) :: Tf ! GCC model real ( real64 ) :: Qs , Qr , alpha , n , m , Lf real ( real64 ), parameter :: TtoK = 27 3.15d0 ! Power model real ( real64 ) :: a if ( Solver % Flags % isTRM ) then do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < 0.0d0 ) then Solver % Si % pre ( iN ) = 1.0d0 else Solver % Si % pre ( iN ) = 0.0d0 end if end do else if ( Solver % Flags % isGCC ) then Qs = Solver % Heat % Latent % GCC % thetaS Qr = Solver % Heat % Latent % GCC % thetaR alpha = Solver % Heat % Latent % GCC % alpha n = Solver % Heat % Latent % GCC % n m = Solver % Heat % Latent % GCC % m Lf = Solver % Heat % Latent % Lf Tf = Solver % Heat % Latent % GCC % Tf do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = (( Qs - Qr ) * ( 1.0d0 - ( 1.0d0 + abs ( alpha * Lf * log (( Solver % T % pre ( iN ) + TtoK ) / TtoK ) / g ) & ** n ) ** ( - m ))) / Qs else Solver % Si % pre ( iN ) = 0.0d0 end if end do else if ( Solver % Flags % isPower ) then Tf = Solver % Heat % Latent % Power % Tf a = Solver % Heat % Latent % Power % a do iN = 1 , Solver % N % node if ( Solver % T % pre ( iN ) < Tf ) then Solver % Si % pre ( iN ) = 1.0d0 - ( 1.0d0 - Solver % T % pre ( iN ) + Tf ) ** a else Solver % Si % pre ( iN ) = 0.0d0 end if end do end if if ( Solver % Flags % isStdOut ) write ( * , '(a)' ) \"Set initial value of Freezing rate.\" end subroutine Fix_InitialCondition_FreezingRate end module Condition_FixInitialCondition","tags":"","loc":"sourcefile/fixinitialcondition.f90.html"},{"title":"FixBoundaryCondition.f90 – Freezing Thawing Dynamics Simulation Solver","text":"This file depends on sourcefile~~fixboundarycondition.f90~~EfferentGraph sourcefile~fixboundarycondition.f90 FixBoundaryCondition.f90 sourcefile~types.f90 Types.f90 sourcefile~fixboundarycondition.f90->sourcefile~types.f90 sourcefile~findind.f90 FindInd.f90 sourcefile~fixboundarycondition.f90->sourcefile~findind.f90 sourcefile~findind.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~fixboundarycondition.f90~~AfferentGraph sourcefile~fixboundarycondition.f90 FixBoundaryCondition.f90 sourcefile~fixinitialcondition.f90 FixInitialCondition.f90 sourcefile~fixinitialcondition.f90->sourcefile~fixboundarycondition.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Condition_FixBoundaryCondition Source Code FixBoundaryCondition.f90 Source Code module Condition_FixBoundaryCondition use , intrinsic :: iso_fortran_env , only : int32 , real64 use :: Types , Tmp => Temperature , Prs => Pressure , Sts => Stress use :: Matrix_FindInd implicit none private public :: Fix_BoundaryConditions contains subroutine Fix_BoundaryConditions ( Solver , inTarget ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: inTarget integer ( int32 ) :: iBC , i integer ( int32 ) :: iBCType integer ( int32 ) :: p1 , p2 do iBC = 1 , Solver % BC % numNode if ( inTarget == Tmp ) then iBCType = Solver % BC % Heat % type ( Solver % BC % Heat % TypeKey ( iBC )) if ( 10 <= iBCType . and . iBCType <= 19 ) then call Fix_DirichletBoundaryCondition_Temperature ( Solver , iBC ) ! call Fix_DirichletBoundaryCondition_Temperature_F(Solver, iBC) end if else if ( inTarget == Prs ) then iBCType = Solver % BC % Water % type ( Solver % BC % Water % TypeKey ( iBC )) if ( 10 <= iBCType . and . iBCType <= 19 ) then ! call Fix_DirichletBoundaryCondition_Water(Solver, iBC) call Fix_DirichletBoundaryCondition_Water_F ( Solver , iBC ) end if end if ! stop ! Solver%Water%Variables%wFlux%y(Solver%BC%Water%TypeKey(iBC)) = 0.0d0 ! if (Solver%BC%Water%TypeKey(iBC) == 4) Solver%Water%Variables%wFlux%x(Solver%BC%Water%TypeKey(iBC)) = 0.0d0 end do if ( inTarget == Tmp . and . Solver % BC % numEdges > 0 ) then do i = 1 , Solver % BC % numEdges p1 = Solver % BC % Heat % Edges % x ( i ) p2 = Solver % BC % Heat % Edges % y ( i ) Solver % Heat % Rhs ( p1 ) = Solver % Heat % Rhs ( p1 ) - ( 2.0d0 * Solver % Heat % Variables % TFlux % x ( p1 ) + Solver % Heat % Variables % TFlux % x ( p2 )) * Solver % BC % Heat % EdgesDistance ( i ) / 6.0d0 Solver % Heat % Rhs ( p2 ) = Solver % Heat % Rhs ( p2 ) - ( Solver % Heat % Variables % TFlux % x ( p1 ) + 2.0d0 * Solver % Heat % Variables % TFlux % x ( p2 )) * Solver % BC % Heat % EdgesDistance ( i ) / 6.0d0 ! print*,Solver%Heat%Rhs(p1),Solver%Heat%Rhs(p2) ! print*,Solver%Heat%Variables%TFlux%x(p1),Solver%Heat%Variables%TFlux%x(p2) ! print*,(Solver%N%vCood%x(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%x(Solver%BC%Heat%Edges%x(i))),(Solver%N%vCood%y(Solver%BC%Heat%Edges%y(i)) - Solver%N%vCood%y(Solver%BC%Heat%Edges%x(i))) end do ! print*, Solver%BC%Heat%EdgesDistance(:) ! print *, \"Water\" ! stop end if end subroutine Fix_BoundaryConditions subroutine Fix_DirichletBoundaryCondition_Temperature ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Heat % Node ( iBC ) call Find_CRS_Index ( Solver % Heat % LHS_A , iCol , iCol , ind ) ps = Solver % Heat % LHS_A % Ptr ( iCol - 1 ) pe = Solver % Heat % LHS_A % Ptr ( iCol ) - 1 Solver % Heat % LHS_A % val ( ps : pe ) = 0.0d0 Solver % Heat % LHS_A % val ( ind ) = 1.0d0 Solver % Heat % Rhs ( iCol ) = Solver % BC % Heat % value ( Solver % BC % Heat % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Temperature subroutine Fix_DirichletBoundaryCondition_Temperature_F ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Heat % Node ( iBC ) ! print*,iCol,iBC Solver % Heat % RA ( iCol , :) = 0.0d0 Solver % Heat % RA ( iCol , iCol ) = 1.0d0 Solver % Heat % Rhs ( iCol ) = Solver % BC % Heat % value ( Solver % BC % Heat % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Temperature_F subroutine Fix_DirichletBoundaryCondition_Water ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Water % Node ( iBC ) call Find_CRS_Index ( Solver % Water % LHS_A , iCol , iCol , ind ) ps = Solver % Water % LHS_A % Ptr ( iCol - 1 ) pe = Solver % Water % LHS_A % Ptr ( iCol ) - 1 Solver % Water % LHS_A % val ( ps : pe ) = 0.0d0 Solver % Water % LHS_A % val ( ind ) = 1.0d0 Solver % Water % Rhs ( iCol ) = Solver % BC % Water % value ( Solver % BC % Water % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Water subroutine Fix_DirichletBoundaryCondition_Water_F ( Solver , iBC ) implicit none type ( SolverInfo ), intent ( inout ) :: Solver integer ( int32 ), intent ( in ) :: iBC integer ( int32 ) :: iCol , ind , ps , pe iCol = Solver % BC % Water % Node ( iBC ) Solver % Water % RA ( iCol , :) = 0.0d0 Solver % Water % RA ( iCol , iCol ) = 1.0d0 Solver % Water % Rhs ( iCol ) = Solver % BC % Water % value ( Solver % BC % Water % TypeKey ( iBC )) end subroutine Fix_DirichletBoundaryCondition_Water_F end module Condition_FixBoundaryCondition","tags":"","loc":"sourcefile/fixboundarycondition.f90.html"},{"title":"Read Me – Freezing Thawing Dynamics Simulation Solver","text":"Freezing Thawing Dynamics Simulation Solver Goals and Motivations Scope Install Software environment Fortran 90 and later Intel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2024.1.0 Build 20240308 Lis version 2.1.3 GNU Make 3.81 Operation System Host OS エディション  Windows 11 Pro バージョン   23H2 インストール日 2024/05/24 OS ビルド  22631.3958 エクスペリエンス    Windows Feature Experience Pack 1000.22700.1026.0 Windows subsytem for linux (WSL2) Ubuntu 24.04.1 LTS Red Hat Enterprise Linux release 9.4 (Plow) Execution environment CPU Intel Core i9 14900K MB Z790 Steel Legend WiFi Memory DDR5-5600 32GB×4 GPU NVIDIA GeForce RTX 4060Ti Usage Contributions Links","tags":"","loc":"page/index.html"},{"title":"license – Freezing Thawing Dynamics Simulation Solver","text":"Copyright (C) 2025 Kikuchi Shun Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. lis lisence\nTERMS AND CONDITIONS OF LICENSE FOR THE SOFTWARE Copyright (C) 2005 The Scalable Software Infrastructure Project, \nsupported by ``Development of Software Infrastructure for Large Scale\nScientific Simulation'' Team, CREST, JST. Akira Nishida, CREST team director, JST. All rights reserved. JSON-Fortran: A Modern Fortran JSON API https://github.com/jacobwilliams/json-fortran Copyright (c) 2014-2024, Jacob Williams\nAll rights reserved.","tags":"","loc":"page/lisence.html"}]}